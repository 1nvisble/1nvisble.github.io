<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中equals方法和hashCode方法</title>
    <url>/2021/06/15/Java%E4%B8%ADequals%E6%96%B9%E6%B3%95%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件构造课上，之前介绍了ADT，讲了RI、AF，AF，及抽象函数解释了该类型是如何将内部表示映射为使用者理解的抽象数据的。那如何判断这些ADT的相等性，这就涉及到了java中很重要的一个知识点，equals方法和hashCode方法。</p>
<h2 id="VS-equals"><a href="#VS-equals" class="headerlink" title="== VS equals()"></a>== VS equals()</h2><p>我们在C中常使用==操作来判断相等。而在Java中，不仅提供了==来判断相等</p>
<p>，还提供了equals()方法，其主要用于比较ADT的相等。</p>
<h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p>==这个相等判断比较的是两个比较对象的索引的相等，或者说是引用相等。如果两个索引指向同一块存储区域，那它们就是==的，也就是相等的。在snophot图中，<code>==</code>就意味着两个比较对象的箭头指向同一个对象或值。</p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><p>equals方法操作比较的是两个对象（object）的内容，或者说，比较的是对象值相等。每当我们定义一个ADT时，我们需要判断，对于这个ADT来说对象值相等是如何定义的，或者说如何实现equals方法。</p>
<p>假设存在一个Person的ADT，其成员属性有两个，一个为name，一个为number。</p>
<p>那我如和判断Person这个ADT实例的两个对象是否相等呢？是判断其name和number相等就算相等，还是只要判断name就算相等，可能一个人有多个手机号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这时候我们要想清楚如何实现equals方法。</p>
<p>我们先看java给出的equal方法的定义，其是在Object类中就定义的，我们又知道Object类是所有类的父类或基类，如果不在子类中重写equals()方法，那么默认继承使用的就是Object类的equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;        </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span> == that;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals() 在Object类中的实现方法就是测试指向/索引相等。对于<strong>不可变类型的对象</strong>来说，这很容易在调用equals方法时出现bug。所以你需要**重写(override) **equals() 方法，重写为你所定义的两个对象的相等的实现。</p>
<p>举上课的例子，这是一个不可变类型的ADT：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span> </span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Duration that)</span> </span>&#123;        </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getLength() == that.getLength();         </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能想当然认为我们比较的是对于这一个ADT，两个对象值的相等，那么参数类型也就为这个类，这里要特别<strong>注意</strong>:这里并不是<strong>重写</strong>了Object类的方法，而是<strong>重载</strong>了equals方法，因为参数类型的不同，其构成的是重载，意思是说，这时Duration中有两个 equals()方法：一个是从 Object隐式继承下来的equals(Object)，还有一个就是我们写的 equals(Duration)。然后编译器，会在编译时而不是运行时，根据传入的参数类型，选择调用哪一个equals方法。</p>
<p>那到底该如何重写equals方法呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that <span class="keyword">instanceof</span> Duration &amp;&amp; 			<span class="keyword">this</span>.sameValue((Duration)that);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sameValue</span><span class="params">(Duration that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() == that.getLength();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其首先测试了传入的that对象是 Duration，然后调用sameValue()去判断它们的值是否相等。表达式 (Duration)that 是进行了一个类型转换操作，它告诉编译器that指向的是一个 Duration对象。</p>
<p>此外，这里的instance操作符进行了一个动态检查，测试一个实例是否属于特定的类型。但老师又提到，在面向对象编程中使用 instanceof是一个不好的选择。在本门课程中——在很多Java编程中也是这样——<strong>除了实现相等操作，instanceof不能被使用。</strong>这也包括其他在运行时确定对象类型的操作，还有getClass方法。</p>
<p>然后我们再说说hashCode方法：</p>
<h2 id="hashCode-方法："><a href="#hashCode-方法：" class="headerlink" title="hashCode()方法："></a>hashCode()方法：</h2><p>java规定了一个对象相等的契约：</p>
<p>如果两个对象使用 equals操作后结果为真，那么它们各自的hashCode操作的结果也应该相同。</p>
<p>那hashCode又是什么呢？这就需要对哈希表的工作原理有一定的了解。听到hash或哈希，我们会联系到学习数据结构时的散列，在Java中，两个常见的聚合类型 HashSet和 HashMap 就用到了哈希表的数据结构，并且依赖hashCode保存集合中的对象以及产生合适的键（key）。</p>
<p>一个哈希表表示的是一种映射：从键值映射到值的抽象数据类型。哈希表提供了常数级别的查找，查找速度比其他唱常规的链表都要快。键不一定是有序的，也不一定有什么特别的属性，除了类型必须提供 equals 和 hashCode两个方法。</p>
<blockquote>
<p>哈希表是怎么工作的呢？它包含了一个初始化的数组，其大小是我们设计好的。当一个键值对准备插入时，我们通过hashcode计算这个键，产生一个索引，它在我们数组大小的范围内（例如取模运算）。最后我们将值插入到数组索引对应的位置。 哈希表的一个基本不变量就是键必须在hashcode规定的范围内。</p>
<p>Hashcode最好被设计为键计算后的索引应该平滑、均匀的分布在所有范围内。但是偶尔冲突也会发生，例如两个键计算出了同样的索引。因此哈希表通常存储的是一个键值对的列表而非一个单个的值，这通常被称为哈希桶（hash  bucket）。而在Java中，键值对就是一个有着两个域的对象。当插入时，你只要像计算出的索引位置插入一个键值对。当查找时，你先根据键哈希出对应的索引，然后在索引对应的位置找到键值对列表，最后在这个列表中查找你的键。</p>
</blockquote>
<p>Object默认的 hashCode()`实现和默认的 equals()保持一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span> == that; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">/* the memory address of this */</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于索引a和b，如果 a == b，那么a和b的存储地址也就相同，hashCode()的结果也就相同，那么就满足了相等的契约。</p>
<p>但对于前面提到的 Duration这个不可变的ADT，因为我们还没有覆盖默认的 hashCode() ，其实际上打破了对象契约。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration d1 = <span class="keyword">new</span> Duration(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Duration d2 = <span class="keyword">new</span> Duration(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">d1.equals(d2) → <span class="keyword">true</span></span><br><span class="line">d1.hashCode() → <span class="number">2392</span></span><br><span class="line">d2.hashCode() → <span class="number">4823</span></span><br></pre></td></tr></table></figure>

<p>那么该怎么解决这个问题呢？</p>
<ol>
<li>简单粗暴的将所有对象的hashCode值都改为一样的。但会严重性能严重下降，这样将每一个值对都保存到相同的位置，每次查找会遍历所有对象。</li>
<li>另一个方法是计算对象每一个内容的hashcode然后对它们进行一系列算术运算，最终返回一个综合hashcode。</li>
</ol>
<p>还是我们上面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) getLength();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> equals方法和hashCode方法都是Java比较特殊的存在，在构造ADT时，要主要二者方法的重写，来判断等价性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】软件构造PPT</p>
<p>【2】 <a href="https://www.cnblogs.com/liqiuhao/p/8810465.html">https://www.cnblogs.com/liqiuhao/p/8810465.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello的自白.</title>
    <url>/2021/05/04/Hello%E7%9A%84%E8%87%AA%E7%99%BD/</url>
    <content><![CDATA[<h1 id="Hello的自白"><a href="#Hello的自白" class="headerlink" title="Hello的自白"></a>Hello的自白</h1><img src="/2021/05/04/Hello%E7%9A%84%E8%87%AA%E7%99%BD/Hello1.jpg" class title="This is a Hello1s image">



<blockquote>
<p>俺是Hello，额是每一个程序猿🐵的初恋(😊羞羞……)，</p>
<p>却在短短几分钟后惨遭每个菜鸟的无情抛弃(😭呜呜….)，他们很快喜欢上sum、sort、matrix、PR、AI、IOT、BD、MIS……，从不回头😞。</p>
</blockquote>
<p><strong>只有我自己知道，我的出身有多么高贵，我的一生多么坎坷! ╰（‵□′）╯</strong></p>
<p><strong>多年以后，那些真正懂我的大佬(也是曾经的<del>菜鸟一枚</del>)，才恍然感悟我的伟大 !</strong></p>
<hr>
<blockquote>
<p>······<em>想当年</em>：</p>
<p><strong>俺</strong>才是第一个玩P2P的:<em><strong><font color="#FF0000">From Program to Process</font></strong></em></p>
<p>懵懵懂懂的你笨笨磕磕地将我一字一键敲进电脑存成<font color="#FF0000">hello.c(Program)</font>，无意识中将我<strong>预处理、编译、汇编、链接</strong>，历经<strong>艰辛-神秘-高贵-欣喜</strong>，我—<font color="#FF0000"><em><strong>Hello</strong></em></font>一个完美的生命诞生了 <strong>o((&gt;ω&lt; ))o</strong>。</p>
<blockquote>
<h6 id="你造吗？"><a href="#你造吗？" class="headerlink" title="你造吗？"></a>你造吗？</h6><ul>
<li><p>在<strong>壳(Bash)<strong>里，</strong><font color="#000080">伟大的OS(进程管理)</font><strong>为我</strong><font color="#000080">fork(Process) </font><strong>，为我</strong><font color="#000080">execve</font></strong>, 为我<font color="#000080"><strong>mmap</strong></font>，</p>
<p>分我时间片，让我得以在<font color="#000080"><strong>Hardware(CPU/RAM/IO)</strong></font>上驰骋<font color="#000080"><strong>（取指译码执行、流水线等）</strong></font>  </p>
</li>
</ul>
</blockquote>
<blockquote>
<h6 id="你造吗？-1"><a href="#你造吗？-1" class="headerlink" title="你造吗？"></a>你造吗？</h6><ul>
<li><strong>OS(存储管理)与MMU</strong>为VA到PA操碎了心:<strong>TLB、4级页表、3级Cache，Pagefile</strong>等等各显神通为我加速；<strong>IO管理与信号处理</strong>使尽了浑身解数，软硬结合，才使我能在键盘、主板、显卡、屏幕间游刃有余，虽说我在台上的表演只是一瞬间😶、演技看起来很Low、效果很苍白 （︶^︶）。</li>
</ul>
</blockquote>
<p><strong>感谢OS!感谢Bash!在我完美谢幕后为我收尸</strong>。我赤条条来去无牵挂!😌</p>
</blockquote>
<hr>
<p><strong>我朝CS(计算机系统-</strong><u><strong>Editor+Cpp+Compiler+AS+LD+OS+CPU/RAM/IO等</strong></u>)<strong>挥一挥手，不带走一片云彩!</strong> 😛    </p>
<p><strong>想想俺也是<font color="#FF0000"> <em><strong>020:From Zero-0 to Zero-0</strong></em></font>.</strong>  <strong>(^人^)</strong>   </p>
<p><strong>历史长河中一个个<del>菜鸟</del>与我擦肩而过，只有CS知道我的生、我的死，我的坎坷，“只有CS知道……我曾经……来…………过……”</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2021/05/04/Hello%E7%9A%84%E8%87%AA%E7%99%BD/Hello2.jpg" class title="This is a Hello2 image">



<hr>
<p><strong>《Hello的自白》为哈工大CSAPP老师史老师原创的大作业——“程序人生”的导读，本人只是觉其有趣，哪一个程序猿与代码的初见不是“Hello world”呢，从而尝试用markdown写成博客发表，进行二次加工搬运，如有侵权，立即删除！</strong></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>可变数据类型和不可变数据类型以及Snaphot图</title>
    <url>/2021/05/20/Snaphot/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在上软件构造这门课时，在讲数据类型时引入了可变数据类型和不可变数据类型，这是以前未接触过的概念，以前自学Java时，仅有基本数据类型，和引用数据类型这两种概念；此外，老师还引入了Snaphot digrams，其用于描述程序运行时的内部状态，较为实用，今天“趁热打铁”，写博客记录一下。</p>
<p>先回顾一下Java的基本数据类型和引用数据类型。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型主要是我们最熟悉的几个变量类型：</p>
<p>byte、short、int、long,float,double,bool,char；</p>
<p>基本数据类型运算的规则：（不包含布尔类型）</p>
<ol>
<li><p>自动类型提升：当容量小的数据类型的变量与大的数据类型做运算时，结果自动提升为容量大的数据类型。 </p>
<p>byte、char、short（这三者做运算均转为int）-&gt;int-&gt;long-&gt;-&gt;float-&gt;double。</p>
<p>容量大小指的是表示属的范围的大和小，比如float的容量大于long</p>
</li>
<li><p>强制类型转换：需要使用强转符，可能导致精度损失 </p>
</li>
<li><p>整数型定义时，常量存储的类型为int型，若定义变量类型为long，或容量大于int型，且常量超过int型可表示的最大范围数，编译不通过，需要加l</p>
</li>
<li><p>浮点型定义时，常量存储的类型为double类型，若定义变量类型为float，double类型向float转换，报错，常量后面需加f</p>
</li>
</ol>
<p>整型常量：默认类型为int型； 浮点型常量：默认类型为double型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> a = <span class="number">2147483647</span>;        <span class="comment">//编译可通过</span></span><br><span class="line">   		<span class="keyword">long</span> a = <span class="number">2147483648</span>;        <span class="comment">//编译不通过，显示数过大</span></span><br><span class="line">   	 	<span class="keyword">long</span> a = <span class="number">2147483648l</span>;      <span class="comment">//编译可通过</span></span><br><span class="line">    	<span class="keyword">float</span> f1 = <span class="number">12.3</span>;   <span class="comment">//编译不通过，因为12.3默认为double型，需要12.3加f</span></span><br><span class="line">   		<span class="keyword">byte</span> b = <span class="number">12</span>;   <span class="comment">//编译可通过</span></span><br><span class="line">   	    <span class="keyword">byte</span> b = b + <span class="number">1</span>;   <span class="comment">//编译不通过，因为1被认为是int型</span></span><br><span class="line">   	    <span class="keyword">float</span> f1 = b + <span class="number">12.3</span>;  <span class="comment">//编译不通过，因为12.3被认为是doble型</span></span><br><span class="line">	System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>引用数据类型主要有：类（字符串）、接口、数组、枚举类等。其被称为引用数据类型的原因是：创建变量并赋值后，且不是直接存储的值，而是存储的是堆中创建值的地址，通过地址寻值，有点类似于C语言的指针。</p>
<p>举例String：</p>
<p>String不是基本数据类型，而是为引用数据类型,字符串。</p>
<p>String类型变量的使用: </p>
<p>String可以和8种基本数据类型做运算，只能做连接，用string类接收，运算结果仍然是String 。</p>
<p>二者区别对比：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">基本数据类型</th>
<th align="center">引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员</td>
<td align="center">byte、short、int、long,float,double,bool,char</td>
<td align="center">类、接口、数组、枚举类</td>
</tr>
<tr>
<td align="center">分配内存区域</td>
<td align="center">在栈中分配内存</td>
<td align="center">在堆中分配内存</td>
</tr>
<tr>
<td align="center">是否与其他值可区分</td>
<td align="center">只有值，没有ID，与其他值无法区分</td>
<td align="center">既有ID，也有值</td>
</tr>
<tr>
<td align="center">可变/不可变数据类型</td>
<td align="center">全都为不可变数据类型</td>
<td align="center">有些是可变的，有些是不可变的</td>
</tr>
<tr>
<td align="center">赋值</td>
<td align="center">传递的是值</td>
<td align="center">传递的是地址</td>
</tr>
</tbody></table>
<p>下面再谈谈上课所讲的可变和不可变数据类型。</p>
<h2 id="不可变数据类型-Immutable-types"><a href="#不可变数据类型-Immutable-types" class="headerlink" title="不可变数据类型(Immutable types)"></a>不可变数据类型(Immutable types)</h2><p>定义：一旦一个变量被创建且被赋初值，其值不能再改变。此外，如果如果是引用类型，也可以是不变的，即一旦确定其指向的对象，不能再被改变指向其他对象。</p>
<p>我们一般用final标识符，来说明这个变量的值不能再被改变。一旦一个变量被final修饰后并进行首次赋值后，编译器进行静态类型检查时，如判断 final 变量首次赋值后发生了改变，会提示错误。如图idea报错。</p>
<p><img src="/2021/05/20/Snaphot/1.png"></p>
<p>下面举一个不可变数据类型String的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时创建了一个String类型的变量str，值为”Hello”，这里是一个局部变量，下图给出其在内存中的表示。</p>
<p><img src="/2021/05/20/Snaphot/2.png"></p>
<p>再执行了下面一条语句后，其变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str + <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/20/Snaphot/3.png" alt="image-20210706184856276"></p>
<p>可以看到，其并没有改变堆里地址为0x2233存储的原来的字符串值，而是在堆里新建一个对象，其值为“HelloWorld”，然后改变栈里str的存储值。</p>
<p>用Snaphot图表示变化：</p>
<p><img src="/2021/05/20/Snaphot/4.png" alt="image-20210706190855510"></p>
<p>不可变数据类型的<strong>优点</strong>：因为其值不能改变，不可变类型更“安全”，在其他质量指标上表现更好。其安全性会在下面与可变数据类型对比时体现出来。</p>
<p><strong>缺点</strong>：使用不可变类型，对其频繁修改会产生大量的临时拷贝，需要垃圾回收。就正如上面所举的例子：改变了str的值，但“Hello”的值仍然在堆中，就需要垃圾回收。</p>
<h2 id="可变数据类型"><a href="#可变数据类型" class="headerlink" title="可变数据类型"></a>可变数据类型</h2><p>定义:可以<strong>改变</strong>值，且拥有方法可以修改自己的值。</p>
<p>这里举一个可变数据类型StringBuilder的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">str1.append(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里选择直接用Snaphot图表示变化：</p>
<p><img src="/2021/05/20/Snaphot/5.png" alt="image-20210706190817364"></p>
<p>看到这里，可能就会产生疑惑：这里的StringBuilder和前面的String的结果不都一样吗？没有什么区别啊。但这个还需要我们深思一下。</p>
<p>如果是当只有<strong>一个</strong>引用指向该对象，二者没有区别。</p>
<p>但是<strong>注意：</strong>有多个引用的时候，差异就出现了！！！</p>
<p>给出上课老师举的例子：</p>
<p><img src="/2021/05/20/Snaphot/6.png" alt="image-20210706191223709"></p>
<p>可以看到，变量t和s都最开始都指向同一个值“ab”，但当t修改值变为“abc”时，仅仅改变了t的指向，指向“abc”，而并未更改原来的值，s的值不变仍为“ab”；</p>
<p>再看变量sb和tb二者最开始都指向同一个值“ab”，但当tb改变值为“abc”时，是在原有的值上直接修改，不同于之前String类型变量t，这样一来sb也并未改变值，但其由于指向的值的改变，导致sb的值变为“abc”；这就相当危险了，看上去是对一个变量值的修改，却也同时改变了另一个变量的值，很难让人察觉出这一变化，从而产生一些副影响。这里就体现了不可变数据类型的<strong>安全性</strong>所在！</p>
<p>但可变数据类型还是有<strong>优点</strong>的：首先就是，我们的程序需要值的变化，其必不可少。</p>
<p>可变类型最少化拷贝以提高效率，减少垃圾；其次，也适合于在多个模块之间共享数据，例如全局变量。</p>
<p>但是我们上面提到了可变数据类型的一些<strong>“危险”</strong>，那就讲一讲如何<strong>安全</strong>的使用可变类型：</p>
<p>局部变量，只有一个引用，不会涉及共享，不会有危险。</p>
<p>但如果有多个引用（别名），使用可变类型就非常不安全。</p>
<p>主要办法就是：防御性拷贝，给客户端返回一个全新的对象，是要返回值的拷贝，但是新建的，地址不同，避免直接返回，传递地址，致使产生多个引用。</p>
<h2 id="Snophot-Diagram"><a href="#Snophot-Diagram" class="headerlink" title="Snophot Diagram"></a>Snophot Diagram</h2><p>Snophot图十分常用，其主要用于描述程序运行时的内部变化，如在栈中和堆中的对象、变量等等。</p>
<p>其优点是：直观、简洁，便于程序员之间交流，便于刻画各类变量随时间发生的变化，便于解释思路。</p>
<p>下面讲一讲其表示规范。</p>
<h3 id="基本类型的值"><a href="#基本类型的值" class="headerlink" title="基本类型的值"></a>基本类型的值</h3><p>其用箭头指向一个常量表示变量对这个值的引用。如图所示：</p>
<p><img src="/2021/05/20/Snaphot/7.png" alt="image-20210706195413812"></p>
<h3 id="对象类型的值"><a href="#对象类型的值" class="headerlink" title="对象类型的值"></a>对象类型的值</h3><p>对象类型的值用一个按其类型标记的圆表示。</p>
<p>定义一个圆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;  <span class="comment">//圆心横坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;  <span class="comment">//圆心纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> r;  <span class="comment">//圆的半径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要显示更多的细节时，可在这个圆里面写明成员变量名，用箭头指向它们的值。若想要更详细，可以标明其成员变量的类型。</p>
<p><img src="/2021/05/20/Snaphot/8.png" alt="image-20210706200318325"></p>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p> 其在对象类型的基础上改为双线椭圆。</p>
<p>如之前前面所举的例子。</p>
<p><img src="/2021/05/20/Snaphot/4.png" alt="image-20210706190855510"></p>
<h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>这个也较为简单，就是之前举的例子。</p>
<p><img src="/2021/05/20/Snaphot/5.png" alt="image-20210706190817364"></p>
<h3 id="不可变的引用"><a href="#不可变的引用" class="headerlink" title="不可变的引用"></a>不可变的引用</h3><p>这里不可变的引用是指，变量指不可变。其用双线箭头表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> y =<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="/2021/05/20/Snaphot/9.png" alt="image-20210706200914860"></p>
<p>同时我们还要注意：引用是不可变的，但指向的值却可以是可变的。比如说，定义了一个final StringBuilder sb，我们不能改变其指向，但其指向的值却是可改变的。</p>
<p>可变的引用，也可指向不可变的值，比如说，定义了一个String s，其指向一个存储在堆中不可变的值“Hello”，但我们可以改变s的指向，指向“Hello world”。</p>
<p>这就是关于Snophot的内容。</p>
<p>这些只是自己的一些浅薄的理解，若有问题，恳请批评指正。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】软件构造课程PPT</p>
<p>【2】自学JAVA的笔记</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Snaphot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式（Proxy）理解</title>
    <url>/2021/06/27/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>老师上课讲到了一些设计模式，但是由于课程较赶，时间较紧，吃不太透，于是自己课下再学习一些，加深理解，同时在编程中多多用到。</p>
<h2 id="代理模式简述"><a href="#代理模式简述" class="headerlink" title="代理模式简述"></a>代理模式简述</h2><p>首先，代理模式是一种<strong>设计模式</strong>。</p>
<p>先给出代理模式的<strong>概念</strong>：代理模式是指通过<strong>代理对象</strong>访问目标对象，而不是直接访问<strong>目标对象</strong>，通过字面理解即可，要通过一个代理人或者说中间人来访问我们想要访问的对象。举例就像房屋中介，买房人不想自己去一个找房主询问其是否卖房，而卖房人也不想麻烦去一个个找买房人，中介就承担起这个功能，买房人（用户）通过中介（代理对象）获知在售的其意向房产的信息（如房价、面积、位置等的）。</p>
<p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>何时使用</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>关键代码：</strong>实现与被代理类组合。</p>
<p>那么为什么要有代理模式呢？其好处是可以在目标对象实现的基础上，增强额外的功能操作，即拓展目标对象的功能，如添加权限进行访问控制和审计等功能，其中举添加权限这个功能说明，通过代理对象判断访问目标对象的用户是否拥有访问的权限，没有则禁止访问，实现对信息的一个保护。</p>
<p>同时，代理模式也是遵循了设计思想中类的单一性原则，就是每个类功能应该单一，即专一，就是说什么人干什么事，一个人尽可能负责一个工作，同时也是去尽量实现低耦合。</p>
<img src="/2021/06/27/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/Proxy.png" class title="This is a Proxys image">

<p>代理模式要着重理解代理对象和目标对象的概念，代理对象是对目标对象的扩展,并会调用目标对象。就像房屋中介调用目标对象（卖房人）获取其房产信息，但不仅限于房产信息，房屋中介还会审计其掌握的房产资源，而后挑选合适的房产给买房人。</p>
<p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理</p>
<h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><p>代理模式主要分为三类：</p>
<p> 1.静态代理；</p>
<p> 2.动态代理；</p>
<p> 3.Cglib代理。</p>
<p>下面分别论述。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。需要注意的是，代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</p>
<p>我们举个买房这个例子来说明：</p>
<p>首先要先创建一个服务类的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后要实现这个服务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseServiceImpl</span> <span class="keyword">implements</span> <span class="title">HouseService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我要买房&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>有了服务后，我们就需要一个中间类也就是代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseServiceProxy</span> <span class="keyword">implements</span> <span class="title">HouseService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HouseService houseService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseServiceProxy</span><span class="params">(<span class="keyword">final</span> HouseService houseService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseService = houseService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攒钱买房&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;挑房看房&quot;</span>);</span><br><span class="line">        houseService.buyHosue();</span><br><span class="line">        System.out.println(<span class="string">&quot;买房装修&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入住&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优点：在不修改目标对象的功能前提下,可以实现对目标对象功能的扩展。</p>
<p>缺点：</p>
<ol>
<li><p>代理对象必须提前写出（在编译期就已经知道了代理对象），如果接口层发生了变化，代理对象的代码也要进行维护。</p>
</li>
<li><p>因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多，导致一旦接口增加方法,目标对象与代理对象都要维护。</p>
</li>
</ol>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>　在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable 		</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攒钱买房&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;挑房看房&quot;</span>);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;买房装修&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入住&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态代理的特点:</strong></p>
<p>1.代理对象,不需要实现接口；<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)；<br>3.动态代理也叫做: JDK代理,接口代理。</p>
<p><strong>JDK中生成代理对象的API</strong><br>代理类所在包:java.lang.reflect.Proxy</p>
<p><strong>总结</strong>：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理。</p>
<p>优点：JDK动态代理解决了静态代理中需要创建多个代理类的问题。</p>
<p>缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，假如没有，则可以使用Cglib代理<strong>。</strong></p>
<h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p>
<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。</p>
<p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)。</p>
<p>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>步骤：创建Cglib代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攒钱买房&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;挑房看房&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;买房装修&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入住&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Cglib子类代理实现方法:</p>
<ol>
<li>需要引入cglib的jar文件,但是因为pring的核心包中已经包括了Cglib功能,所以可以直接引入<code>pring-core-3.2.5.jar</code>。</li>
<li>引入功能包后,就可以在内存中动态构建子类</li>
</ol>
<p>以上就是代理模式的内容，仅个人拙见，若有错误，恳请批评指正。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>【1】<a href="https://www.runoob.com/design-pattern/proxy-pattern.html">https://www.runoob.com/design-pattern/proxy-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>post</title>
    <url>/2021/09/19/post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>UML类图简述及IDEA中UML插件的安装和使用</title>
    <url>/2021/06/15/UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在上软件构造这门课中，随着课程的深入，PPT上出现了许多的类图，初次看起来不太懂各种箭头指向表明的含义；此外，老师还提到了许多类与类之间的关系，依赖、组合、泛化、实现等等，其在UML类图上都有体现。同时考虑到UML类图的在工作学习种会广泛使用，以及其清晰简洁的类与类之间关系的表示，同时可以在我们的实验报告中用类图展示类与类之间关系，简洁明了，由此产生了学习UML类图的想法，到网上查阅资料学习并撰写博客记录。</p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><h3 id="UML图定义"><a href="#UML图定义" class="headerlink" title="UML图定义"></a>UML图定义</h3><p>​        UML图，实际上是一种<strong>语言</strong>， 统一建模语言，又称标准建模语言，是用来对软件密集系统进行可视化建模的一种语言。UML的包括<strong>UML语义</strong>和<strong>UML表示法</strong>两个元素。</p>
<p>​        UML是在开发阶段，说明、可视化、构建和书写一个<strong>面向对象</strong>软件密集系统的制品的开放方法。最佳的应用是工程实践，对大规模，复杂系统进行建模方面，特别是在<strong>软件架构</strong>层次，已经被验证有效。统一建模语言（UML）是一种模型化语言。模型大多以<strong>图表</strong>的方式表现出来。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。</p>
<p>​        UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</p>
<h3 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h3><ol>
<li>用例图。</li>
<li>静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图。</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图。</li>
</ol>
<p>说明：</p>
<ul>
<li>类图是描述<strong>类与类</strong>之间的<strong>关系</strong>，是UML图中最<strong>核心</strong>的。</li>
</ul>
<p>下面着重介绍UML类图</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>​        UML类图的介绍：</p>
<ul>
<li>描述系统中类（对象）本身的组成（成员属性和成员方法）和类（对象）之间的各种<strong>静态关系</strong>。</li>
<li>类之间的关系：依赖、泛化、实现、关联、聚合与组合。</li>
</ul>
<h3 id="类图的依赖关系（Dependence）"><a href="#类图的依赖关系（Dependence）" class="headerlink" title="类图的依赖关系（Dependence）"></a>类图的依赖关系（Dependence）</h3><p>​        只要是在类中用到了对方，那么他们之间就存在依赖关系，如果没有对方，甚至连编译都过不了。依赖关系是类与类之间最广泛、最普遍也是最基础的关系。</p>
<p>​        下面几条为判断类依赖关系的依据：</p>
<ul>
<li><p>类中用到了对方</p>
</li>
<li><p>类的成员属性</p>
</li>
<li><p>方法中使用到</p>
</li>
<li><p>是方法的返回类型</p>
</li>
<li><p>是方法接收的参数类型</p>
<p>​    就拿最简单的Person来举例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    每个人Person都有自己的身份证号，这里新建一个IDnumber类，使用到了IDnumber类，而id又是Peroson的成员变量，同时在setIDnumber方法传入参数类型也为IDnumber ，getIDnumber方法中返回的类型也为IDnumber，只要存在上述的任意一条出现，就可以说IDnumber类和Peroson类构成了依赖关系。</p>
<p>​    在UML类图中，用带箭头的虚线表示，箭头指向被依赖方，比如说，这里Person类指向IDnumber类。如下图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Dependence.jpg"></p>
</li>
</ul>
<h3 id="类图中的泛化关系（Generalization）"><a href="#类图中的泛化关系（Generalization）" class="headerlink" title="类图中的泛化关系（Generalization）"></a>类图中的泛化关系（Generalization）</h3><p>​        泛化关系实际上就是继承关系，比如B类（子类）继承了A类（父类），二者构成了泛化关系。泛化关系是依赖关系的特例。前面已经提到依赖关系是最普遍的关系，而这里则是针对关系的特点再细分。</p>
<p>​        这里就用Human和Person来举例，每个人都是人类，都要吃饭和睡觉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber idnumber;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在UML类图中，用带三角箭头的实线表示泛化关系，其箭头指向父类。如下图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/extend.jpg"></p>
<h3 id="类图中的实现关系（Realization）"><a href="#类图中的实现关系（Realization）" class="headerlink" title="类图中的实现关系（Realization）"></a>类图中的实现关系（Realization）</h3><p>​        实现关系就是A类实现B接口，表示类具备了某种能力，也是依赖关系的特例。</p>
<p>​        这里就用Person类和Swimming接口来举例，并不是每个人都会游泳，就比如说我这只“旱鸭子”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Swimming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implenment</span> <span class="title">Swimming</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> 	<span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在UML类图中带三角箭头的虚线表示依赖关系，其箭头指向实现的接口。如下图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/implement.jpg"></p>
<h3 id="类图中的关联关系（Association）"><a href="#类图中的关联关系（Association）" class="headerlink" title="类图中的关联关系（Association）"></a>类图中的关联关系（Association）</h3><p>​        一个类中的成员变量（成员属性）用到了其他类，则称二者构成关联关系。关联关系实际上就是类与类之间的联系，也是依赖关系的特例。</p>
<p>​        关系具有导航性，即双向关系或单向关系，单向一对一关系，双向一对一关系。</p>
<p>​        关系具有多重性，如“1”表示有且仅有一个，“0…”表示0个或者多个，“0，1”表示0个或1个，“i…j”表示i到j个都可以，“m…*”表示至少m个。</p>
<p>​        这里依旧拿Person和IDnumber来举例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">现在Person类和IDnumber类的关系就是关联关系，Person类的成员属性中用到了IDnumber类，此时是单向一对一的，Person对应IDnumber，而IDnumber并没对应Person。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML类图如下：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Associate1.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段表示Person与IDnumber关系仍是关联关系，但与上面的单向一对一的不同，此时，Person对应IDnumber，而IDnumber也对应Person，是双向一对一关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    UML类图如下：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Associate2.jpg"></p>
<p>​    在UML类图中带箭头的实线表示关联关系，箭头指向关联类。</p>
<h3 id="类图中的聚合关系（Aggregation）"><a href="#类图中的聚合关系（Aggregation）" class="headerlink" title="类图中的聚合关系（Aggregation）"></a>类图中的聚合关系（Aggregation）</h3><p>​        聚合关系表示的是整体和部分的关系，整体与部分可以分离，部分具有一定的独立性。整体和部分具有各自的生命周期，部分可以属于多个对象，也可以被多个对象共享；比如计算机和CPU、鼠标、键盘，公司与员工的关系。</p>
<p>​        在代码层面来讲，聚合与关联是一致的，只能从语义上来区分。聚合关系是关联关系的特例，具有关联的导航性与多重性。</p>
<p>​        这里拿Computer类和Mouse类、Keyboard类来举例，电脑有鼠标、键盘等组成，但鼠标、键盘都可以拔下来，电脑损害不会损坏到鼠标、键盘，鼠标、键盘损坏也不会损坏电脑，换个新鼠标、键盘就是了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Mouse</span> <span class="title">mouse</span></span>;</span><br><span class="line">	<span class="keyword">private</span> Keyboard keyboard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMouse</span><span class="params">(Mouse mouse)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyboard</span><span class="params">(Keyboard keyboard)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.keyboard= keyboard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span></span>&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在UML类图中用带空心菱形的实线表示，菱形指向整体。如图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Aggreation.jpg"></p>
<h3 id="类图中的组合关系（Composition-）"><a href="#类图中的组合关系（Composition-）" class="headerlink" title="类图中的组合关系（Composition    ）"></a>类图中的组合关系（Composition    ）</h3><p>​        组合关系表示的也是整体和部分的关系，但是聚合关系的升级，整体和部分不可以分开，部分不能从整体中分离出来，创建了整体的同时，部分也随之创立，共诞生、共灭亡。同样是关联关系的特例。</p>
<p>​        这里依旧拿Person和Heart类举例，每个人都有心脏，自一出生下来，心脏无时无刻不跳动，当然不跳动了，人就die了，同生共死。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;   <span class="comment">//聚合关系</span></span><br><span class="line">    <span class="keyword">private</span> Heart heart = <span class="keyword">new</span> Heart();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML类图如下：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/composition.jpg"></p>
<p>​        此外，还有一种特例，会将聚合关系升级成组合关系，即级联删除。其前提是：类A与类B是聚合关系，A是整体，B是部分；当销毁删除A的同时，连同B一块销毁删除，这就是级联删除。当定义了级联删除时，那么A与B由原来的聚合关系升级为组合关系。就比如说上面举的Person和IDnumber的例子，删除Person时连同IDnumber一块删除，那么IDnumber和Person就是组合关系了。</p>
<p>​        在UML类图中用带实心菱形的实线表示，菱形指向整体。</p>
<h3 id="类图关系小结"><a href="#类图关系小结" class="headerlink" title="类图关系小结"></a>类图关系小结</h3><p>​        类图的6种关系中，其中依赖关系是最普遍、最基础、最广泛的一类关系，再根据关系的特点细分，可以划分出泛型、实现、关联、组合、聚合关系，其都是依赖关系的特例。就像人类社会一般，每个人都与他人之间有着依赖关系，维持着人际关系，再根据人际关系特点或身份等等，分成各种关系，诸如父子、师生、朋友等等关系。</p>
<h2 id="IDEA中UML插件的安装与使用"><a href="#IDEA中UML插件的安装与使用" class="headerlink" title="IDEA中UML插件的安装与使用"></a>IDEA中UML插件的安装与使用</h2><h3 id="UML的安装"><a href="#UML的安装" class="headerlink" title="UML的安装"></a>UML的安装</h3><p>​        第一步：打开IDEA，选中左上角的<strong>文件（File）—&gt;设置（Settings）—&gt;插件（Plugins）</strong>，搜索UML，这里推荐PlantUML，然后安装，安装完成后需要重新启动IDEA。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/1.png"></p>
<p>​        第二步：重启IDEA完成后，选中左上角的<strong>文件（File）—&gt;新建（new）</strong>，可以发现一个<strong>PlantUML File</strong>，说明可以创建UML文件了</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/2.png"></p>
<p>​        点击出现文件创建，输入文件名，以及选择UML图的类型，这里选择class，即我们最常用的UML类图。</p>
<p>​        下面是初次创建其给我们的示例：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/3.png"></p>
<p>​        如想了解更多有关其类图的信息可以到其官网。</p>
<p>​        传送门：<a href="https://plantuml.com/class-diagram">https://plantuml.com/class-diagram</a></p>
<p>​        若要学习绘制UML图的语法，可以到PlantUML的github上获取资源。</p>
<p>​        传送门：<a href="https://github.com/plantuml/plantuml">https://github.com/plantuml/plantuml</a></p>
<h3 id="PlantUML语法"><a href="#PlantUML语法" class="headerlink" title="PlantUML语法"></a>PlantUML语法</h3><p>​        这里给出常用语法：        </p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">示例含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–</td>
<td align="center">UML图中体现为实线</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">UML图中体现为虚线</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">..&gt;</td>
<td align="center">依赖</td>
<td align="center">A..&gt;B</td>
<td align="center">类A依赖于B</td>
</tr>
<tr>
<td align="center">–&gt;</td>
<td align="center">关联</td>
<td align="center">A..&gt;B</td>
<td align="center">类A关联于B</td>
</tr>
<tr>
<td align="center">–|&gt;</td>
<td align="center">继承</td>
<td align="center">A–|&gt;B</td>
<td align="center">类A继承于B</td>
</tr>
<tr>
<td align="center">..|&gt;</td>
<td align="center">实现</td>
<td align="center">A..|&gt;B</td>
<td align="center">类A实现接口B</td>
</tr>
<tr>
<td align="center">–o</td>
<td align="center">聚合</td>
<td align="center">A–oB</td>
<td align="center">类A聚合了B</td>
</tr>
<tr>
<td align="center">–*</td>
<td align="center">组合</td>
<td align="center">A–*B</td>
<td align="center">类A组合了B</td>
</tr>
</tbody></table>
<p>​        注：</p>
<ul>
<li>这里给符号&gt;, o, *指向那一侧，在UML图中会如实体现。</li>
<li>还支持双向箭头&gt;、o、*，比如说关联关系中的双向单一关系，可以用A&lt;–&gt;B，其效果如前面所展示的Person和IDnumber的双向单一关系的UML类图一致。</li>
<li>在左侧的类一般在UML图的上侧，如Human–|&gt;Person，Person..&gt;IDnumber，其UML图如前面所说类图中泛化关系的类图所示。</li>
</ul>
<p>​        然后是权限修饰符：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">示例含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">private</td>
<td align="center">-id: IDnumber</td>
<td align="center">private IDnumber id;</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">public</td>
<td align="center">+id: IDnumber</td>
<td align="center">public IDnumber id;</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">protected</td>
<td align="center">#id: IDnumber</td>
<td align="center">protected IDnumber id;</td>
</tr>
</tbody></table>
<p>​        再是抽象类和接口：</p>
<p>​        可直接用抽象类和接口对应关键词即可，abstract和interface来声明即可。</p>
<p>​        建议：根据第一次新建UML类图文件其官方给出的示例，照猫画虎，稍加研究，很快就可以上手，需要时间不到半小时，而且一旦熟练掌握后，效率十分之高，比拖拽画类图方便很多，同时plantUML做到了所见即所得，就是实时预览，十分方便。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 尚硅谷UML介绍：<a href="https://www.bilibili.com/video/BV1G4411c7N4?p=23&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1G4411c7N4?p=23&amp;spm_id_from=pageDriver</a></p>
<p>[2] PlantUML语法：<a href="https://www.cnblogs.com/liruilong/p/11506280.html">https://www.cnblogs.com/liruilong/p/11506280.html</a></p>
]]></content>
      <categories>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>IDEA</tag>
        <tag>UML类图</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/06/24/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>老师上课讲了7种设计模式，分为三种类型:创建型模式，结构型模式，行为类模式。</p>
<p>结构型模式中主要讲了，适配器模式和装饰器模式。其中个人理解了装饰器模式，就是通过装饰对象来在原有对象的基础上增加一些新特性，上课举的咖啡的例子，在最基础的咖啡上加糖、加牛奶等等，这就是一个装饰的过程。但对适配器模式，并未理解，依旧云里雾里，课下学习，写博客记录。</p>
<h2 id="适配器模式（Adapter-Pattern）简述"><a href="#适配器模式（Adapter-Pattern）简述" class="headerlink" title="适配器模式（Adapter Pattern）简述"></a>适配器模式（Adapter Pattern）简述</h2><p>先从字面意思来理解，适配器，生活中有电源适配器，也就是插头，其作用是将插座上220V的电压转化为一般为5V（万年5V1A）的电压，以供手机充电，解决了电压过大，无法充电的问题，其实现的是插座电源和手机充电电源之间两个不兼容的接口的问题。</p>
<p>形象地说，适配器是两个不兼容的接口之间的桥梁。</p>
<p><strong>意图</strong>：将一个类的接口转换成客户端Client希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>解决的问题：</strong>主要解决改变环境后，原有的类不能在新环境下使用的情况，导致我们设计好的类被浪费，不能复用，重写耗费时间。</p>
<p><strong>主要实现方式：</strong>继承。通过增加一个接口，将已存在的子类封装起来， client 面向接口编程，从而隐藏了具体子类。</p>
<p>UML类图关系：</p>
<p><img src="/2021/06/24/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/1.png" alt="image-20210707202243644"></p>
<p>不兼容：target想要调用Request方法，而Adaptee并没有这个方法，只有SpecificRequest方法，要进行一个转换。</p>
<p>下面举一个例子来说，还是拿手机电源和插座电源来说：</p>
<p>先定义创建二者的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutletPower</span></span>&#123;  <span class="comment">//插座电源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(String appliance)</span></span>;  <span class="comment">//appliance 充电电器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhonePower</span></span>&#123; <span class="comment">//手机电源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneCharge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建两个类分别实现上面的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutletPowerImpl</span> <span class="keyword">implements</span> <span class="title">OutletPower</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(String appliance)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插座电源220V：充电&quot;</span>+appliace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhonePowerImpl</span> <span class="keyword">implements</span> <span class="title">PhonePower</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneCharge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机充电电压5V：手机充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后，现在我们就需要一个手机电源设配器，将电压由220V转换成5V，让其可以给手机充电。定义创建一个实现了phonePower接口的电源适配器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">implements</span> <span class="title">phonePower</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutletPower outletPower;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PowerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">           OutletPowerImpl = <span class="keyword">new</span> OutletPowerImpl();  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneCharge</span><span class="params">(String appliance)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(appliace.equalsIgnoreCase(<span class="string">&quot;phone&quot;</span>))&#123;</span><br><span class="line">          OutletPowerImpl.charge(appliance);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现电源转换：</p>
<p>这样一来，插座电源通过手机电源设配器能给手机充电。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点：</strong> </p>
<ol>
<li><p>可以让任何两个没有关联的类一起运行。</p>
</li>
<li><p>提高了类的复用。 </p>
</li>
<li><p>增加了类的透明度。 </p>
</li>
<li><p>灵活性好。</p>
</li>
</ol>
<p><strong>缺点：</strong> </p>
<ol>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li>
<li> 由于 JAVA规定，一个子类 至多继承一个类，即只有一个父类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ol>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>【1】 <a href="https://www.runoob.com/design-pattern/adapter-pattern.html">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p>
<p>【2】 <a href="https://www.jianshu.com/p/9d0575311214">https://www.jianshu.com/p/9d0575311214</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>程序人生-Hello的前世今生</title>
    <url>/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    <content><![CDATA[<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image001.jpg"></p>
<p>​                                                                 <strong>计算机系统</strong></p>
<p>​                                                                     <strong>大作业</strong></p>
<p>​                                                     题   目：   程序人生-Hello’s P2P  </p>
<p>​                                                     专   业：   计算学部    </p>
<p>​                                                     学   号：   1190201307    </p>
<p>​                                                     班   级：   1903010    </p>
<p>​                                                     学   生：    徐伟     　</p>
<p>​                                                     指 导 教 师：  史先俊老师    </p>
<p>​                                                           <strong>计算机科学与技术学院</strong></p>
<p>​                                                                  <strong>2021年5月</strong>    </p>
<p><strong>摘 要</strong></p>
<p>​    Hello是最简单的程序，是每个程序员的初见，不过短短几行，不是很难理解和编写，但从其出生到死亡可谓是一段漫长而又丰富的历程，本论文主要介绍了hello这一最简单程序的生命周期。在这一生命周期，他遇到过生命中的“贵人”帮助他从program变成process，“从静止到跑起来”，即从.c源文件经过预处理、编译、汇编、链接生成可执行文件，再到shell为其fork进程成为process。还有020，从无到有再到化为历史长河的一粒沙，execbe加载运行hello完成内存映射，访问内存读取数据、再到结束shell回收相关资源。从诞生到结束，从运行到终止，探讨追踪了hello这一最简单程序在计算机系统内软硬件结合如何一步步运行直到死亡的过程。</p>
<p><strong>关键词：编译汇编链接，进程管理，内存管理，IO管理。</strong>             </p>
<p>（摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分）</p>
<p><strong>目 录</strong></p>
<p><a href="#_Toc532238396">第1章 概述…………………………………………………………………………………… - 4 -</a></p>
<p><a href="#_Toc532238397">1.1 Hello简介…………………………………………………………………………………. - 4 -</a></p>
<p><a href="#_Toc532238398">1.2 环境与工具………………………………………………………………………………. - 4 -</a></p>
<p><a href="#_Toc532238399">1.3 中间结果………………………………………………………………………………….. - 5 -</a></p>
<p><a href="#_Toc532238400">1.4 本章小结………………………………………………………………………………….. - 5 -</a></p>
<p><a href="#_Toc532238401">第2章 预处理……………………………………………………………………………….. - 6 -</a></p>
<p><a href="#_Toc532238402">2.1 预处理的概念与作用………………………………………………………………… - 6 -</a></p>
<p><a href="#_Toc532238403">2.2在Ubuntu下预处理的命令………………………………………………………… - 8 -</a></p>
<p><a href="#_Toc532238404">2.3 Hello的预处理结果解析……………………………………………………………. - 8 -</a></p>
<p><a href="#_Toc532238405">2.4 本章小结………………………………………………………………………………….. - 9 -</a></p>
<p><a href="#_Toc532238406">第3章 编译…………………………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238407">3.1 编译的概念与作用………………………………………………………………….. - 10 -</a></p>
<p><a href="#_Toc532238408">3.2 在Ubuntu下编译的命令…………………………………………………………. - 11 -</a></p>
<p><a href="#_Toc532238409">3.3 Hello的编译结果解析……………………………………………………………… - 11 -</a></p>
<p><a href="#_Toc532238410">3.4 本章小结………………………………………………………………………………… - 20 -</a></p>
<p><a href="#_Toc532238411">第4章 汇编…………………………………………………………………………………. - 21 -</a></p>
<p><a href="#_Toc532238412">4.1 汇编的概念与作用………………………………………………………………….. - 21 -</a></p>
<p><a href="#_Toc532238413">4.2 在Ubuntu下汇编的命令…………………………………………………………. - 21 -</a></p>
<p><a href="#_Toc532238414">4.3 可重定位目标elf格式…………………………………………………………….. - 21 -</a></p>
<p><a href="#_Toc532238415">4.4 Hello.o的结果解析………………………………………………………………….. - 25 -</a></p>
<p><a href="#_Toc532238416">4.5 本章小结………………………………………………………………………………… - 28 -</a></p>
<p><a href="#_Toc532238417">第5章 链接…………………………………………………………………………………. - 29 -</a></p>
<p><a href="#_Toc532238418">5.1 链接的概念与作用………………………………………………………………….. - 29 -</a></p>
<p><a href="#_Toc532238419">5.2 在Ubuntu下链接的命令…………………………………………………………. - 29 -</a></p>
<p><a href="#_Toc532238420">5.3 可执行目标文件hello的格式………………………………………………….. - 29 -</a></p>
<p><a href="#_Toc532238421">5.4 hello的虚拟地址空间………………………………………………………………. - 33 -</a></p>
<p><a href="#_Toc532238422">5.5 链接的重定位过程分析…………………………………………………………… - 35 -</a></p>
<p><a href="#_Toc532238423">5.6 hello的执行流程……………………………………………………………………… - 37 -</a></p>
<p><a href="#_Toc532238424">5.7 Hello的动态链接分析……………………………………………………………… - 39 -</a></p>
<p><a href="#_Toc532238425">5.8 本章小结………………………………………………………………………………… - 41 -</a></p>
<p><a href="#_Toc532238426">第6章 hello进程管理………………………………………………………………….. - 42 -</a></p>
<p><a href="#_Toc532238427">6.1 进程的概念与作用………………………………………………………………….. - 42 -</a></p>
<p><a href="#_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程………………………………………. - 42 -</a></p>
<p><a href="#_Toc532238429">6.3 Hello的fork进程创建过程……………………………………………………… - 42 -</a></p>
<p><a href="#_Toc532238430">6.4 Hello的execve过程………………………………………………………………… - 44 -</a></p>
<p><a href="#_Toc532238431">6.5 Hello的进程执行…………………………………………………………………….. - 44 -</a></p>
<p><a href="#_Toc532238432">6.6 hello的异常与信号处理…………………………………………………………… - 46 -</a></p>
<p><a href="#_Toc532238433">6.7本章小结…………………………………………………………………………………. - 46 -</a></p>
<p><a href="#_Toc532238434">第7章 hello的存储管理………………………………………………………………. - 49 -</a></p>
<p><a href="#_Toc532238435">7.1 hello的存储器地址空间…………………………………………………………… - 49 -</a></p>
<p><a href="#_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理……………………………… - 50 -</a></p>
<p><a href="#_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理…………………………. - 51 -</a></p>
<p><a href="#_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换…………………………….. - 51 -</a></p>
<p><a href="#_Toc532238439">7.5 三级Cache支持下的物理内存访问…………………………………………. - 54 -</a></p>
<p><a href="#_Toc532238440">7.6 hello进程fork时的内存映射…………………………………………………… - 55 -</a></p>
<p><a href="#_Toc532238441">7.7 hello进程execve时的内存映射……………………………………………….. - 57 -</a></p>
<p><a href="#_Toc532238442">7.8 缺页故障与缺页中断处理……………………………………………………….. - 58 -</a></p>
<p><a href="#_Toc532238443">7.9动态存储分配管理…………………………………………………………………… - 58 -</a></p>
<p><a href="#_Toc532238444">7.10本章小结……………………………………………………………………………….. - 59 -</a></p>
<p><a href="#_Toc532238445">第8章 hello的IO管理………………………………………………………………… - 62 -</a></p>
<p><a href="#_Toc532238446">8.1 Linux的IO设备管理方法……………………………………………………….. - 62 -</a></p>
<p><a href="#_Toc532238447">8.2 简述Unix IO接口及其函数…………………………………………………….. - 62 -</a></p>
<p><a href="#_Toc532238448">8.3 printf的实现分析…………………………………………………………………….. - 62 -</a></p>
<p><a href="#_Toc532238449">8.4 getchar的实现分析………………………………………………………………….. - 65 -</a></p>
<p><a href="#_Toc532238450">8.5本章小结…………………………………………………………………………………. - 66 -</a></p>
<p><a href="#_Toc532238451">结论……………………………………………………………………………………………… - 66 -</a></p>
<p><a href="#_Toc532238452">附件……………………………………………………………………………………………… - 68 -</a></p>
<p><a href="#_Toc532238453">参考文献………………………………………………………………………………………. - 69 -</a></p>
<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p>​    P2P：即从 Program to process由我们在IDE像是VScode、Codeblocks里一行行用C语言这一高级语言编写代码开始，在静态检查无错误后保存得到hello.c文件，而这样的文件仅我们程序员可理解，机器无法理解，也就是programmer（程序员）写出的程序（program），然后经过一系列处理：预处理（预处理器cpp生成hello.i修改的源文件代码）、编译（编译器cc1生成编译文件hello.s）、汇编(汇编器as生成hello.o可重定位目标文件)、链接（链接器ld生成hello可执行目标文件），最后在shell里输入命令运行hello可执行目标文件，shell为其fork一个子进程， hello就实现了从program到process（进程）的转变。</p>
<p>​    020：即: From Zero-0 to Zero-0。shell为hello程序fork进程后，子进程调用execve，将hello加载到内存，由0开始，对hello这个文件进行内存映射，将可执行目标文件中的代码和数据从磁盘中复制到内存中，设置当前进程上下文中的程序计数器，使PC为hello的入口点，然后开始运行hello，运行过程中，PC发生变化，将指令和数据入内存，CPU以流水线形式读取并执行指令，执行逻辑控制流。操作系统负责进程调度，为进程分时间片，进行上下文切换。执行过程其多次访问L1、L2、L3高速缓存、TLB、多级页表等进行存储管理，通过I/O系统进行键盘输入输出来改变异常控制流直到结束。当程序运行结束后，成为僵死进程，hello的父进程shell/bash回收hello进程的内存，hello结束了，又回归到0，则就是O2O过程。</p>
<h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>​    硬件环境：X64 CPU Intel酷睿i7 9750H;2.9GHZ;16G RAM; 512G SSD;</p>
<p>​    软件环境：Windows10 64位；VMware WorkStation Pro16.1；Ubuntu 20.04 LTS；</p>
<p>​    开发工具：Visual Studio 2019 64位；CodeBlocks 64位；GDB；edb-debugger；gedit；</p>
<h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><table>
<thead>
<tr>
<th>文件名称</th>
<th>文件作用</th>
</tr>
</thead>
<tbody><tr>
<td>hello.c</td>
<td>保存hello源代码即源文件</td>
</tr>
<tr>
<td>hello.i</td>
<td>经过预处理的修改了的源文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>编译器编译hello.i生成的汇编文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>编译器编译hello.s生成的可重定位目标文件</td>
</tr>
<tr>
<td>hello.elf</td>
<td>hello.o文件的ELF格式文件，查看hello.o各节的信息</td>
</tr>
<tr>
<td>hello.txt</td>
<td>objdump反汇编hello.o生成的汇编文件与hello.s对比</td>
</tr>
<tr>
<td>hello</td>
<td>链接器重定位、链接生成的可执行目标文件</td>
</tr>
<tr>
<td>hello2.elf</td>
<td>hello文件的ELF格式文件，查看hello各节的信息</td>
</tr>
<tr>
<td>hello2.txt</td>
<td>objdump反汇编hello文件生成的汇编文件</td>
</tr>
</tbody></table>
<h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>​    本章主要简述了hello的诞生，即Hello的简介，介绍了个人的实验环境包括硬件环境和软件环境，以及大作业中用到的开发工具，列出了论文中间文件的名字及作用，是本篇论文的背景和简要介绍。</p>
<p>（第1章0.5分）</p>
<h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>​    预处理的概念：</p>
<p>​    先介绍预处理指令的概念：C 语言编程过程中，经常会用到如 #include、#define 等指令，这些标识开头的指令被称为预处理指令，预处理指令由预处理程序（预处理器）操作。</p>
<p>​    预处理指令及分类：</p>
<p>​    ANSI C 定义的预处理指令主要包括：文件包含、宏定义、条件编译和特殊控制等 4 类。</p>
<ol>
<li><p>文件包含：#include 是 C 程序设计中最常用的预处理指令。例如，几乎每个需要输入输出的 C 程序，都要包含 #include&lt;stdio.h&gt; 指令，表示把 stdio.h 文件中的全部内容，替换该行指令。</p>
<p>此外，包含文件的格式有 #include 后面跟尖括号 &lt;&gt; 和双引号 “” 之分。两者的主要差别是搜索路径的不同。</p>
<p>(1)尖括号形式：如 #include&lt;math.h&gt;，预处理器直接到系统目录对应文件中搜索 math.h 文件，搜索不到则报错。系统提供的头文件一般采用该包含方式，而自定义的头文件不能采用该方式。</p>
<p>(2)双引号形式：如 #include”cal.h”，首先到当前工作目录下查找该文件，如果没有找到，再到系统目录下查找。包含自定义的头文件，一般采用该方式。虽然系统头文件采用此方式也正确，但浪费了不必要的搜索时间，故系统头文件不建议采用该包含方式。</p>
</li>
<li><p>宏定义：包括定义宏 #define 和宏删除 #undef。如我们常用的#define N 5</p>
<p>定义无符号宏，或定义符号常量N;</p>
</li>
<li><p>条件编译：主要是为了有选择性地执行相应操作，防止宏替换内容（如文件等）的重复包含。常见的条件编译指令有 #if、#elif、#else、#endif、#ifdef、#ifndef。</p>
</li>
<li><p>特殊控制：ANSI C 还定义了特殊作用的预处理指令，如 #error、#pragma。</p>
<p>#error：使预处理器输出指定的错误信息，通常用于调试程序。</p>
<p>#pragma：是功能比较丰富且灵活的指令，可以有不同的参数选择，从而完成相应的特 定功能操作。调用格式为：#pragma 参数。</p>
<p>再介绍一下C预处理器（C Pre-Processor）也常简写为 CPP，是一个与 C 编译器独立的小程序，预处理器并不理解 C 语言语法，它仅是在程序源文件被编译之前，实现文本替换的功能。如我们常用#define N 100，其会将程序.c文件所有的N替换为100，仅仅修改程序源文件罢了。</p>
</li>
</ol>
<p>​    预处理过程进行的操作：</p>
<ol>
<li><p>将所有的“#define”删除，并且展开所有的宏定义</p>
</li>
<li><p>处理所有的条件编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”</p>
</li>
<li><p>处理“#include”预编译指令，将被包含的头文件插入到该编译指令的位置。（这个过程是递归进行的，因为被包含的文件可能还包含了其他文件）</p>
</li>
<li><p>删除所有的注释“//”和“/* */”。</p>
</li>
<li><p>添加行号和文件名标识，方便后边编译时编译器产生调试用的行号心意以及编译时产生编译错误或警告时能够显示行号。</p>
</li>
<li><p>保留所有的#pragma编译指令，因为编译器需要使用它们。</p>
</li>
</ol>
<p>​    预处理的作用：</p>
<p>​    我们先看hello.c的源代码</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image002.png"></p>
<center>图2‑1 hello.c的源代码</center>

<p>​    预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如上图中hello.c中第一行的代码：#include &lt;stdio.h&gt; 命令高速预处理器读取系统头文件stdio.h的内容，以此类推，第二、三行代码#include &lt;unistd.h&gt;;#include&lt;stdlib.h&gt;则是命令高速预处理器读取系统头文件unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中。结果得到另一个C程序，通常是以.i作为文件拓展名，其是一个修改了的源程序（文本），将源程序文件hello.c进行拓展，便于后面编译。</p>
<h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p>​    在ubutun终端输入如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linux&gt; gcc –E –o hello.i hello.c</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image003.png"></p>
<center>图2‑2 ubutun下预处理命令及生成的hello.i文件</center>



<h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>​    linux下gedit打开刚才所得到hello.i文件进行查看：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image004.png"></p>
<center>图2‑3 hello.i文件的内容</center>

<p>​    从上图可以看到其不再是#include &lt;stdio.h&gt;; #include &lt;unistd.h&gt;;#include&lt;stdlib.h&gt;;等语句，而是高速预处理器读取读取系统头文件stdio.h、unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中，那我们原来main函数的内容还在吗？继续往下查看hello.i的内容，原来hello.c文件中，main函数在最后面，cpp将原来#include的预处理指令替换成系统头文件的内容，那么main函数应该也是在hello.i的末尾，查看后果然如此，前面三千多行都是头文件内容，并未发生变化。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image005.png"></p>
<center>图2‑4 hello.i文件中main函数的内容</center>

<p>​    这里我们就验证了预处理的作用：就是预处理器CPP处理预处理指令，预处理器读取了系统头文件unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中，对原来的预处理指令进行文本替换，得到修改了的源程序hello.i，便于后面的编译器对程序进行编译。</p>
<h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>​    这一章主要先是介绍了预处理指令的概念，通常以#开头，再介绍了预处理器，然后预处理器CPP处理预处理指令，其并不理解 C 语言语法，它仅是在程序源文件被编译之前，实现文本替换的功能，将预处理指令替换，在hello.c文件中就是，预处理器读取了系统头文件unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中，对原来的预处理指令进行文本替换，得到修改了的源程序hello.i，便于后面的编译器对程序进行编译。</p>
<p>（第2章0.5分）</p>
<h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>​    编译的概念：</p>
<p>​    要介绍编译，就需要先介绍CPU指令集，指令集包括汇编语言形式和二进制机器码格式，然后根据CPU指令集，去完成处理器的架构，就是处理器的硬件架构，称为微架构，是一堆硬件电路，去实现指令集所规定的操作运算。处理器是一堆硬件电路，只能识别二进制数据，所以其执行的是二进制代码或是机器代码（这叫机器指令，机器能理解并且执行），而汇编代码或汇编指令就是人类可读的机器代码的表示，每条汇编指令都有对应的机器码指令。现有CPU架构包括鼎鼎有名的Intel的X86架构（x86指令集）、ARM的ARM架构、MIPS的MIPS架构、DEC的Alpha架构。</p>
<p>​    编译，其就是将我们前一步预处理器CPP对hello.c文件进行预处理之后得到修改的源文件hello.i翻译成文本文件hello.s，把代码转化为汇编代码的过程，编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码，而编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，是人类可读的，不像机器代码是一串二进制数。</p>
<p>​    编译的作用：</p>
<p>​    编译程序过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p>
<ol>
<li><p>词法分析：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词（亦称单词符号或简称符号），如基本字（begin、end、if、for、while），标识符、常数、运算符和界符（标点符号、左右括号）。</p>
</li>
<li><p>语法分析：在词法分析的基础上，根据语言的语法规则，把单词符号串分解成各类语法单位（语法范畴），如“短语”、“句子”、“程序段”和“程序”等。</p>
</li>
<li><p>词义分析与中间代码产生：对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码）。</p>
</li>
<li><p>代码优化：优化的任务在于对前段产生的中间代码进行加工变换，以期在最后阶段能产生出更为高效（省时间和空间）的目标代码。</p>
</li>
<li><p>目标代码生成：这一阶段的任务是：把中间代码（或经优化处理之后）变换成特定机器上的低级语言代码。目标代码的形式可以是绝对指令代码或可重定位的指令代码或汇编指令代码。如目标代码是绝对指令代码，则这种目标代码可立即执行。如果目标代码是汇编指令代码，则需汇编器汇编之后才行运行。</p>
</li>
</ol>
<h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>​    在ubutun终端输入如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc –S –o hello.s hello.i</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image006.png" alt="img"></p>
<center>图3‑1 Ubuntu下编译的命令及编译生成的hello.s文件</center>




<h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p>​    先观察hello.c的源代码：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image002.png" alt="img"></p>
<center>图3‑2 hello.c的源代码</center>

<p>​    我们可以发现其中主要定义了3种类型的数据：</p>
<p>​    int argc，main函数的形参全局int型变量：argc，表示传入main函数的参数个数；</p>
<p>​    char *argv[]，main函数的形参全局char指针类型变量：argv，表示传入main函数的参数序列或指针，该指针指向一个字符串数组的首地址。</p>
<p>​    int i；main函数中的局部int型变量：i；</p>
<p>​    再观察其中C语言的操作：</p>
<p>​    先是控制转移和关系操作：if(argc != 4) 一个if判断，if控制转移， !=关系操作；</p>
<p>再是for(i=0;i&lt;8;i++)一个循环，for表示控制转移，=赋值操作，&lt;关系操作，++算术操作，argv[i]数组操作；</p>
<p>​    此外还有函数操作，最常见的printf函数，sleep函数，getchar函数的调用，其中包含了参数传递，最后是main函数返回 return 0。</p>
<p>下面则根据上述这些数据类型及操作说明，编译器是怎么处理C语言的各个数据类型以及各类操作的。</p>
<h3 id="3-3-1常量"><a href="#3-3-1常量" class="headerlink" title="3.3.1常量"></a>3.3.1常量</h3><p>​    这里主要有两个字符串常量，既然是字符串常量，那么存放在文件.rodata节中，只读，如图3-3所示，</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image007.png" alt="img"></p>
<center>图 3‑3 字符串常量</center>


<p>​    那么这两个字符串常量又在哪里使用呢？查看汇编代码可发现，其是printf函数输出的语句，作为参数被传入printf函数调用，如图3-4划线所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image008.png" alt="img"></p>
<center>图 3‑4 字符串常量对应汇编代码</center>


<p>再看对应源代码，其就是被printf函数输出，只是汇编代码中汉字被编码，而不是汉字的形式。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image009.png"></p>
<center>图 3‑5 字符串对应源代码</center>


<h3 id="3-3-2变量"><a href="#3-3-2变量" class="headerlink" title="3.3.2变量"></a>3.3.2变量</h3><p>​    这里主要有三个变量：argc，argv，i；</p>
<p>​    先是argc，其作为main函数的第一个参数，那么根据CPU传参寄存器顺序，其应该保存在%edi中，为什么不是%rdi，因为这里argc为int类型，4字节，32位寄存器%edi恰好放得下，这里就是movl %edi, -20(%rbp)，movl传送双字，4字节，将argc的值保存到栈内%rbp-20处，栈内保存的是局部变量。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image010.png" alt="img"></p>
<center>图 3‑6 参数argc和argv</center>


<p>​       再是第二个参数<em>argv，其应该保存在%rsi中，对应汇编语句movq $rsi,-32(%rbp)；</em>argv是一个指针，指向一个字符串数组，其存储的就是字符串数组的首地址，8字节，64位寄存器%rsi恰好能放得下，movq表示传送四字，8字节，将argv的值保存到栈内%rbp-32处。</p>
<p>​       再是另一个整形变量i，我们在上面的汇编代码中并没有找到，其实因为这里只是对其定义，而未赋值初始化，所以找不到，但是栈内开辟了存储这个局部变量i的空间。在后面.L2节中，对i赋值为0，我们发现了i。如下图所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image011.png" alt="img"></p>
<center>图 3‑7 变量i</center>


<h3 id="3-3-3赋值操作"><a href="#3-3-3赋值操作" class="headerlink" title="3.3.3赋值操作"></a>3.3.3赋值操作</h3><p>​        这里仅有一处赋值操作，对应movl $0, -4 (%rbp)</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image011.png" alt="img"></p>
<center>图 3‑8 赋值i=0</center>


<p>​        movl就是将0传递给栈内%rbp-4处的变量i，也就是将i的值赋为0。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image012.png" alt="img"></p>
<center>图 3‑9 赋值对应源代码</center>


<h3 id="3-3-4算术操作"><a href="#3-3-4算术操作" class="headerlink" title="3.3.4算术操作"></a>3.3.4算术操作</h3><p>​    源代码只有一处算术操作，查看汇编代码，寻找对应汇编语句：</p>
<p>addl $1, -4(%rbp)，如图3-6所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image013.png" alt="img"></p>
<center>图 3‑10 算术操作++</center>


<p>​    通过前面赋值操作已知，栈内%rbp-4存放的是局部变量i，这里是对其进行i+1的算术操作，同时我们可以发现其是.L4段的最后一条语句，.L4段对应for循环体内容，i++就应该在循环体内的语句都执行完以后再执行，然后再判断i&lt;8，符合C语言逻辑。其对应源代码就是：i++;</p>
<h3 id="3-3-5关系操作"><a href="#3-3-5关系操作" class="headerlink" title="3.3.5关系操作"></a>3.3.5关系操作</h3><p>​    源代码共有2处关系操作，我们查看汇编代码来寻找对应的关系操作，先是!=关系操作: cmpl $4, -20(%rbp)</p>
<p>![img](这里仅有一处赋值操作，对应movl $0, -4 (%rbp)</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image014.png" alt="img"></p>
<center>图 3‑11 !=关系操作</center>


<p>​    通过对前面数据的分析，已经得知栈内%rbp-20处存放的是传进main函数的形参argc，这里将其与4比较，mpl指令行为和sub指令的行为指令是一样的，其根据两个操作数之差来设置条件码，下一条汇编指令je，根据条件码，相等才发生跳转.L2执行，不相等则不跳转执行下一条语句，正好对应了图3-5所展示源代码所作的比较。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image015.png" alt="img"></p>
<center>图 3‑12 !=关系操作对于源代码</center>


<p>​    再看另一处关系操作&lt;：cmpl $7, 44(%rbp)</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image016.png" alt="img"></p>
<center>图 3‑13 &lt关系操作</center>


<p>​    通过对前面分析，已经得知栈内%rbp-4处存放的是main函数中定义的局部整型变量i，这里与7作比较，似乎与我们图3-7所示对应源代码不一致，再看下一条汇编指令jle，表示i小于等于7才跳转执行循环，其就等价于i&lt;8，才执行循环，与之相对应。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image017.png" alt="img"></p>
<center>图 3‑14 &lt 关系操作对应源代码</center>


<h3 id="3-3-6控制转移"><a href="#3-3-6控制转移" class="headerlink" title="3.3.6控制转移"></a>3.3.6控制转移</h3><p>​    源代码共有2处控制转移，我们查看汇编代码来寻找对应的控制转移，先是if控制转，对应图3-8划线两条语句所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image018.png"></p>
<center>图 3‑15 控制转移if</center>


<p>​    前面我们已经分析过了关系操作，这里先将argc与4比较对应cmpl，cmpl指令行为和sub指令的行为指令是一样的，其根据两个操作数之差来设置条件码，je根据条件码，argc等于4则跳转执行.L2的代码，不等于就执行下一条语句调用printf函数输出，对应源码图3-5所示的“if(argc!=4);”的这条语句。</p>
<p>再看另一处控制转移，for的控制转移，对应图3-9划线两条汇编代码所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image019.png" alt="img"></p>
<center>图 3‑16 for控制转移的汇编代码</center>


<p>​    前面我们已经分析过了关系操作，这里先将i与7比较对应cmpl，其根据两个操作数之差来设置条件码，jle根据条件码，i&lt;= 7则跳转执行.L4的代码，即for循环体内的代码，i&gt;8则跳出循环执行下一条语句调用getchar函数，对应源码图3-9所示的for循环的源代码。</p>
<h3 id="3-3-7-数组-指针-结构体操作"><a href="#3-3-7-数组-指针-结构体操作" class="headerlink" title="3.3.7 数组/指针/结构体操作"></a>3.3.7 数组/指针/结构体操作</h3><p>​       在源代码中我们共发现了三处数组操作，我们在汇编代码中寻找，如图3-17所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image020.png" alt="img"></p>
<center>图 3‑17 对argv数组的操作</center>


<p>​    我们前面已知%rbp-32存放的是argv，即argv数组的首地址，这里先是通过地址+16的偏移量访问argv[2]，将其传入寄存器%rdx中，再是通过地址+8的偏移量访问argv[1]，将其传入寄存器%rsi中，为下面调用printf函数做传参准备；再往下走，通过地址+24的偏移量访问argv[3]，将其传入寄存器%rdi中，为下面调用atoi函数做传参准备，如下图对应源码。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image021.png" alt="img"></p>
<center>图 3‑18 数组操作对应源码</center>


<h3 id="3-3-8函数操作"><a href="#3-3-8函数操作" class="headerlink" title="3.3.8函数操作"></a>3.3.8函数操作</h3><p>​    这里的函数操作较多，从头到尾先看源码分析。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image022.png" alt="img"></p>
<center>图 3‑19 hello.c中源代码的函数操作</center>


<p>​    第一处调用printf函数输出，汇编代码如图3-20所示，</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image023.png" alt="img"></p>
<center>图 3‑20 第一处printf函数调用</center>


<p>​    我们可以看到，其将.L0存储的字符串传入寄存器%rdi，恰好也是CPU传参使用寄存器的传递第一个参数所用的寄存器，然后简化调用puts函数输出，对应源代码图3-19中划线的1。</p>
<p>​    然后是调用exit函数退出，其汇编代码如图3-21所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image024.png" alt="img"></p>
<center>图 3‑21 调用exit函数退出</center>


<p>​    其先是将1传递到寄存器%edi，恰好也是CPU传参使用寄存器的传递第一个参数所用的寄存器，1为参数，为exit(1)中的‘1’，exit(1)表示异常退出，在退出前可以给出一些提示信息，然后调用exit函数退出，对应源代码图3-19中划线的2。</p>
<p>​    再是第二处调用printf函数输出，汇编代码如图3-22所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image025.png" alt="img"></p>
<center>图 3‑22 第二处调用printf函数</center>


<p>​    之前对数组操作分析可知，通过对栈内存放argv数组首地址加偏移量+16、+8，访问了argv[2]、argv[1]，并将其分别传入寄存器%rdx、%rsi中，传参使用对应寄存器的第三个、第二个，而传参用的第一个寄存器却是传进的.LC1的字符串常量，有些奇怪，与我们的源代码并不符合。这里其实对printf函数的一个理解，其先传进去的是printf函数输出的格式，告诉printf按照一个什么样的格式输出，然后再是传递我们要输出的值的参数，对应源代码图3-19中划线的3。</p>
<p>​    再是调用atoi函数，汇编代码如图3-23所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image026.png" alt="img"></p>
<center>图 3‑23 调用atoi函数</center>


<p>​    之前对数组操作分析可知，通过对栈内存放argv数组首地址加偏移量+24，访问了argv[3]，然后传入%rdi，作为调用atoi函数的参数，atoi是将字符串存储的数转化为整数类型，对应源代码图3-19中划线的4。</p>
<p>​    接着是调用sleep函数，汇编代码如图3-24所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image027.png" alt="img"></p>
<center>图 3‑24调用sleep函数</center>


<p>​    前面我们已经分析了atoi函数的调用，其将argv[3]作为参数，将argv[3]字符串类型转换为整数数值，然后返回，其返回值就保存在寄存器%eax中，然后这里在传递给%edi，变成了sleep函数的参数，然后调用sleep函数，对应源代码图3-19中划线的5。</p>
<p>​    再接着是调用getchar函数，汇编代码如图3-25所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image028.png" alt="img"></p>
<center>图 3‑25 getchar函数的调用</center>


<p>​    这里getchar函数的调用的汇编代码较为简单，但没有运行，不知道其功能，猜测可能是读取键盘输入，对应源代码图3-19中划线的6。</p>
<p>​    然后最后一个函数操作，汇编代码如图3-26所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image029.png" alt="img"></p>
<center>图3‑26 main函数返回</center>

<p>​    这里也较为简单，main函数结尾return 0；返回值设为0，保存在寄存器%eax中，然后main函数返回，程序退出。对应源代码图3-19中划线的7。</p>
<h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>   本章主要介绍编译，编译是C语言编译器对经过预处理后修改完的源代码hello.i文件的一个翻译，基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例将其翻译为人类可读、可理解的二进制代码或者说机器代码的文本表示——汇编代码，保存在hello.s文件中，依然是文本文件，接下来一步就是将汇编代码通过汇编器转换为机器代码，机器可读懂并执行的代码，一串二进制数，人很难理解。所以汇编代码就十分重要，其可以帮助我们去查看用高级语言所写代码在计算机内运行的逻辑及过程，理解汇编代码，可以帮助我们debug以及运用维护，同时也要注意到，有时候编译器会程序进行一定的优化，会改变一些库函数的调用，比如我们第一处调用printf函数，其计算机实际调用的却是puts函数。</p>
<p>（第3章2分）</p>
<h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>​    汇编的概念：</p>
<p>我们都知道，计算机的硬件作为一种电路元件，它的输出和输入只能是有电或者没电，也就是所说的高电平和低电平，所以计算机传递的数据是由“0” 和“1”组成的二进制数，所以说二进制的语言是计算机语言的本质，那么就有了机器指令的概念。</p>
<p>​    要讲汇编，需要先理解指令，之前我们在汇编部分已有谈及，这里给出更明晰的定义：指令被编码为有一个或多个字节序列组成的二进制格式一个处理器支持的指令和指令的字节级编码成为它的指令集体系结构，像Intel IA32和x86-64，x86-64也就是我们现在电脑windows系统所用的指令集体系结构。 </p>
<p>​    这里就是汇编器（as）将前面得到汇编文件hello.s从汇编语言指令翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并讲解结果保存在文件hello.o中，hello.o是一个二进制文件，其包含的字节是main函数的指令编码，这些指令的编码是基于该电脑上的指令集体系结构，用文本编辑器打开，将看到一堆乱码，人类完全无法读懂，但是计算机可以读懂并且执行，但部分要经过后续的链接才能执行。</p>
<h2 id="4-2在Ubuntu下汇编的命令"><a href="#4-2在Ubuntu下汇编的命令" class="headerlink" title="4.2在Ubuntu下汇编的命令"></a>4.2在Ubuntu下汇编的命令</h2><p>在ubutun终端输入如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc –c hello.s –o hello.o</span><br></pre></td></tr></table></figure>

<p>如下图4-1所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image030.png" alt="img"></p>
<center>图 4‑1 Ubutun下汇编的命令及汇编生成hello.o文件</center>



<h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p>​    分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</p>
<p>​    Ubutun终端输入以下命令：linux&gt; readelf –a hello.o &gt; hello.elf</p>
<p>​    readelf读出hello.o——ELF可重定位目标文件所有信息，保存到hello.elf文件中，便于查看。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image031.png" alt="img"></p>
<center>图 4‑2 readelf读取信息并保持到hello.elf文件</center>

<p>​    先回顾典型ELF可重定位目标文件的格式，如图4-2所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image032.png" alt="img"></p>
<center>图 4‑3 典型ELF可重定位目标文件</center>

<p>​    然后打开hello.elf文件分析。</p>
<p>​    先是ELF 头：描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。如图4-3所示。我们对此分析：首先是magic，</p>
<p>​    一个16字节的序列，描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息， 其中包括 ELF 头的大小、目标文件的类型、 机器类型、字节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量等信息。观察其指明了该ELF文件类别为ELF64文件，数据是64位，采用补码为2的小端法存储，系统架构为X86-64，该文件为REL，可重定位文件，程序入口点地址为0x0，节头部表条目数量为14，大小为64字节，偏移量为1240字节，还有符号表等信息。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image033.png" alt="img"></p>
<center>图 4‑4 ELF 头</center>

<p>​    再是节头部表：描述目标文件的节，如图4-4所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image034.png" alt="img"></p>
<center>图 4‑5 节头部表信息</center>

<p>​    节头部表也是段表，我们观察到有14个节，其给出各个节的节名，在文件中的偏移、大小、访问属性、对齐信息等等。这些数据是由段表中一系列段描述符承载完成的，其中最为重要的就是下一步链接所要使用的信息：该段符号表的位置及重定位表的信息。 </p>
<p>​    下面针对其比较重要的几个节来说明：</p>
<p>​    .text节: 存储已编译程序的机器代码，大小为0x92字节，偏移量为0x0;</p>
<p>​    .rodate节: 存储只读数据，如字符串常量，大小为0x33字节，偏移量为0xd8。</p>
<p>​    .data节: 存储已初始化的全局和静态C变量，大小为0x0字节，偏移量为0xd2。</p>
<p>​    .bss节: 存储未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量，大小为0x0字节，偏移量为0xd2。</p>
<p>​    .symtab节: 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息，大小为0x1b0字节，偏移量为0x180。</p>
<p>​    .strtab节: 一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字，大小为0x48字节，偏移量为0x340。</p>
<p>​    .rela.text节：一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这信息。大小为0xc0字节，偏移量为0x388。</p>
<p>​    再是重定位节：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image035.png" alt="img"></p>
<center>图 4‑6 重定位节</center>

<p>​    先介绍重定位的概念：重定位是连接符号引用与符号定义的过程。例如，程序调用函数时，关联的调用指令必须在执行时将控制权转移到正确的目标地址。可重定位文件必须包含说明如何修改其节内容的信息。通过此信息，可执行文件和共享目标文件可包含进程的程序映像的正确信息。重定位项即是这些数据。该信息就存储在重定位节中。</p>
<p>​    重定位节’.rela.text’：一个.text节中位置的列表，包含.text 节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者应用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改，就如图4-6所示，hello.o的重定位信息：各个节的符号名称、符号值、加数、类型、偏移量、信息等等。</p>
<p>​    最后是符号表：一个符号表，用来存放程序中定义和引用的函数和全局变量的信息。每个重定位文件都在.symtab中都有符号表，需要引用的符号都在其中声明。如图4-7所示，里面有我们在hello.c中看到几个函数的符号：exit，printf，atoi等等。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image036.png" alt="img"></p>
<center>图 4‑7 符号表</center>



<h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt;objdump -d -r hello.o</span><br></pre></td></tr></table></figure>

<p>​    如图4-8所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image037.png" alt="img"></p>
<center>图 4‑8 objump反汇编并保存为hello.txt文件</center>

<p>​    反汇编得到文件后，打开查看：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image038.png" alt="img"></p>
<center>图 4‑9 hello.o反汇编文件内容</center>

<p>​    发现与我们在第3章编译得到的hello.s的汇编代码并不一样，有很多差异。 </p>
<p>​    首先我们发现其开头表明其是由hello.o文件反汇编得到，文件格式为elf64-x86-64，而不是我们然后我们之前hello.s文件的存储的字符串常量.LC0和.LC1，在hello.s中，访问全局变量是通过字节使用声明中的助记符+off+%rip来实现的；而在这里hello.o反汇编代码中，访问全局变量是通过用$0x0(%rip)来确定，其因为.data与.rodata段中的数据地址在链接运行后时才确定的，因此，对全局变量的访问需要重定位，全局变量的访问需要添加重定位条目。</p>
<p>​    此外，其左侧多了一栏地址（格式为xx:）,以及一串十六进制数，如4: 55，4：表示地址，55则表示指令的字节级编码，是由汇编指令翻译而来，其再翻译成二进制数，就是低级语言，机器指令或是机器语言。以sub $0x20,%rsp这条汇编指令举例，其意思为将寄存器%rsp存储的值减去-0x20然后存储在寄存器内，其对应的指令的字节级编码为48 83 ec 20。我们这里解析一下这个指令编码，其与汇编代码的对应关系。每条指令需要1-10个字节不等，这取决于需要哪些字段，此外每个字节编码都只有唯一的结束，任何一个字节序列要么就是一个为的指令序列的编码，要么就不是一个合法的字节序列。</p>
<p>​    指令的编码为48 83 ec 20共8位，按顺序放。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">3</td>
<td align="center">e</td>
<td align="center">c</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>​    每条指令的第一个字节表明指令的类型，这里就是0、1两位存储的一个字节，这个字节分为两个部分，每部分4位：高4位是代码部分，低4位是功能部分，这里0存储的就是高4位代码部分，表明其是什么操作，整数操作、分支条件传送或是函数操作等等；这里1存储的就是低4位功能部分，0里面存储的4表示整数操作，8表示是整数操作里面的减法操作。再接着往下看2、3位存储的字节，是寄存器指示符字节，指定一个或两个寄存器，根据指令类型，其可以指定用于数据源和目的寄存器，或是用地址计算的基址寄存器，其表明使用的寄存器的编号，如3位存储的3为该指令集下寄存器%rsp的相对应的标识符。再往下看是一个常数字，6、7两位存储的0x20，表明要减去立即数0x20。同时我们可以看到，地址8的下一条语句的地址是c，而不是9，有些奇怪，其实这里的地址是等于上一条语句的地址+指令的字节数，这里上一条语句地址为8，指令的字节数为4，8+4=12，反以十六进制就是12。</p>
<p>​    下面还有一个明显区别就是，分支转移。我们在第3章可以观察到其发生跳转都是跳转到另一段中，使用助记符.LX，例如.L2，.L4等。而在反汇编代码中，我们可以发现转跳指令语句中目的地址使用的是实际地址，如&lt;main+0x20&gt;等等。如图4-10所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image039.png" alt="img"></p>
<center>图 4‑10 hello.o与hello.s跳转转移的对应</center>

<p>​    再看函数调用也有区别，在hello.s文件中，函数调用call的对象直接就是调用函数名称，而在hello.o反汇编中，call 的对象却是目标地址，而不是之前的函数名称，而是当前下一条指令地址，但这并不是目标函数的地址，其是因为hello.c中调用的函数不是本地函数，而是共享库中的函数，需要通过动态链接器要将共享库与程序链接后才能确定函数的运行时真正的地址，而在hello.o可重定位文件生成为机器语言的时候，这些地址并不确定，所以被称为可重定位文件，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全目标地址正是下一条指令，然后在.rela.text节中为其添加重定位条目，在连接阶段静态链接会重定位。如图4-11所示</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image040.png" alt="img"></p>
<center>图 4‑11 函数调用的对应</center>

<p>​    </p>
<h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>​    本章先是介绍了汇编的概念及作用，汇编器as将前面得到汇编文件hello.s从汇编语言指令翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式hello.o文件，分析了elf文件的内容，包含的elf头、符号表、.text节等等各种信息，说明其为什么是可重定位文件，其还要经过后续的链接重定位才可运行。然后比较了hello.o饭汇编文件与hello.s编译文件的差异，同为汇编代码，却在表达上有种种差异，如条件转移，函数调用，同时也讲明了汇编代码与机器代码的映射，指令字节级编码的概念。</p>
<p>（第4章1分）</p>
<h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p>​    链接是链接器（ld）将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行与加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是有应用程序来执行。链接由链接器的程序自动执行的。</p>
<p>​    链接器在软件开发中扮演着一个关键的角色，因为他们使得分离编译成为可能。我们不用讲一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块的一个时，只需要简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
<p>​    举例：hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。结果就是得到hello文件，他是一个可执行目标文件，可以被加载到你内存中，由系统执行。</p>
<h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linux&gt;ld -o hello -dynamic-linker /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span></span><br><span class="line"></span><br><span class="line"> /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o </span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure>

<p>(注意：其是连续的而不是隔开的的，如图5-1所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image041.png" alt="img"></p>
<center>图 5‑1 链接指令及链接生成的hello可执行目标文件</center>



<h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>​    Ubutun终端输入下列命令，将其保存到hello2.elf文件中，与之前读取hello.elf区别开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; readelf -a hello &gt; hello2.elf</span><br></pre></td></tr></table></figure>



<p>​    同样先回顾一下典型的可执行目标文件的ELF格式，如图5-2所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image042.png" alt="img"></p>
<center>图 5‑2 典型的ELF可执行目标文件</center>

<p>​    可以发现可执行目标文件的ELF格式与可重定位目标文件的ELF格式基本一致，但其少了部分内容，少了rela.text等等，虽少了这些内容，但hello的ELF文件内容较hello.o多了许多，内容上有差异，我们将hello和hello.o对照观察，有些差异，如图5-3所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image043.png" alt="img"></p>
<center>图 5‑3 hello文件elf格式与hello.o文件elf格式对比</center>

<p>​    从hello文件elf格式与hello.o文件的elf格式的对比，可以观察到，文件类型由hello.o的可重定位文件（REL）变为hello的可执行文件（EXEC），入口点地址也由0变为0x4010f0，程序头起点也由0变为64字节，节头部的开始由1240变为14208，</p>
<p>​    节的数量和程序头的数量都变多了。</p>
<p>​    下面查看hello的ELF文件其各段的基本信息，包括各段的起始地址、大小、偏移量、对齐等信息等，如图5-4及5-5所示。<img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image044.png" alt="img"></p>
<center>图 5‑4 hello的ELF格式的节的信息1 </center>

<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image044.png" alt="img"></p>
<center>图 5‑5 hello的ELF格式的节的信息2</center>

<p>​    hello文件的ELF格式还较hello.o文件的ELF格式多出了一个程序头的内容：程序头表描述了可执行文件的连续片与连续内存段之间的映射关系，根据程序表头的内容，可以根据可执行文件的内容初始化两个内存片段。如下图5-6所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image046.png" alt="img"></p>
<center>图 5‑6 hello文件程序头的内容</center>

<p>​    此外还多了段节的内容以及动态节的内容，如图5-7所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image047.png" alt="img"></p>
<center>图 5‑7 段节及动态节的内容</center>

<p>​    可重定位节的内容也发生了改变，多了我们hello中所调用系统库内函数的内容。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image048.png" alt="img"></p>
<center>图 5‑8 重定位节的内容</center>

<p>​    此外，符号表的内容也大大增多，包含51项，较原来的18项大大增多。如下图5-9所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image049.png" alt="img"></p>
<center>图 5‑9 符号表的内容</center>



<h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p>​    使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。  </p>
<p>edb运行hello程序，打开data dump可查看hello进程的虚拟地址空间各段信息，如图5-10所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image050.png" alt="img"></p>
<center>图 5‑10 hello的虚拟地址空间</center>

<p>​     观察发现程序被分配到虚拟地址为0x0400000~0x0405000的虚拟空间上，同时我们观察到点运行后，跳转到地址0x0401000，刚好与我们刚才elf文件（图5-3所示）读出信息，程序入口点地址为0x401000一致，结束地址为0x0401ff0，各个段的顺序与节表头的顺序一一对应。</p>
<p>​    举例说明：</p>
<p>​    根据ELF文件读出信息查看：先是ELF头：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image051.png" alt="img"></p>
<center>图 5‑11 ELF头从0x400000开始</center>

<p>​    再是.interp段的地址，存储着动态链接共享库路径：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image051.png" alt="img"></p>
<center>图 5‑12 .interp从0x4002e0开始</center>

<p>​    此外，我们再查看ELF 格式文件中的程序头，程序头表在执行的时候被使用，通过表中的信息我们可以得知内存与段之间的映射关系，表中得到每一个项提供了各段的基本信息，如图5-11所示，其中offset表示偏移，birtAddr就表示虚拟地址的起始，physAddr表示物理地址的起始，FileSiz表示目标文件中的段大小，MemSiz表示内存中的段大小，Flags表示运行时访问权限，最后Align表示对齐。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image053.png" alt="img"></p>
<center>图 5‑13 程序表头的内容</center>

<p>​    程序表头主要有以下几个内容：</p>
<ol>
<li><p>PHDR：保存程序头表。</p>
</li>
<li><p>INTERP：指定在程序已经从可执行文件映射到内存之后，必须调用的解释</p>
</li>
</ol>
<p>器（如动态链接器）。</p>
<ol start="3">
<li>LOAD：只读代码段。</li>
<li>LOAD：读写数据段：表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串） 、程序的目标代码等。</li>
<li>DYNAMIC：保存了由动态链接器使用的信息。</li>
<li>NOTE：保存辅助信息。</li>
<li>GNU_STACK： 权限标志，标志栈是否是可执行的。</li>
<li>GNU_RELRO： 指定在重定位结束之后那些内存区域是需要设置只读。</li>
</ol>
<h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>​    objdump -d -r hello 分析hello与hello.o的不同，说明链接的过程。</p>
<p>​    在linux终端下输入下列命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux &gt; objdump –d –r hello &gt; hello2.txt</span><br></pre></td></tr></table></figure>

<p>​    将hello可执行文件反汇编的内容保存到hello2.txt文件中，与hello.o文件做区别，如图5-12所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image054.png" alt="img"></p>
<center>图 5‑14 hello文件反汇编得到hello2.txt</center>

<p>​    然后将二者比对来看： </p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image055.png" alt="img"></p>
<center>图 5‑15 hello.o文件与hello文件反汇编对比 </center>

<p>​    我们发现，程序入口地址其由原来的0变成0x401000，此外也不是以mian函数开始，而是以init函数开始，地址在链接器重定位后，变成了CPU实际分配的虚拟地址，其地址计算是通过0x040000+数据所在节的地址+再加节内偏移量即可得出；此外还多了许多我们在hello里面调用函数的内容，像是puts、getchar等等库文件的内容，如图5-14所示，这是我们之前hello.o反汇编文件里面所没有看到，变化这样一来也是验证了链接，将共享库的内容与hello.o的内容链接、合并了进来。其中</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image056.png" alt="img"></p>
<center>图 5‑16 hello反汇编文件调用函数的内容</center>

<p>​    此外，还多出了一些节的内容，像是_init等等。多出来节的作用：</p>
<p>​    .init: 程序初始化执行的代码；</p>
<p>​    .plt: 静态连接的连接表；</p>
<p>​    .plt.got: 保存函数引用的地址；</p>
<p>​    .fini: 程序正常终止时执行的代码。</p>
<p>​    然后介绍重定位的概念：</p>
<p>​    重定位：在连接阶段，连接器将所有的相同类型的节合并为同一类型的新的聚合节，然后连接器将运行时内存地址赋值给新的聚合节，赋值给输入模块定义的每个节，以及以及赋值给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址。</p>
<p>​    重定位节中的符号引用：在这一步中，连接器修改代码节的符号节中的引用，使它们指向正确的运行时地址，完成这一步，连接器需要依赖可重定位目标模块中称为重定位条目。</p>
<p>​    给出重定位条目的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span>   offset;             <span class="comment">//节内偏移</span></span><br><span class="line">	<span class="keyword">long</span>   type:<span class="number">32</span>,          <span class="comment">//重定位类型</span></span><br><span class="line">	 	   symbol:<span class="number">32</span>;         <span class="comment">//说绑定的符</span></span><br><span class="line">	<span class="keyword">long</span>   addend;           <span class="comment">//偏移调整</span></span><br><span class="line">&#125;Elf64_Rela</span><br></pre></td></tr></table></figure>



<p>​    我们先看hello.o文件的重定位节的内容，然后举例说明</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image057.png" alt="img"></p>
<center>图 5‑17 hello.o重定位条目与hello.o反汇编文件的对应</center>

<p>​    图5-17中R_X86_64_PC32：32位相对地址引用，一个PC相对地址就是据程序计数器（PC）的当前运行值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的地址。图5-17中.rodata-4就是PC相对寻址。</p>
<p>​    那么符号（symbol）puts偏移（offset）是21，类型（type）是R_X86_64_PLT32，</p>
<p>addend为-4；</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image058.png" alt="img"></p>
<center>图5‑18puts函数在hello文件里的地址</center>

<p>​    当运行到call puts函数这条语句的PC值为下一条语句的地址：0x40114a，再看call这条机器指令的字节级编码：e8表是call，后面的46 ff ff ff则是相对寻址的偏移量</p>
<p>​    小端存储，为0xffffff46 = -0xba</p>
<p>​    故call 指令后面的地址值为0x40 114a-0xba=0x401090。</p>
<h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><p>使用edb执行hello，从加载hello到_start，到call main,以及程序终止的所有过程。</p>
<table>
<thead>
<tr>
<th>调用程序</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>ld-2.31.so!_dl_start</td>
<td>0x00007f58fe20fb30</td>
</tr>
<tr>
<td>ld-2.31.so!_dl_init</td>
<td>0x00007f58fe20fbc0</td>
</tr>
<tr>
<td>hello!_start</td>
<td>ox4010e0</td>
</tr>
<tr>
<td>libc-2.31.so!_libc_start_main</td>
<td>0x00007fe977429bc0</td>
</tr>
<tr>
<td>ld-2.31.so!_dl_fixup</td>
<td>0x00007ffed6dbae70</td>
</tr>
<tr>
<td>libc-2.31.so!_cxa_atexit</td>
<td>0x00007ffed6a1b700</td>
</tr>
<tr>
<td>libc-2.31.so!_libc_csu_init</td>
<td>0x401260</td>
</tr>
<tr>
<td>libc-2.31.so!_setjmp</td>
<td>0x00007ffed6a166d0</td>
</tr>
<tr>
<td>hello!main</td>
<td>0x4011d6</td>
</tr>
<tr>
<td>hello!puts@plt</td>
<td>0x401090</td>
</tr>
<tr>
<td>hello!exit@plt</td>
<td>0x4010b0</td>
</tr>
<tr>
<td>ld-2.31.so!_dl_fixup</td>
<td>0xo0007ffcd6dbae70</td>
</tr>
<tr>
<td>libc-2.31.so!exit</td>
<td>0x00007f69325cf4b0</td>
</tr>
<tr>
<td>libc-2.31.so!_run_exit_handlers</td>
<td>0x00007f69325cf390</td>
</tr>
</tbody></table>
<h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>​    分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。</p>
<p>​    动态链接的概念：</p>
<p>​    动态链接，在可执行文件装载时或运行时，由操作系统的装载程序加载库。大多数操作系统将解析外部引用（比如库）作为加载过程的一部分。</p>
<p>以下两个概念较为重要</p>
<ol>
<li><p>装载时重定位：对于动态共享库中的函数，在编译阶段无法获得其真实地址；在动态连接阶段，连接器将共享函数设置一个重定位项，其中包含重定位信息（ADDR(.plt)+offset）和符号表信息，然后在运行时根据重定位项信息才能确定其真实地址。</p>
</li>
<li><p>PIC（地址无关代码）：动态链接库希望所有进程共享指令段而各自拥有数据段的私有副本，为了实现这个目标，就要采用与地址无关代码的技术。该实现的基本思想是：把指令中需要修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分则在每个进程拥有一个副本。</p>
</li>
</ol>
<p>​    在之前读取hello的ELF格式文件时，发现了一个dynamic section。假如一个object文件参与动态的连接，它的程序头表将有一个类型为PT_DYNAMIC</p>
<p>的元素。该“段”包含了.dynamic sectio。说明有下列这些项目参与了动态的链接，</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image059.png" alt="img"></p>
<center>图 5‑19 Dynamic section</center>

<p>​    此外，我们分析在dl_init前后，观察这些项目的内容变化。</p>
<p>​    我们先观察没有dl_init的.plt和.pot的内容，如图所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image060.png" alt="img"></p>
<center>图 5‑20 未dl_init的内存</center>

<p>​    dl_init后.plt和.pot的内容，如图所示</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image061.png" alt="img"></p>
<center>图 5‑21 dl_init后的内存</center>

<p>​    可以发现，原先有些内存存储的是0被赋值，其内容对应着那些动态链接进来的项目，举例第二行的地址内容即为以下函数的地址;libc-2.31.so!_libc_start_main , ox00007fe977429bc0。</p>
<p>​    同时还可以发现其增加了链接了一些库，如图所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image062.png" alt="img"></p>
<center>图 5‑22 dl_init后增加的库</center>



<h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>​    本章主要介绍了链接的概念，链接器（ld）将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。其中我们观察了链接前后，hello.o的elf格式文件与hello的elf格式文件内容上的差异，以及由二者反汇编代码的差异去分析、理解链接的概念，包括重定位等等。</p>
<p>（第5章1分)</p>
<h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h1><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p>​    进程：一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正常运行所需的状态组成。</p>
<p>​    关注进程提供给应用程序的关键抽象：</p>
<ol>
<li><p>一个独立的逻辑控制流，他提供一个假象，好像我们的程序独占地使用处理器；</p>
</li>
<li><p>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。</p>
<p>创建：父进程调用fork函数创建一个新的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。</p>
</li>
</ol>
<p>回收方法：</p>
<p>​    1. 当一个进程终止时，内核并不是立即把它从系统中清除，直到被其父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，完成进程回收。</p>
<pre><code>2. 如果一个父进程终止了，内核会安排init进程成为其子进程的父进程，负责回收父进程已终止的子进程。
</code></pre>
<h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p>​    shell是一个用C语言编写的程序，通过Shell用户可以访问操作系统内核服务，类似于DOS下的command和后来的cmd.exe。shell既是一种命令语言，又是一种程序设计语言。shell是一个应用程序。shell还是系统的用户界面，提供了用户与内核进行交互操作的一种接口，其接收用户输入的命令并把它传入内核去执行。</p>
<p>​    shell的功能：</p>
<ol>
<li><p>当shell作为命令语言，它交互式地解释和执行用户输入的命令；</p>
</li>
<li><p>当shell作为程序设计语言，它定义了各种变量、参数、函数、流程控制等等。它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。</p>
</li>
</ol>
<p>shell的处理流程：</p>
<ol>
<li>从终端读取输入的命令。</li>
<li>将输入字符串切分获得所有的参数</li>
<li>如果是内置命令则调用内部函数立即执行，否则调用相应的程序执行</li>
<li>shell可接受键盘输入信号，并对这些信号进行相应处理</li>
</ol>
<h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>​    在linux在终端下执行下列语句来启动hello程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; ./hello <span class="number">1190201307</span> 徐伟 <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>​    看到屏幕输出： Hello 1190201307 徐伟 </p>
<p>且程序没有停止，直到过了30s后才结束，这里就表明运行了hello这个程序。</p>
<p>​    shell从命令行读取了这行命令，然后对其进行解析，判断非内置命令，而是运行程序，调用fork机制，为这个程序fork了一个进程，为shell的子进程，与shell同属一个进程组，进程组号相同，这里hello进程pid为31524，新创建的子进程拥有几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，其意思是当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别在于它们拥有不同的 PID。此外，父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。如果在shell上无作特殊说明，则在子进程执行期间，父进程（shell）默认选项是显式等待子进程的完成，如指定为后台程序，则无需等待子进程完成。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image063.png" alt="img"></p>
<center>图 6‑1 为hellofork的进程</center>

<p>​    下面用一个进程图来说明Hello的fork进程创建过程。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image064.png" alt="img"></p>
<center>图 6‑2 hello的fork进程创建</center>



<h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>​    因为shell判断出hello不是内置命令，且hello是一个可执行文件，所以shell在当前进程的上下文中调用execve函数加载并运行hello程序，且带参数列表argv和环境变量列表envp。argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串，按照惯例，argv[0]是可执行目标文件的名字，所以我们可以想到hello.c文件中，其访问的是argv[1],argv[2],argv[3]，存储的参数分别是我们的学号、姓名、sleep时间的字符串，就是刚才我们在终端输入“1190201307 徐伟 30”，即为参数。环境变量的列表是有一个类似的数据结构表示的，envp变量指向一个以null结尾的指针数组，其中每一个指针指向一个环境变量字符串。execve是通过调用驻留在存储器中称为加载器的操作系统代码来运行hello， 其删除进程现有虚拟内存映射关系，给hello分配新的虚拟内存地址,并映射hello中的文件或匿名文件至虚拟内存中。然后跳转至_start函数，再通过调用libc_start_main函数初始化环境变量等内容，并将程序执行至main函数入口。加载器将可执行目标文件中的代码和数据从磁盘中复制到内存中，然后通过跳转到程序的第一条指令或者入口点来运行hello。</p>
<h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>​    前面已经介绍过了进程的概念。我们提到了进程向每个程序提供了一个假象，好像它在独占地使用处理器。如果用调试器单步之形成，可以看到一系列的程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享库对象中的指令。这个PC值的序列就叫叫做逻辑控制流，简称逻辑流。若一个逻辑流的执行时间和另一个流重叠，则成为并发流，这两个流被称为并发地运行。多个流并发地执行地一般现象被称为并发。一个进程和其他进程轮流运行的概念为多任务，一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此多任务也叫做时间分片。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image065.png" alt="img"></p>
<center>图 6‑3 逻辑并发流</center>

<p>​    而操作系统内核则使用上下文切换的较高层形式的异常控制流来实现多任务。</p>
<p>​    内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。它由包括目的寄存器、程序计数器、用户栈、状态寄存器在内的对象的值构成。</p>
<p>​    当子进程调用exceve()函数在上下文中加载并运行hello程序后，hello程序不会立即运行，需要内核调度它。进程调度是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称为上下文切换的机制来将控制转移到新的进程。</p>
<p>​    处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。通常用某个控制寄存器的一个模式位来提供这种机制，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程运行在内核模式中，进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置；没有设置模式位时，进程运行在用户模式中，进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据，否则会导致保护故障。运行应用程序代码的进程初始时在用户模式中，进程需要通过中断、故障或者陷入系统调用这样的异常才能从用户模式变为内核模式。</p>
<p>​    由于负责进程调度的是内核，因此内核调度需要运行在内核模式下。当内核代表用户执行系统调用时，可能会发生上下文切换，中断也可能引发上下文切换。同时，系统通过某种产生周期性定时器中断的机制判断当前进程已经运行了足够长的时间，并切换到一个新的进程。</p>
<p>​    然后分析我们的hello的例子，当调用printf函数时，需要访问内核，这时就会进行上下文切换，于是进程就会从用户模式切换到内核模式。再比如说当hello进程调用sleep时，由于sleep是系统调用，进程陷入内核模式。这时hello进程被挂起，内核会选择调度其他进程，通过上下文切换保存hello进程的上下文，将控制传递给新调度的进程。定时器的时间到了后会发送中断信号，进入内核模式，将挂起的hello进程变成运行状态，这时hello进程就可以等待内核调度它。当从内核模式变回用户模式时，可能就返回切换到另一个进程了。这时会进行上下文切换，切换过程一般可分为3个部分，分别为：</p>
<p>​    （1）保存当前进程的上下文；</p>
<p>​    （2）恢复要执行进程之前保存的上下文；</p>
<p>​    （3）将控制传递给新恢复的进程。如图6-4所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image066.png" alt="img"></p>
<center>图 6-4 hello的上下文切换</center>



<h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><p>​    hello执行过程中，四类异常都可能会出现：故障，中断，陷阱，终止，图6-5总结了异常的类别。</p>
<p>​    故障：由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。</p>
<p>​    中断：中断是来自IO设备的信号，异步发生，中断处理程序对其进行处理，泛回后继续执行调用前待执行的下一条代码，就像没有发生过中断。</p>
<p>​    陷阱:有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。</p>
<p>​    终止：是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程</p>
<p>序会将控制返回给一个abort例程，该例程会终止这个应用程序。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image067.png" alt="img"></p>
<center>图 6‑5 异常的类别</center>

<p>​    （1）正常执行：hello程序正常执行，途中不作任何中断程序的输入，同时尝试键盘乱按，发现乱按会将乱按的输入的输出，  在执行完毕之后，hello进程被其父进程回收，同时getchar会读取键盘输入作为shell终端指令的输入，如图6-6所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image068.png" alt="img"></p>
<center>图 6‑6 hello正常执行</center>

<p>​    （2）键盘输入Ctrl+c，给正在运行的前台作业hello发送SIGINT信号，终止其进行，如图6-7所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image069.png" alt="img"></p>
<center>图 6‑7 hello被Ctrl+c终止</center>

<p>​    再使用linux&gt; ps 查看是否有这个hello进程，发现没有hello程序。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image069.png" alt="img"></p>
<p>​    <center> 图6-8 查看进程信息</center></p>
<p>​    （3）键盘输入Ctrl+z，给正在运行的前台作业hello发送SIGSTP信号，停止其进行，并且ps查看进程，发现其已停止，如图6-9所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image071.png" alt="img"></p>
<center>图 6-9 hello被Ctrl+z停止</center>

<p>​    再使用linux&gt;jobs查看当前shell的任务信息，linxu&gt;pstree打印进程关系树，显示进程之间的关系。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image072.png" alt="img"></p>
<center>图6-10 jobs查看任务信息及pstree查看进程关系树</center>

<p>​    此外linux&gt; bg，可以让暂停被提交至后台的hello作业转到前台继续运行，最后linux&gt;kill -9 pid ，杀死hello进程，终止其运行，如图6-10所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image073.png" alt="img"></p>
<center>图 6-11 杀死hello进程</center>



<h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>​    本章主要涉及到异常控制流的内容，引入了进程、上下文的概念，简述了壳Shell-bash的作用与处理流程，结合hello程序讲述了hello的fork进程创建过程、hello的execve过程和hello的进程执行，一个程序在计算机里运行的状态，前台作业或后台作业，以及运行各种可能出现的异常，以及对异常的处理，主要是各种来自键盘的中断等等。</p>
<p>（第6章1分）</p>
<h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p>​    先分别给出这4种地址的概念：</p>
<p>​    逻辑地址（Logical Address）：包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在80x86著名的分段结构中表现得尤为具体，它促使windows程序员把程序分成若干段。每个逻辑地址都由一个段地址和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。实际上也就是hello.o中的我们看到的以及hello.o的ELF格式文件中我们看到了偏移量及相对偏移地址。</p>
<p>​    线性地址：逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址后加上基地址就是线性地址。</p>
<p>​    虚拟地址：由CPU生产，经过MMU转换可以转换为物理地址，虚拟地址实际上就是一种线性地址。我们在hello反汇编文件中看到的就是虚拟地址。</p>
<p>​    物理地址：用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚按发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每一个字节都有一个唯一的物理地址。在hello得到虚拟地址后，通过查询页表等分页机制，将其转化为物理地址，到内存或磁盘中寻址，读取文件。</p>
<p>​    其关系如图7-1所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image074.png" alt="img"></p>
<center>图 7‑1 4类地址之间关系</center>

<p>​    hello.c在汇编生成hello.o可重定位目标文件后，还未与共享库链接，所以这里hello.o的反汇编代码体现的就是逻辑地址，仅有偏移量。再到重定位链接生成hello可执行文件，此时反汇编代码所体现的就是虚拟地址。</p>
<h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>​    段式内存管理方式就是直接将逻辑地址转换成线性地址，一个逻辑地址由两部份组成，段标识符: 段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。如7-2所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image075.png" alt="img"></p>
<center>图 7‑2  段标识符</center>

<p>逻辑空间：逻辑空间分为若干个段，其中每一个段都定义了一组具有完整意义的信息，逻辑地址对应于逻辑空间。</p>
<p>段： 段是对程序逻辑意义上的一种划分，一组完整逻辑意义的程序被划分成一段，所以段的长度是不确定的。</p>
<p>段描述符：段描述符段中的元素，用于描述一个段的详细信息的结构，段描述符一般是由8个字节组成。此外，又有很多段，就又相应多的段描述符，这些段描述符就组成了“段描述符表”。如图7-3所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image076.png" alt="img"></p>
<center>图 7‑3 段描述符的定义</center>

<p>​    逻辑地址到线性地址的转换过程：首先获取一个完整的逻辑地址[段选择符（段基值）：段内偏移地址], 看段选择描述符中的T1字段是0还是1，可以知道当前要转换的是GDT（全局段描述符）中的段，还是LDT（局部段描述符表）中的段，再根据指定的相应的寄存器，得到其地址和大小，我们就有了一个数组了。 拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，这样就有了Base，即基地址就知道了，把基地址Base+Offset,就是要转换的下一个阶段的物理地址。如图7-4所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image077.png" alt="img"></p>
<center>图 7‑4 逻辑地址到线性地址的转换过程</center>



<h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>​    前面我们已经介绍到了，由逻辑地址经过段式管理得到线性地址，也就是虚拟地址，而又虚拟地址并不够，还需要物理地址，才能到磁盘上存取。而线性地址（虚拟地址VA）到物理地址（PA）之间的转换通过分页机制以及页式管理来完成。</p>
<p>​    概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，磁盘上数组的内容被缓存在物理内存。 这些内存块被称为页。</p>
<p>​    操作系统通过将虚拟内存空间以页为单位分割管理，一页大小4KB；类似地，物理内存空间也以页以页为单位分割管理，一页大小4KB。通过MMU，可以将虚拟地址映射到唯一物理地址。</p>
<p>​    由此引入页表的概念：页表是一个页表条目 (Page Table Entry, PTE)的数组，将虚拟页地址映射到物理页地址。如图7-5所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image078.png" alt="img"></p>
<center>图 7‑5 页表</center>

<p>​    MMU利用页表实现从虚拟地址到物理地址的变换。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。</p>
<p>​    再介绍虚拟地址和物理地址的组成。</p>
<p>​    虚拟地址组成：虚拟地址由两部分组成VPN和VPO。VPN为虚拟页号，在虚拟地址高位位置；VPO为虚拟页偏移量，在虚拟地址低位位置。VA具体占用多少位，由系统环境决定；在Intel Core i7环境下，VPN占据高36位，VPO占据低12位。</p>
<p>​     物理地址组成：物理地址由两部分组成PPN和PPO。PPN为物理页号，在物理地址高位位置；PPO为物理页偏移量，在物理地址低位位置。PA具体占用多少位，由系统环境决定；在Intel Core i7环境下，PPN占据高40位，VPO占据低12位。</p>
<p>​    MMU利用VPN选择适当的PTE，如果这个PTE设置了有效位，则页命中，将页表条目中的物理页号和虚拟地址中的VPO连接起来就得到相应的物理地址。否则会触发缺页异常，控制传递给内核中的缺页异常处理程序。缺页处理程序确定物理内存中的牺牲页，调入新的页面，并更新内存中相应PTE。处理程序返回到原来的进程，再次执行导致缺页的指令，MMU重新进行地址翻译，此时和页命中的情况一样。</p>
<p>​    整个流程如下图：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image079.png" alt="img"></p>
<center>图 7‑6 基于页表的地址翻译</center>



<h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p>先介绍TLB的概念：TLB，也称翻译后备缓冲器，是在MMU中包括一个关于PTE的缓存。TLB是一个小的、虚拟寻址的缓存，每一行保存着一个由单个PTE组成的块。由于VA到PA的转换过程中，需要使用VPN确定相应的页表条目，因此TLB需要通过VPN来寻找PTE。和其他缓存一样，需要进行组索引和行匹配。如果TLB有2t个组，那么TLB的索引TLBI由VPN的t个最低位组成，TLB标记TLBT由VPN中剩余的位组成。如图7-7所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image080.png" alt="img"></p>
<center>图 7‑7 TLB的构成</center>

<p>​    接着介绍TLB的工作机制。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。</p>
<p>​    第1步:CPU产生一个虚拟地址。</p>
<p>​    第2步和第3步:MMU从TLB中取出相应的PTE。</p>
<p>​    第4步:MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</p>
<p>​    第5步:高速缓存/主存将所请求的数据字返回给CPU。</p>
<p>​    当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如图7-8(b)所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image081.png" alt="img"></p>
<center>图 7‑8 TLB命中与不命中</center>

<p>​    再接着介绍多级页表的概念：多级页表可以用来压缩页表，对于k级页表层次结构，虚拟地址的VPN被分为k个，每个VPNi是一个到第i级页表的索引。当1≤j≤k-1时，第j级页表中的每个PTE指向某个第j+1级页表的基址。第k级页表中的每个PTE和未使用多级页表时一样，包含某个物理页面的PPN或者一个磁盘块的地址。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image082.png" alt="img"></p>
<center>图 7‑9 二级页表层次结构</center>

<p>​    再将页表翻译：首先四级页表中，第一级页表为第二级页表的索引，第二级页表为第三级页表的索引，第三级为第四级的索引，最终的第四级页表映射到物理地址。然后对虚拟地址进行划分，得到VPN，则根据VPN访问页表，根据页表判断相应地址的数据是否缓存，若缓存，可直接从页表中读出PPN，则VPO与PPN组成一个完整的物理地址，接下来便可访存。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image083.png" alt="img"></p>
<center>图 7‑10 使用4级页表的地址翻译</center>



<h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>​    先介绍cache的概念：高速缓存cache被组成一个有S=2s个高速缓存组的数组，每个组包含E个高速缓存行。每个是由一个B=2b字节的数据块组成，一个有效位指明这个行是否存储有意义的信息，还有t=m-b-s个标记为，唯一标识存在这个高速缓存的块。如图7-11所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image084.png" alt="img"></p>
<center>图 7‑11 cache的结构</center>

<p>​    再给出三级Cache的相关概念，Cache被分为三级。L1级cache作为L2级cache的缓存，L2级cache作为L3级cache的缓存，而L3级cache作为内存（DRAM）的缓存。而L1cache又分为指令cache和数据cache。如图7-11所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image085.png" alt="img"></p>
<center>图 7‑12 Core i7的内存系统</center>

<p>​    当我们进行进行物理内存访问时，先将物理地址发送给L1级cache，看L1级cache中是否缓存了需要的数据。L1级cache共64组，每组8行，块大小64Bytes。由之前cache的结构将物理地址分为三部分，块偏移6位，组索引6位，剩下的为标记位40位。首先利用组索引位进行组匹配找到对应的组，然后在组中进行行匹配找到对应的行，对于组中的8个行，分别查看有效位并将行的标记位与物理地址的标记位匹配，当标记位匹配且有效位是1时，缓存命中，根据块偏移位取出对应的块就课直接将cache中缓存的数据传送给CPU。如果缓存不命中，需要继续从存储层次结构中的下一层中取出被请求的块，将新块存储在相应组的某个行中，可能会替换某个缓存行。</p>
<p>​    L1级cache不命中时，会继续向L2级cache发送数据请求。和L1级cache的过程一样，需要进行组索引、行匹配和字选择，找到后将数据传送给L1级cache。如果L2级cache不命中时，则会继续向L3级cache发送数据请求。最后，L3级cache不命中时，只能从内存中请求数据了。</p>
<h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>​    前面在第6章我们讲hello的fork进程创建时，就已提到shell父进程为新创建的hello子进程提供了一个几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，其意思是当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别在于它们拥有不同的 PID。为了给这个新进程创建虚拟内存，fork创建了当前进程的mm_struct，区域结构和页表的原样副本。fork将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image086.png" alt="img"></p>
<center>图 7‑13 一个共享的对象</center>

<p>​    当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中任一个后来进行写操作时，写时复制机制就会创建新页面。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image087.png" alt="img"></p>
<center>图 7‑14 一个私有的写时复制对象</center>

<h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>​    execve通过调用某个驻留在存储器中称为加载器的操作系统代码来运行hello，加载器将可执行目标文件中的代码和数据从磁盘中复制到内存中，然后通过跳转到程序的第一条指令或者入口点来运行该程序，当加载器运行时，会hello创建内存映像。加载并运行 hello 需要以下几个步骤：</p>
<ol>
<li><p>删除已存在的用户区域：删除当前进程虚拟地址的用户部分中的已存在的区域结构。</p>
</li>
<li><p>映射私有区域：为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 hello 文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。</p>
</li>
<li><p>映射共享区域：hello 程序与共享对象（或者目标）链接，libc.so是动态链库，那么这些对象都是接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。</p>
</li>
<li><p>设置程序计数器（PC）：execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。</p>
<p>内存映射示意图如图7-15所示</p>
</li>
</ol>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image088.png" alt="img"></p>
<center>图 7‑15 加载器映射用户地址空间的区域</center>



<h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p>​    同样先给出缺页故障的概念，缺页故障：CPU产生一个虚拟地址给MMU，MMU经过一系列步骤获得了相应的PTE，当PTE的有效位未设置时，说明虚拟地址对应的内容还没有缓存在内存中，这时MMU会触发缺页故障。</p>
<p>​    而缺页故障则会使正在运行的程序陷入内核，从而触发缺页中断处理程序。缺缺页处理程序主要会执行以下三个步骤：</p>
<ol>
<li><p>判断虚拟地址是否合法。缺页处理程序搜索区域结构的链表，把虚拟地和每个区域结构中的vm_start和vm_end做比较。如果指令不合法，缺页处理程序会触发一个段错误，从而终止这个进程。</p>
</li>
<li><p>判断内存访问是否合法。比如缺页是否由一条试图对只读页面进行写操作的指令造成的。如果访问不合法，缺页处理程序会触发一个保护异常，从而终止这个进程。</p>
</li>
<li><p>此刻，内核知道这个缺页是由合法的操作造成的。内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。处理程序返回时，CPU重新执行引起缺页的指令，这条指令将再次发送给MMU。这次，MMU能正常地进行地址翻译，不会再产生缺页中断了。</p>
</li>
</ol>
<p>Linux缺页处理如图7-16所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image089.png" alt="img"></p>
<center>图 7‑16 Linux缺页处理</center>



<h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>​    动态内存分配器维护着一个进程的虚拟内存区域，堆。假设堆为一个请求二进制零的区域，紧接在未初始化的数据区域（.bss）后开始，并向上生长（向更高的地址），对应每个进程，内核维护着一个brk，指向堆的顶部。</p>
<p>​    分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，块为已分配的或为空闲的。已分配的块显式地保留为供应用程序使用，已分配块保持已分配状态，直到它被释放，或被应用程序显式执行释放，或是内存分配器自身隐式执行释放。空闲块可用来分配，空闲块保持空闲，直到它被显式地被所应用分配。</p>
<p>​    分配器有两种基本风格，其都要求应用显式地分配块，不同之处在于哪个实体来负责释放已分配的块。</p>
<p>​    显式分配器，要求应用显式地释放任何已分配的块，如C语言的free函数。</p>
<p>​    隐式分配器，也称垃圾收集器，要求分配器检测一个已分配的块何时不再被程序所使用，然后释放这个块，代表有Java语言。</p>
<p>​    分配器的要求和目标：无法控制分配块的数量或大小；处理任意请求序列；立即响应请求；必须对齐块，使得它们可以保护任何类型的数据对象；只能操作或改变空闲块；一旦块被分配，就不允许修改或移动它了。</p>
<p>​    分配器的数据结构：</p>
<p>​    隐式空闲链表，在隐式空闲链表中，一个块是由一个字（4字节）的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有填充），且标记了这个块是已分配的还是空闲的，如图7-17所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image090.png" alt="img"></p>
<center>图 7‑17 隐式空闲链表的堆块格式</center>


<p>头部后面就是应用调用malloc时请求的有效载荷，有效载荷后面是一片不使用的填充块，其大小是任意的，满足对齐要求。</p>
<p>在设计完成了堆块的结构后，我们将一个对组织成为一个连续的已分配块和空闲块的序列，隐式空闲链表指的是并不直接对空闲块进行链接，而是将对内存空间中的所有块组织成一个大链表，其中头部和脚部中的信息隐式地起到连接的作用。如图7-18所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image091.png" alt="img"></p>
<center>图 7‑18 隐式空闲链表结构</center>

<p>​    放置策略主要有三种：</p>
<p>​    首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。</p>
<p>​    下一次适配：是从上一次查询结束的地方开始搜索空闲链表。</p>
<p>​    最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。</p>
<p>​    分割：放置时，可能分配块空间远大于我们实际需要空间大小，可以选择分割。</p>
<p>​    一旦分配器找到一个匹配的空闲块，就必须做一个另一个策略决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分，第一部分变为分配块，剩下的变成一个新的空闲块。</p>
<p>​    合并空闲块：在带边界标签的隐式空闲链表分配器下有4中情况：前面的块和后面的块都是已分配的，则就直接将当前块释放，不合并；前面的块和后面的块都是空闲的，那么将这三块合并；前面的块空闲后面的块已分配，将前一个块和当前块合并；前面的块已分配后面的块空闲，当前块和后面的块合并。</p>
<p>​    此外较为常用的是显式空间链表。显式空闲链表是将空闲块组织为某种形式的显式数据结构。堆被组织为一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继的指针。</p>
<p>​    块结构如下：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image092.png" alt="img"></p>
<center>图 7‑19 显式空间链表的堆块结构</center>

<p>链表结构如图7-20所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image093.png" alt="img"></p>
<center>图 7‑20 显式空间链表结构</center>

<p>​    使用双向链表而不是隐式空闲链表，使得首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。</p>
<p>​    一种方法是用后进先出的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在常数时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。</p>
<p>​    另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。</p>
<p>​    一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p>
<h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>​    本章主要先是介绍了逻辑地址、线性地址、虚拟地址、物理地址的概念，由此引入段式管理将逻辑地址翻译到线性地址，再到页式管理将虚拟地址翻译到物理地址，这一连串地址的转化及之间关系的论述，再到更为复杂的TLB及四级页表，三级cache，是对计算机存储系统的一个全面的回顾。此外，还探讨了一个程序在运行时，父进程与其共享的虚拟映射，讲到了写时复制以及缺页处理等等，明晰了进程与存储的关系。</p>
<p>（第7章 2分）</p>
<h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><p>​    设备的模型化：文件</p>
<p>​    一个linux文件就是一个m个字节的序列：B0, B1, … Bk, …, Bm-1</p>
<p>​    所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。</p>
<p>​    每个Linux文件都有一个类型(type)来表明它在系统中的角色:</p>
<ol>
<li><p>普通文件(regular file)包含任意数据。应用程序常常要区分文本文件(text file)和二进制文件(binary file)，文本文件是只含有ASCII或Unicode字符的普通文件;二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。</p>
</li>
<li><p>目录( directory)是包含一组链接(link)的文件，其中每个链接都将一个文件名(filename)映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目:“.”是到该目录自身的链接，以及“..”是到目录层次结构(见下文)中父目录( parent directory)的链接。你可以用mkdir命令创建一个目录，用ls查看其内容，用rmdir删除该目录。</p>
</li>
<li><p>套接字(socket)是用来与另一个进程进行跨网络通信的文件。</p>
</li>
</ol>
<p>​    其他文件类型包含命名通道(named pipe)、符号链接(symbolic link)，以及字符和块设备(character and block device)。 </p>
<p>​    设备管理：unix io接口</p>
<p>​    所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：Unix I/O</p>
<h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><p>​    Unix IO 接口，使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ol>
<li>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，即描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</li>
<li>Linux shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件中的常量可以代替显式的描述符值。</li>
<li>改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置 k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。</li>
<li>读写文件：一个读操作就是从文件复制n&gt;0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发EOF条件，应用程序能检测到这个条件。类似地，写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。</li>
<li>关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</li>
</ol>
<p>Unix I/O函数:</p>
<ol>
<li> 进程通过调用open函数打开一个存在的文件或者创建一个新文件。</li>
</ol>
<p>   函数声明：int open(char* filename,int flags,mode_t mode);</p>
<p>   open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件；mode参数指定了新文件的访问权限位。</p>
<p>   ​    flags参数如下：</p>
<p>   ​        O_RDONLY：只读</p>
<p>   ​        O_WDONLY：只写</p>
<p>   ​        O_RDWR：可读可写</p>
<p>   ​        O_CREAT：如果文件不存在，就创建它的一个截断的空文件</p>
<p>   ​        O_TRUNC：如果文件已经存在，就截断它</p>
<ol start="2">
<li><p>进程通过调用close函数关闭一个打开的文件，所需头文件： #include &lt;unistd.h&gt;。</p>
<p>函数声明：int close（int fd）;</p>
<p>fd是需要关闭的文件描述符，成功返回0，错误返回-1。关闭一个已关闭的描述符会出错。</p>
</li>
<li><p>应用程序通过分别调用read和write函数来执行输入和输出，所需头文件： #include &lt;unistd.h&gt;</p>
<p>函数声明如下：</p>
<p>ssize_t read(int fd,void *buf,size_t n);</p>
<p>ssize_t wirte(int fd,const void *buf,size_t n);</p>
<p>read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量；write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。</p>
</li>
</ol>
<h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p><a href="https://www.cnblogs.com/pianist/p/3315801.html">https://www.cnblogs.com/pianist/p/3315801.html</a></p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image094.png" alt="img"></p>
<center>图 8‑1printf函数的源代码</center>

<p>​    然后观察发现其调用了一个我们没见过的vsprintf函数，此外还有我们前面提到的write函数。先分析这个vsprintf函数。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image095.png" alt="img"></p>
<center>图 8‑2 vsprintf函数的源代码</center>

<p>​    仔细观察发现 vsprintf他对传进来的字符串，循环判断是否为‘%’，或‘x’,或‘s’，在循环中用参数替换占位符，最后返回的整数类型，返回的是要打印出来的字符串的长度，vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出。</p>
<p>  然后再到write函数的分析，write，写操作，把buf中的i个元素的值写到终端，引发系统调用syscall，显示格式化了的字符串，字符串的每个字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。</p>
<p>​    显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p>
<h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>​    同样先研究getchar函数的源代码：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image096.png" alt="img"></p>
<center>图 8‑3 getchar函数源代码</center>

<p>​    观察源代码发现，getchar调用了read函数，从标准输入缓冲区读取BUFSIZE个字符到静态字符串数组buf中，从缓冲区中返回一个字符，而当缓冲区字符个数为0时，则返回EOF，表示读到文件末尾。getchar函数的返回值是用户输入的字符的ASCII码。若用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar继续读取，则后续的getchar调用不会等待用户按键，而会直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键。</p>
<p>​    异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。</p>
<p>​    getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p>
<h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>​    这一章主要介绍了hello的IO管理，简述了文件的概念，以及unix I/O的接口和函数，同时分析了库函数printf和getchar函数的实现。以此为基础，了解我们的hello程序是如何在屏幕上输出的，同时其中调用getchar函数获取我们的输入等等，</p>
<p>（第8章1分)</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>​    用计算机系统的语言，逐条总结hello所经历的过程。</p>
<p>​    hello这个源程序不过短短几行而已，同时也并不是很难，但从其出生到死亡可谓是漫长而又丰富的一段历程，其中它遇到了许多“人”，为其服务，帮助他成长，下面一条条简要论述。</p>
<ol>
<li><p>编写源程序：在IDE中用c语言编写代码，形成hello.c文件（文本文件）。</p>
</li>
<li><p>预处理：hello.c经过预处理器cpp处理，处理开头的预处理指令，将库文件加到文件中，解析宏定义，生成一个hello.i文件，一个修改了的源文件（文本文件）。</p>
</li>
<li><p>编译：hello.i文件经过编译器（ccl）处理，将c语言高级语言翻译成汇编语言，生成hello.s汇编文件（文本文件）。</p>
</li>
<li><p>汇编：hello.s经过汇编器as处理，编译成机器代码，生成可重定位目标文件hello.o文件）。</p>
</li>
<li><p>链接：hello.o可重定位目标文件经链接器lld和动态链接库链接，实现重定位，生成可执行目标程序hello（二进制文件）</p>
</li>
<li><p>fork创建进程：在终端输入运行hello的指令，shell为hello程序fork子进程。</p>
</li>
<li><p>execve加载运行程序：子进程中调用execve函数，加载并运行hello程序，进入hello的程序入口点，hello开始运行。</p>
</li>
<li><p>进程管理：内核负责调度进程，进行上下文切换，在用户模式和内核模式之间切换。</p>
</li>
<li><p>内存管理：hello运行需要读取指令和数据。MMU、TLB、多级页表、cache、DRAM内存、动态内存分配器相互协作，共同完成内存的管理。Unix I/O使得程序与文件进行交互。</p>
</li>
<li><p>信号处理：程序运行过程中，会碰到各种异常和接收到各种信号比如来自键盘的输入，调用异常处理程序处理这些异常和信号。</p>
</li>
<li><p>终止：hello走到生命的最后，终止运行，shell回收hello进程及相关资源，内核删除为hello进程创建的所有数据结构，hello丰富的一生结束了。</p>
<p>对计算机系统的设计与实现的深切感悟:</p>
</li>
</ol>
<p>​    计算机系统这门课，可以说是每个程序员的必修课，要不然对于程序的理解永远是肤浅的。上完数据结构和算法这些课程后，我并没有太强烈的感觉成为了一个程序员，就是写代码、设计数据结构、设计算法来编写代码运行完成所要实现的需求就完了，说白了就是对高级语言语法的掌握和数据结构、算法的设计，其中重要的编写代码的逻辑。但是在上完计算机系统后，了解了一个编写的程序到底是怎么在计算机上运行的整个过程，其并不是我们简单地点一下运行就好了，其中发生了经历许多的变化，我感觉对程序地运行有了更深的理解、以及对更底层的理解。不再是前面的代码编写的软件部分，开始触碰到硬件，软硬结合， 威力无边。正如书所说，真正开始以一个程序员的角度看待程序，可谓是豁然开朗之感。</p>
<p>​    计算机系统的设计与实现经常让我发出惊叹，如此巧妙，又如此神奇，将计算机如此一个庞大、复杂的结构、体系层层相扣，从最基础的电路的有电没电，到高级语言程序的编写，而这样的体系在短短不到100年就发展起来，着手神奇。</p>
<p>​    总之，这门课受益匪浅，意犹未尽，感谢老师的辛苦教学。</p>
<p>​    个人博客地址：<a href="https://1nvisble.github.io/">https://1nvisble.github.io/</a></p>
<p>​    CSDN论文博客地址：<a href="https://blog.csdn.net/weixin_45961864/article/details/118282290">https://blog.csdn.net/weixin_45961864/article/details/118282290</a></p>
<h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>列出所有的中间产物的文件名，并予以说明起作用。</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>文件作用</th>
</tr>
</thead>
<tbody><tr>
<td>hello.c</td>
<td>保存hello源代码即源文件</td>
</tr>
<tr>
<td>hello.i</td>
<td>经过预处理的修改了的源文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>编译器编译hello.i生成的汇编文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>编译器编译hello.s生成的可重定位目标文件</td>
</tr>
<tr>
<td>hello.elf</td>
<td>hello.o文件的ELF格式文件，查看hello.o各节的信息</td>
</tr>
<tr>
<td>hello.txt</td>
<td>objdump反汇编hello.o生成的汇编文件与hello.s对比</td>
</tr>
<tr>
<td>hello</td>
<td>链接器重定位、链接生成的可执行目标文件</td>
</tr>
<tr>
<td>hello2.elf</td>
<td>hello文件的ELF格式文件，查看hello各节的信息</td>
</tr>
<tr>
<td>hello2.txt</td>
<td>objdump反汇编hello文件生成的汇编文件</td>
</tr>
</tbody></table>
<p>（附件0分，缺失-1分）</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><strong>为完成本次大作业你翻阅的书籍与网站等</strong></p>
<p>[1] 图中部分图片来源于老师上课PPT</p>
<p>[2] 图中部分图片来源于书籍《深入理解计算机系统》第三版。</p>
<p>[3] <a href="https://www.runoob.com/linux/linux-comm-pstree.html">https://www.runoob.com/linux/linux-comm-pstree.html</a></p>
<p>[4] <a href="https://www.runoob.com/cprogramming/c-function-vsprintf.html">https://www.runoob.com/cprogramming/c-function-vsprintf.html</a></p>
<p>[5] <a href="https://blog.csdn.net/yusiguyuan/article/details/9664887">https://blog.csdn.net/yusiguyuan/article/details/9664887</a></p>
<p>[6] <a href="https://blog.csdn.net/cherisegege/article/details/80708143">https://blog.csdn.net/cherisegege/article/details/80708143</a></p>
<p>[7]  <a href="https://blog.csdn.net/weixin_41571493/article/details/80692749">https://blog.csdn.net/weixin_41571493/article/details/80692749</a></p>
<p>（参考文献0分，缺失 -1分)</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>CSAPP</tag>
        <tag>计算机系统</tag>
      </tags>
  </entry>
</search>
