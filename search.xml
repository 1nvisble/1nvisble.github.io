<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP（面向切面编程）</title>
    <url>/2021/11/09/AOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="AOP（面向切面编程）"><a href="#AOP（面向切面编程）" class="headerlink" title="AOP（面向切面编程）"></a>AOP（面向切面编程）</h1><h2 id="AOP-含义"><a href="#AOP-含义" class="headerlink" title="AOP 含义"></a>AOP 含义</h2><p>面向切面编程：也叫做面向方法编程，通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。</p>
<p>将一些各接口都调用的相同方法抽象为接口，这个接口类似于切面；将方法注入到接口调用的某个地方，这个地方就为切点。</p>
<p>实现AOP的技术主要分为两类：一类是采用动态代理技术利用截取消息的方式，对消息进行装饰以取代原有对象行为的执行。另一类是采用静态织入的方式，引入特定语法创建切面，从而使编译器可以在编译期间织入相关的切面代码。（<a href="https://www.jianshu.com/p/f1770b9dce27%EF%BC%89">https://www.jianshu.com/p/f1770b9dce27）</a></p>
<h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><h3 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h3><p>横切关注点主要关注于：对哪些方法进行拦截，拦截后怎样处理，是替换还是包装，此外，还有执行的顺序，</p>
<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p><code>ASPECT</code>  切面是散落在系统各处<strong>通用</strong>的业务逻辑代码，如安全模块、日志模块、认证模块等。</p>
<p>切面可以说是一个较大的概念，较为笼统；更具体的就是切点<code>PointCut</code>和通知<code>Advice</code>，由名字就可知，切点存在于切面上，切面上存在切点，切点又有相应的通知<code>Advice</code>；</p>
<p>切面通常是一个类，可以定义切点<code>PointCut</code>和通知<code>Advice</code>。类是对物体特征的抽象，切面是对横切关注点的抽象。</p>
<p>切面是业务流程运行的某个特定步骤，是应用运行过程中的关注点，关注点通常会横切多个对象，因此也被称为横切关注点。</p>
<h3 id="程序执行点"><a href="#程序执行点" class="headerlink" title="程序执行点"></a>程序执行点</h3><p><code>JointPoint</code>连接点是程序执行过程中明确的点，感觉这个说法比较抽象，我个人理解为一些入口点（如方法调用，异常处理），典型的为方法的调用，对类成员的访问以及异常处理程序块的执行。连接点是程序在运行过程中能够插入切面的点，比如方法调用、异常抛出、字段修改等。</p>
<p>注意：一个<code>JointPoint</code>自身可以<strong>嵌套</strong>其他<code>JointPoint</code>，就比如说，一个方法中又调用了另一个方法。</p>
<h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><p><code>PointCut</code>切入点是带有通知的连接点，在程序中主要体现为编写切入点表达式。切入点是对连接点进行拦截的定义。切入点用于定义通知应该切入到哪些连接点上，不同的通知需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</p>
<p>切入点是可以插入增强处理的连接点，当某个连接点满足执行要求时，该连接点将被连接增强处理，该连接点也就变成了切入点。</p>
<p>切入点是拦截的方法，连接点<code>JointPoint</code>拦截后将变成切入点。</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p><code>Advice</code>通知是AOP在特定切入点上执行的增强处理，是拦截到连接点之后要执行的代码，通知可以分为前置通知<code>Before</code>、后置通知<code>AfterReturning</code>、异常通知<code>AfterThrowing</code>、最终通知<code>After</code>、环绕通知<code>Around</code>五类。</p>
<ol>
<li><p> <code>before advice</code>, 在<code>join point</code>前被执行的<code> advice</code>. 虽然<code>before advice</code>是在<code>join point</code>前被执行, 但是它并不能够阻止<code> join point</code> 的执行, 除非发生了异常(即我们在 <code>before advice </code>代码中, 不能人为地决定是否继续执行<code> join point</code> 中的代码)</p>
</li>
<li><p>after return advice<code>, 在一个</code> join point <code>正常返回后执行的</code> advice`</p>
</li>
<li><p><code>after throwing advice</code>, 当一个<code> join point</code> 抛出异常后执行的 <code>advice</code></p>
</li>
<li><p><code>after(final) advice</code>, 无论一个<code>join point</code>是正常退出还是发生了异常, 都会被执行的 advice.</p>
</li>
<li><p><code>around advice</code>, 在<code> join poin</code>t 前和<code> joint point</code> 退出后都执行的 <code>advice</code>. 这个是最常用的<code> advice</code>.</p>
</li>
<li><p><code>introduction</code>，<code>introduction</code>可以为原有的对象增加新的属性和方法。</p>
</li>
</ol>
<h3 id="织入"><a href="#织入" class="headerlink" title="织入"></a>织入</h3><p><code>Weaving</code> 织入通过切入点切入，将切面应用到目标对象并导致代理对象创建的过程。将切面应用到目标对象从而创建一个新的代理对象的过程，这个过程可以发生在编译器、类转载期、运行期，不同的发生点有着不同的前提条件。如果发生在编译器就需要有一个支持这种AOP实现的特殊编译器，发生在类转载期就需要有一个支持AOP实现的特殊类转载其，发生在运行期则可以直接通过反射机制与动态代理机制来动态实现。</p>
<h3 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h3><p><code>Proxy</code>代理对象是AOP创建的对象，包含通知，代理是目标对象的加强。 代理是将通知应用到目标对象之后被动态创建的对象，可以简单理解代理对象的功能等同于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。</p>
<h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p><code>Target</code>目标对象是指代理的目标对象，是指要织入的对象模块。目标对象是那些即将切入切面的对象，也就是被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码，所有的共有功能等待AOP容器的切入。</p>
<p>目标对象是AOP进行增强处理的对象，也被称为增强的对象。如果AOP是通过运行时代理来实现的，那么这个对象将是一个被代理的对象。</p>
<p>AOP是典型的代理模式的体现，代理模式的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、将消息转发给委托类、事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象相关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象方法来提供特定的服务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在AOP中切面就是与业务逻辑独立，但又垂直存在于业务逻辑的代码结构中的通用功能组合；切面与业务逻辑相交的点就是切点；连接点就是把业务逻辑离散化后的关键节点；切点属于连接点，是连接点的子集；Advice（增强）就是切面在切点上要执行的功能增加的具体操作；在切点上可以把要完成增强操作的目标对象（Target）连接到切面里，这个连接的方式就叫织入</p>
<p><a href="https://www.jianshu.com/p/281dcde6974d">从代理机制到Spring AOP，这篇给你安排得明明白白的 - 简书 (jianshu.com)</a></p>
<p><a href="https://blog.csdn.net/qq_41701956/article/details/84427891">AOP如何实现及实现原理_Java笔记-CSDN博客_aop原理</a></p>
<p><a href="https://blog.csdn.net/q982151756/article/details/80513340">细说Spring——AOP详解（AOP概览）_啦啦啦的博客-CSDN博客_aop</a></p>
]]></content>
      <categories>
        <category>面向切面编程</category>
      </categories>
      <tags>
        <tag>面向切面编程</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode142-环形链表Ⅱ</title>
    <url>/2022/04/17/Leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    <content><![CDATA[<h1 id="环形链表Ⅱ"><a href="#环形链表Ⅱ" class="headerlink" title="环形链表Ⅱ"></a>环形链表Ⅱ</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">Leetcode142</a></p>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>定义一个快指针和一个慢指针，快指针一步走二，慢指针一步走一，其必定会在环内相遇。<br>解释：</p>
<ul>
<li><strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇。</strong></li>
<li><strong>fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。</li>
</ul>
<p>寻找环入口：</p>
<p><strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii">代码随想录</a></p>
]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中equals方法和hashCode方法</title>
    <url>/2021/06/15/Java%E4%B8%ADequals%E6%96%B9%E6%B3%95%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>软件构造课上，之前介绍了ADT，讲了RI、AF，AF，及抽象函数解释了该类型是如何将内部表示映射为使用者理解的抽象数据的。那如何判断这些ADT的相等性，这就涉及到了java中很重要的一个知识点，equals方法和hashCode方法。</p>
<h2 id="VS-equals"><a href="#VS-equals" class="headerlink" title="== VS equals()"></a>== VS equals()</h2><p>我们在C中常使用==操作来判断相等。而在Java中，不仅提供了==来判断相等</p>
<p>，还提供了equals()方法，其主要用于比较ADT的相等。</p>
<h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p>==这个相等判断比较的是两个比较对象的索引的相等，或者说是引用相等。如果两个索引指向同一块存储区域，那它们就是==的，也就是相等的。在snophot图中，<code>==</code>就意味着两个比较对象的箭头指向同一个对象或值。</p>
<h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><p>equals方法操作比较的是两个对象（object）的内容，或者说，比较的是对象值相等。每当我们定义一个ADT时，我们需要判断，对于这个ADT来说对象值相等是如何定义的，或者说如何实现equals方法。</p>
<p>假设存在一个Person的ADT，其成员属性有两个，一个为name，一个为number。</p>
<p>那我如和判断Person这个ADT实例的两个对象是否相等呢？是判断其name和number相等就算相等，还是只要判断name就算相等，可能一个人有多个手机号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这时候我们要想清楚如何实现equals方法。</p>
<p>我们先看java给出的equal方法的定义，其是在Object类中就定义的，我们又知道Object类是所有类的父类或基类，如果不在子类中重写equals()方法，那么默认继承使用的就是Object类的equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;        </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span> == that;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>equals() 在Object类中的实现方法就是测试指向/索引相等。对于<strong>不可变类型的对象</strong>来说，这很容易在调用equals方法时出现bug。所以你需要**重写(override) **equals() 方法，重写为你所定义的两个对象的相等的实现。</p>
<p>举上课的例子，这是一个不可变类型的ADT：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span> </span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Duration that)</span> </span>&#123;        </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getLength() == that.getLength();         </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可能想当然认为我们比较的是对于这一个ADT，两个对象值的相等，那么参数类型也就为这个类，这里要特别<strong>注意</strong>:这里并不是<strong>重写</strong>了Object类的方法，而是<strong>重载</strong>了equals方法，因为参数类型的不同，其构成的是重载，意思是说，这时Duration中有两个 equals()方法：一个是从 Object隐式继承下来的equals(Object)，还有一个就是我们写的 equals(Duration)。然后编译器，会在编译时而不是运行时，根据传入的参数类型，选择调用哪一个equals方法。</p>
<p>那到底该如何重写equals方法呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that <span class="keyword">instanceof</span> Duration &amp;&amp; 			<span class="keyword">this</span>.sameValue((Duration)that);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sameValue</span><span class="params">(Duration that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() == that.getLength();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其首先测试了传入的that对象是 Duration，然后调用sameValue()去判断它们的值是否相等。表达式 (Duration)that 是进行了一个类型转换操作，它告诉编译器that指向的是一个 Duration对象。</p>
<p>此外，这里的instance操作符进行了一个动态检查，测试一个实例是否属于特定的类型。但老师又提到，在面向对象编程中使用 instanceof是一个不好的选择。在本门课程中——在很多Java编程中也是这样——<strong>除了实现相等操作，instanceof不能被使用。</strong>这也包括其他在运行时确定对象类型的操作，还有getClass方法。</p>
<p>然后我们再说说hashCode方法：</p>
<h2 id="hashCode-方法："><a href="#hashCode-方法：" class="headerlink" title="hashCode()方法："></a>hashCode()方法：</h2><p>java规定了一个对象相等的契约：</p>
<p>如果两个对象使用 equals操作后结果为真，那么它们各自的hashCode操作的结果也应该相同。</p>
<p>那hashCode又是什么呢？这就需要对哈希表的工作原理有一定的了解。听到hash或哈希，我们会联系到学习数据结构时的散列，在Java中，两个常见的聚合类型 HashSet和 HashMap 就用到了哈希表的数据结构，并且依赖hashCode保存集合中的对象以及产生合适的键（key）。</p>
<p>一个哈希表表示的是一种映射：从键值映射到值的抽象数据类型。哈希表提供了常数级别的查找，查找速度比其他唱常规的链表都要快。键不一定是有序的，也不一定有什么特别的属性，除了类型必须提供 equals 和 hashCode两个方法。</p>
<blockquote>
<p>哈希表是怎么工作的呢？它包含了一个初始化的数组，其大小是我们设计好的。当一个键值对准备插入时，我们通过hashcode计算这个键，产生一个索引，它在我们数组大小的范围内（例如取模运算）。最后我们将值插入到数组索引对应的位置。 哈希表的一个基本不变量就是键必须在hashcode规定的范围内。</p>
<p>Hashcode最好被设计为键计算后的索引应该平滑、均匀的分布在所有范围内。但是偶尔冲突也会发生，例如两个键计算出了同样的索引。因此哈希表通常存储的是一个键值对的列表而非一个单个的值，这通常被称为哈希桶（hash  bucket）。而在Java中，键值对就是一个有着两个域的对象。当插入时，你只要像计算出的索引位置插入一个键值对。当查找时，你先根据键哈希出对应的索引，然后在索引对应的位置找到键值对列表，最后在这个列表中查找你的键。</p>
</blockquote>
<p>Object默认的 hashCode()`实现和默认的 equals()保持一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span> == that; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">/* the memory address of this */</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于索引a和b，如果 a == b，那么a和b的存储地址也就相同，hashCode()的结果也就相同，那么就满足了相等的契约。</p>
<p>但对于前面提到的 Duration这个不可变的ADT，因为我们还没有覆盖默认的 hashCode() ，其实际上打破了对象契约。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration d1 = <span class="keyword">new</span> Duration(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Duration d2 = <span class="keyword">new</span> Duration(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">d1.equals(d2) → <span class="keyword">true</span></span><br><span class="line">d1.hashCode() → <span class="number">2392</span></span><br><span class="line">d2.hashCode() → <span class="number">4823</span></span><br></pre></td></tr></table></figure>

<p>那么该怎么解决这个问题呢？</p>
<ol>
<li>简单粗暴的将所有对象的hashCode值都改为一样的。但会严重性能严重下降，这样将每一个值对都保存到相同的位置，每次查找会遍历所有对象。</li>
<li>另一个方法是计算对象每一个内容的hashcode然后对它们进行一系列算术运算，最终返回一个综合hashcode。</li>
</ol>
<p>还是我们上面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) getLength();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> equals方法和hashCode方法都是Java比较特殊的存在，在构造ADT时，要主要二者方法的重写，来判断等价性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】软件构造PPT</p>
<p>【2】 <a href="https://www.cnblogs.com/liqiuhao/p/8810465.html">https://www.cnblogs.com/liqiuhao/p/8810465.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello的自白.</title>
    <url>/2021/05/04/Hello%E7%9A%84%E8%87%AA%E7%99%BD/</url>
    <content><![CDATA[<h1 id="Hello的自白"><a href="#Hello的自白" class="headerlink" title="Hello的自白"></a>Hello的自白</h1><img src="/2021/05/04/Hello%E7%9A%84%E8%87%AA%E7%99%BD/Hello1.jpg" class title="This is a Hello1s image">



<blockquote>
<p>俺是Hello，额是每一个程序猿🐵的初恋(😊羞羞……)，</p>
<p>却在短短几分钟后惨遭每个菜鸟的无情抛弃(😭呜呜….)，他们很快喜欢上sum、sort、matrix、PR、AI、IOT、BD、MIS……，从不回头😞。</p>
</blockquote>
<p><strong>只有我自己知道，我的出身有多么高贵，我的一生多么坎坷! ╰（‵□′）╯</strong></p>
<p><strong>多年以后，那些真正懂我的大佬(也是曾经的<del>菜鸟一枚</del>)，才恍然感悟我的伟大 !</strong></p>
<hr>
<blockquote>
<p>······<em>想当年</em>：</p>
<p><strong>俺</strong>才是第一个玩P2P的:<em><strong><font color="#FF0000">From Program to Process</font></strong></em></p>
<p>懵懵懂懂的你笨笨磕磕地将我一字一键敲进电脑存成<font color="#FF0000">hello.c(Program)</font>，无意识中将我<strong>预处理、编译、汇编、链接</strong>，历经<strong>艰辛-神秘-高贵-欣喜</strong>，我—<font color="#FF0000"><em><strong>Hello</strong></em></font>一个完美的生命诞生了 <strong>o((&gt;ω&lt; ))o</strong>。</p>
<blockquote>
<h6 id="你造吗？"><a href="#你造吗？" class="headerlink" title="你造吗？"></a>你造吗？</h6><ul>
<li><p>在<strong>壳(Bash)<strong>里，</strong><font color="#000080">伟大的OS(进程管理)</font><strong>为我</strong><font color="#000080">fork(Process) </font><strong>，为我</strong><font color="#000080">execve</font></strong>, 为我<font color="#000080"><strong>mmap</strong></font>，</p>
<p>分我时间片，让我得以在<font color="#000080"><strong>Hardware(CPU/RAM/IO)</strong></font>上驰骋<font color="#000080"><strong>（取指译码执行、流水线等）</strong></font>  </p>
</li>
</ul>
</blockquote>
<blockquote>
<h6 id="你造吗？-1"><a href="#你造吗？-1" class="headerlink" title="你造吗？"></a>你造吗？</h6><ul>
<li><strong>OS(存储管理)与MMU</strong>为VA到PA操碎了心:<strong>TLB、4级页表、3级Cache，Pagefile</strong>等等各显神通为我加速；<strong>IO管理与信号处理</strong>使尽了浑身解数，软硬结合，才使我能在键盘、主板、显卡、屏幕间游刃有余，虽说我在台上的表演只是一瞬间😶、演技看起来很Low、效果很苍白 （︶^︶）。</li>
</ul>
</blockquote>
<p><strong>感谢OS!感谢Bash!在我完美谢幕后为我收尸</strong>。我赤条条来去无牵挂!😌</p>
</blockquote>
<hr>
<p><strong>我朝CS(计算机系统-</strong><u><strong>Editor+Cpp+Compiler+AS+LD+OS+CPU/RAM/IO等</strong></u>)<strong>挥一挥手，不带走一片云彩!</strong> 😛    </p>
<p><strong>想想俺也是<font color="#FF0000"> <em><strong>020:From Zero-0 to Zero-0</strong></em></font>.</strong>  <strong>(^人^)</strong>   </p>
<p><strong>历史长河中一个个<del>菜鸟</del>与我擦肩而过，只有CS知道我的生、我的死，我的坎坷，“只有CS知道……我曾经……来…………过……”</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2021/05/04/Hello%E7%9A%84%E8%87%AA%E7%99%BD/Hello2.jpg" class title="This is a Hello2 image">



<hr>
<p><strong>《Hello的自白》为哈工大CSAPP老师史老师原创的大作业——“程序人生”的导读，本人只是觉其有趣，哪一个程序猿与代码的初见不是“Hello world”呢，从而尝试用markdown写成博客发表，进行二次加工搬运，如有侵权，立即删除！</strong></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode203</title>
    <url>/2022/04/12/Leetcode203/</url>
    <content><![CDATA[<h2 id="链表移除元素"><a href="#链表移除元素" class="headerlink" title="链表移除元素"></a>链表移除元素</h2><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements">Leetcode203</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>示例2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [], val &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [7,7,7,7], val &#x3D; 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="普通做法"><a href="#普通做法" class="headerlink" title="普通做法"></a>普通做法</h4><p>普通做法就是将删除节点为头节点和非头节点分开处理的方法。</p>
<ul>
<li>删除节点为头节点：头节点改为下一个节点，循环删除，直至头节点不为删除节点</li>
<li>删除节点为非头节点：遍历节点即可，找到删除的节点，将其上一个节点的尾部指向该删除节点的下一个节点，因为是单链表，需要记录上一节点，也可以用<code>prev-&gt;next</code>为当前节点。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意这里不是if</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟头节点法"><a href="#虚拟头节点法" class="headerlink" title="虚拟头节点法"></a>虚拟头节点法</h4><p>创建一个新的不会被删除的头节点，其next指向head，这样一来所有节点都为非空节点，直接按非空节点删除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* virtulNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>,head); <span class="comment">//虚拟节点</span></span><br><span class="line">        ListNode* prev = virtulNode; </span><br><span class="line">        <span class="keyword">while</span>(prev-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                ListNode* temp = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtulNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><p>递归删除节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next,val);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val)&#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单来说，就是，一直递归调用到最后一个元素，从最后一个元素开始删除，如果传进来的节点是一个要被删除的节点，则将其next返回给上一个节点的next，否则，就返回本节点给上一个节点的next，保持不变。</p>
]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式（Proxy）理解</title>
    <url>/2021/06/27/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>老师上课讲到了一些设计模式，但是由于课程较赶，时间较紧，吃不太透，于是自己课下再学习一些，加深理解，同时在编程中多多用到。</p>
<h2 id="代理模式简述"><a href="#代理模式简述" class="headerlink" title="代理模式简述"></a>代理模式简述</h2><p>首先，代理模式是一种<strong>设计模式</strong>。</p>
<p>先给出代理模式的<strong>概念</strong>：代理模式是指通过<strong>代理对象</strong>访问目标对象，而不是直接访问<strong>目标对象</strong>，通过字面理解即可，要通过一个代理人或者说中间人来访问我们想要访问的对象。举例就像房屋中介，买房人不想自己去一个找房主询问其是否卖房，而卖房人也不想麻烦去一个个找买房人，中介就承担起这个功能，买房人（用户）通过中介（代理对象）获知在售的其意向房产的信息（如房价、面积、位置等的）。</p>
<p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>何时使用</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>关键代码：</strong>实现与被代理类组合。</p>
<p>那么为什么要有代理模式呢？其好处是可以在目标对象实现的基础上，增强额外的功能操作，即拓展目标对象的功能，如添加权限进行访问控制和审计等功能，其中举添加权限这个功能说明，通过代理对象判断访问目标对象的用户是否拥有访问的权限，没有则禁止访问，实现对信息的一个保护。</p>
<p>同时，代理模式也是遵循了设计思想中类的单一性原则，就是每个类功能应该单一，即专一，就是说什么人干什么事，一个人尽可能负责一个工作，同时也是去尽量实现低耦合。</p>
<img src="/2021/06/27/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/Proxy.png" class title="This is a Proxys image">

<p>代理模式要着重理解代理对象和目标对象的概念，代理对象是对目标对象的扩展,并会调用目标对象。就像房屋中介调用目标对象（卖房人）获取其房产信息，但不仅限于房产信息，房屋中介还会审计其掌握的房产资源，而后挑选合适的房产给买房人。</p>
<p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理</p>
<h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><p>代理模式主要分为三类：</p>
<p> 1.静态代理；</p>
<p> 2.动态代理；</p>
<p> 3.Cglib代理。</p>
<p>下面分别论述。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。需要注意的是，代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</p>
<p>我们举个买房这个例子来说明：</p>
<p>首先要先创建一个服务类的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HouseService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后要实现这个服务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseServiceImpl</span> <span class="keyword">implements</span> <span class="title">HouseService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;我要买房&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>有了服务后，我们就需要一个中间类也就是代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseServiceProxy</span> <span class="keyword">implements</span> <span class="title">HouseService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HouseService houseService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseServiceProxy</span><span class="params">(<span class="keyword">final</span> HouseService houseService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseService = houseService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攒钱买房&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;挑房看房&quot;</span>);</span><br><span class="line">        houseService.buyHosue();</span><br><span class="line">        System.out.println(<span class="string">&quot;买房装修&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入住&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优点：在不修改目标对象的功能前提下,可以实现对目标对象功能的扩展。</p>
<p>缺点：</p>
<ol>
<li><p>代理对象必须提前写出（在编译期就已经知道了代理对象），如果接口层发生了变化，代理对象的代码也要进行维护。</p>
</li>
<li><p>因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多，导致一旦接口增加方法,目标对象与代理对象都要维护。</p>
</li>
</ol>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>　在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable 		</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攒钱买房&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;挑房看房&quot;</span>);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;买房装修&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入住&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态代理的特点:</strong></p>
<p>1.代理对象,不需要实现接口；<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)；<br>3.动态代理也叫做: JDK代理,接口代理。</p>
<p><strong>JDK中生成代理对象的API</strong><br>代理类所在包:java.lang.reflect.Proxy</p>
<p><strong>总结</strong>：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理。</p>
<p>优点：JDK动态代理解决了静态代理中需要创建多个代理类的问题。</p>
<p>缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，假如没有，则可以使用Cglib代理<strong>。</strong></p>
<h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p>
<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。</p>
<p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)。</p>
<p>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>步骤：创建Cglib代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攒钱买房&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;挑房看房&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;买房装修&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入住&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Cglib子类代理实现方法:</p>
<ol>
<li>需要引入cglib的jar文件,但是因为pring的核心包中已经包括了Cglib功能,所以可以直接引入<code>pring-core-3.2.5.jar</code>。</li>
<li>引入功能包后,就可以在内存中动态构建子类</li>
</ol>
<p>以上就是代理模式的内容，仅个人拙见，若有错误，恳请批评指正。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>【1】<a href="https://www.runoob.com/design-pattern/proxy-pattern.html">https://www.runoob.com/design-pattern/proxy-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode1——两数之和</title>
    <url>/2022/04/21/Leetcode1%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode206-反转链表</title>
    <url>/2022/04/14/Leetcode206/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">Leetcode209</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>直接以当前头节点来创建一个新链表，从<code>head-&gt;next</code>遍历，头插法插入新链表中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">            newNode-&gt;next = newHead;</span><br><span class="line">            newHead = newNode;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>前面的头插法创建了一个新链表，内存开销较大，那能不能在原有基础上直接将<code>next</code>改变来逆转呢？答案是可以的，需要两个指针<code>prev</code>和<code>cur</code>，<code>prev</code>指向前一节点，<code>cur</code>指向后一节点，把后一节点<code>cur</code>的<code>next</code>指向前一节点<code>prev</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* prev =<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = prev;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<pre><code>### 递归法
</code></pre>
<p>原理同双指针法，只是用递归的方法做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">nullptr</span>,head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">代码随想录</a></p>
]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode209</title>
    <url>/2022/04/08/Leetcode209/</url>
    <content><![CDATA[<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">Leetcode209</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组：<br> [nums_l, nums_l+1 …, nums_r-1, nums_r] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：target = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：target = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：target = <span class="number">11</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>首先利用vector的求和函数，判断所有元素之和是否小于target，是直接返回0，否则进入else。<br>else部分则是利用两层循环，求出所有该数组的子序列，对每个子序列求和，每次计算符合条件的子序列长度，若比已求出最小子序列长度小，则更新子序列长度。从下标0开始求0-1，0-2，…，0-（len-1）的子序列，当已求得0-r的满足条件的序列时，可以直接跳出内循环，不再求0-r+1的序列，无意义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>)&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp =  <span class="number">0</span>;  <span class="comment">//当前子序列长度</span></span><br><span class="line">            <span class="keyword">int</span> sums = <span class="number">0</span>;    <span class="comment">//子序列和</span></span><br><span class="line">            <span class="keyword">int</span> len = INT32_MAX; <span class="comment">//最终子序列长度       </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                sums = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    sums += nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sums&gt;=target)&#123;</span><br><span class="line">                        temp = j - i +<span class="number">1</span>;</span><br><span class="line">                        len = len &lt; temp ? len : temp;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h4><p>该方法主要也是双指针法，开始时都指向0，头指针不移动，尾指针移动，直到尾指针头指针指向所形成的区间内的数之和满足要求时，区间收缩，减去头指针所指向的数，头指针移动，头指针移动的条件时：保证区间内的数之和满足条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 滑动窗口起始位置</span></span><br><span class="line">        <span class="keyword">int</span> subLength = <span class="number">0</span>; <span class="comment">// 滑动窗口的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                subLength = (j - i + <span class="number">1</span>); <span class="comment">// 取子序列的长度</span></span><br><span class="line">                result = result &lt; subLength ? result : subLength;</span><br><span class="line">                sum -= nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    时间复杂度：$O(n)$ 空间复杂度：$O(1)$</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">代码随想录</a></p>
]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode704</title>
    <url>/2022/04/05/Leetcode704/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>​    <a href="https://leetcode-cn.com/problems/binary-search/submissions/">力扣二分查找题目</a></p>
<p>​    二分查找这个算法简单，但却会屡屡出错，问题就出在边界上。针对边界的问题，有两种写法，一种是闭区间，一种是开区间。<br>​    此外，需注意的是，使用二分查找的条件：<strong>已排序的数组</strong>，无重复元素。</p>
<h3 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h3><ul>
<li>搜索区间：[left , right];</li>
<li>left、right初始化：left = 0; right = array.size -1;（也就说最右边数组元素的下标，例长度为7的数组，最右边数组下标为6）;</li>
<li>终止条件：left &lt;= right;</li>
<li>left改变：left = middle + 1;</li>
<li>right；right = middle-1；</li>
<li>middle = left + ((right - left) / 2);（防止溢出 等同于(left + right)/2）;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h3><ul>
<li>搜索区间；[left, right);</li>
<li>left、right初始化：left = 0; right = array.size ;（数组的长度，例长度为7的数组，以该索引访问数组则会越界，故上面的搜素区间为左开右闭）。</li>
<li>终止条件：left &lt; right;</li>
<li>left改变：left = middle + 1;</li>
<li>right；right = middle；</li>
<li>middle = left + ((right - left) / 2);（防止溢出 等同于(left + right)/2）;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h3><p><a href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">搜索插入位置</a><br><a href="https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html">在排序数组中查找元素的第一个和最后一个位置</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">代码随想录</a></p>
]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode59</title>
    <url>/2022/04/09/Leetcode59/</url>
    <content><![CDATA[<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/submissions/">Leetcode59</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 $ n^2 $ 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><img src="/2022/04/09/Leetcode59/sample.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>螺旋矩阵，仔细观察其规律，就可以发现，变化规律为画4条边：</p>
<ol>
<li>行不变，列从左到右，</li>
<li>列不变，行从上到下</li>
<li>行不变，列从左到右</li>
<li>列不变，行从下到上</li>
</ol>
<p>尤其注意边界条件，不能填充已填充过的位置，每一圈都要画4条边，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p>
<p>整理一下思路：</p>
<ul>
<li>先确定循环次数，这里的循环，指绕几个大圈，一个圈画4条边</li>
<li>求得矩阵中间位置，可能会在n为奇数使用到</li>
<li>记录每一次循环开始位置，即绕完一圈后的开始位置</li>
<li>每次绕完一圈，下一次绕圈，每条边长变短</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(n,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span> starx = <span class="number">0</span>, stary=<span class="number">0</span>; <span class="comment">//开始位置</span></span><br><span class="line">        <span class="keyword">int</span> loop = n/<span class="number">2</span>;  <span class="comment">//循环次数</span></span><br><span class="line">        <span class="keyword">int</span> mid = n/<span class="number">2</span>; <span class="comment">//中间位置</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// n</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>; <span class="comment">//for步长</span></span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">while</span>(loop--)&#123;</span><br><span class="line">            i = starx;</span><br><span class="line">            j = stary;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j=stary;j&lt;starx+n-offset;j++)&#123;  <span class="comment">//从左到右</span></span><br><span class="line">                res[starx][j] = count;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=starx;i&lt;stary+n-offset;i++)&#123; <span class="comment">//从下到上</span></span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;stary;j--)&#123;  <span class="comment">//从右到左</span></span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;starx;i--)&#123; <span class="comment">//从下到上</span></span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            starx++; <span class="comment">//改变起始位置</span></span><br><span class="line">            stary++;</span><br><span class="line">            offset+=<span class="number">2</span>; <span class="comment">//步长减小2，因为左边右边、上边下边各1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>) res[mid][mid] = n*n; <span class="comment">//奇数时，填充中间位置</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>
]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode707</title>
    <url>/2022/04/13/Leetcode707/</url>
    <content><![CDATA[<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/">Leetcode707</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code> 和<code>next</code>。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性<code>prev</code>以指示链表中的上一个节点。假设链表中的所有节点都是<code> 0-index</code> 的。</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkedNode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="keyword">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size<span class="number">-1</span>)  || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= _size || index &lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next= cur-&gt;next-&gt;next;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode977</title>
    <url>/2022/04/07/Leetcode977/</url>
    <content><![CDATA[<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/">Leetcode977</a></p>
<p>​    给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p>示例 1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">-4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br><span class="line">解释：平方后，数组变为 [<span class="number">16</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">100</span>]</span><br><span class="line">排序后，数组变为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">-7</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">11</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">49</span>,<span class="number">121</span>]</span><br></pre></td></tr></table></figure>

<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>​    最简单的当然就是暴力法，直接平方，再排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>​    已知数组是有序的，非递减排序，只不过负数平方之后，可能比一些数要大得多，例如$ (-4)^2 &gt; 1^2$ ，从而影响排列顺序。<br>​    <strong>重点：</strong>数组平方的<strong>最大值就在数组的两端</strong>，不是<strong>最左边就是最右边</strong>，不可能是中间。<br>​    因此，这里考虑使用一个双指针，一个指向数组第一项——i，一个指向数组最后一项——j。<br>​    定义一个新数组result，和nums数组一样的大小，让<strong>k指向result数组终止位置</strong>。<br>​    当前面比后面大时，直接将其赋给新数组的最后一项，i++；<br>​    当后面比前面大时，直接将其赋给新数组的最后一项，j–；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;  <span class="comment">//左边指针</span></span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">//右边指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> k = right; <span class="comment">//指向result数组最后一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] * nums[left] &lt; nums[right]*nums[right])&#123;</span><br><span class="line">                result[k--] = nums[right]*nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result[k--] = nums[left]*nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>乐扣刷题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>可变数据类型和不可变数据类型以及Snaphot图</title>
    <url>/2021/05/20/Snaphot/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在上软件构造这门课时，在讲数据类型时引入了可变数据类型和不可变数据类型，这是以前未接触过的概念，以前自学Java时，仅有基本数据类型，和引用数据类型这两种概念；此外，老师还引入了Snaphot digrams，其用于描述程序运行时的内部状态，较为实用，今天“趁热打铁”，写博客记录一下。</p>
<p>先回顾一下Java的基本数据类型和引用数据类型。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型主要是我们最熟悉的几个变量类型：</p>
<p>byte、short、int、long,float,double,bool,char；</p>
<p>基本数据类型运算的规则：（不包含布尔类型）</p>
<ol>
<li><p>自动类型提升：当容量小的数据类型的变量与大的数据类型做运算时，结果自动提升为容量大的数据类型。 </p>
<p>byte、char、short（这三者做运算均转为int）-&gt;int-&gt;long-&gt;-&gt;float-&gt;double。</p>
<p>容量大小指的是表示属的范围的大和小，比如float的容量大于long</p>
</li>
<li><p>强制类型转换：需要使用强转符，可能导致精度损失 </p>
</li>
<li><p>整数型定义时，常量存储的类型为int型，若定义变量类型为long，或容量大于int型，且常量超过int型可表示的最大范围数，编译不通过，需要加l</p>
</li>
<li><p>浮点型定义时，常量存储的类型为double类型，若定义变量类型为float，double类型向float转换，报错，常量后面需加f</p>
</li>
</ol>
<p>整型常量：默认类型为int型； 浮点型常量：默认类型为double型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> a = <span class="number">2147483647</span>;        <span class="comment">//编译可通过</span></span><br><span class="line">   		<span class="keyword">long</span> a = <span class="number">2147483648</span>;        <span class="comment">//编译不通过，显示数过大</span></span><br><span class="line">   	 	<span class="keyword">long</span> a = <span class="number">2147483648l</span>;      <span class="comment">//编译可通过</span></span><br><span class="line">    	<span class="keyword">float</span> f1 = <span class="number">12.3</span>;   <span class="comment">//编译不通过，因为12.3默认为double型，需要12.3加f</span></span><br><span class="line">   		<span class="keyword">byte</span> b = <span class="number">12</span>;   <span class="comment">//编译可通过</span></span><br><span class="line">   	    <span class="keyword">byte</span> b = b + <span class="number">1</span>;   <span class="comment">//编译不通过，因为1被认为是int型</span></span><br><span class="line">   	    <span class="keyword">float</span> f1 = b + <span class="number">12.3</span>;  <span class="comment">//编译不通过，因为12.3被认为是doble型</span></span><br><span class="line">	System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>引用数据类型主要有：类（字符串）、接口、数组、枚举类等。其被称为引用数据类型的原因是：创建变量并赋值后，且不是直接存储的值，而是存储的是堆中创建值的地址，通过地址寻值，有点类似于C语言的指针。</p>
<p>举例String：</p>
<p>String不是基本数据类型，而是为引用数据类型,字符串。</p>
<p>String类型变量的使用: </p>
<p>String可以和8种基本数据类型做运算，只能做连接，用string类接收，运算结果仍然是String 。</p>
<p>二者区别对比：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">基本数据类型</th>
<th align="center">引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员</td>
<td align="center">byte、short、int、long,float,double,bool,char</td>
<td align="center">类、接口、数组、枚举类</td>
</tr>
<tr>
<td align="center">分配内存区域</td>
<td align="center">在栈中分配内存</td>
<td align="center">在堆中分配内存</td>
</tr>
<tr>
<td align="center">是否与其他值可区分</td>
<td align="center">只有值，没有ID，与其他值无法区分</td>
<td align="center">既有ID，也有值</td>
</tr>
<tr>
<td align="center">可变/不可变数据类型</td>
<td align="center">全都为不可变数据类型</td>
<td align="center">有些是可变的，有些是不可变的</td>
</tr>
<tr>
<td align="center">赋值</td>
<td align="center">传递的是值</td>
<td align="center">传递的是地址</td>
</tr>
</tbody></table>
<p>下面再谈谈上课所讲的可变和不可变数据类型。</p>
<h2 id="不可变数据类型-Immutable-types"><a href="#不可变数据类型-Immutable-types" class="headerlink" title="不可变数据类型(Immutable types)"></a>不可变数据类型(Immutable types)</h2><p>定义：一旦一个变量被创建且被赋初值，其值不能再改变。此外，如果如果是引用类型，也可以是不变的，即一旦确定其指向的对象，不能再被改变指向其他对象。</p>
<p>我们一般用final标识符，来说明这个变量的值不能再被改变。一旦一个变量被final修饰后并进行首次赋值后，编译器进行静态类型检查时，如判断 final 变量首次赋值后发生了改变，会提示错误。如图idea报错。</p>
<p><img src="/2021/05/20/Snaphot/1.png"></p>
<p>下面举一个不可变数据类型String的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时创建了一个String类型的变量str，值为”Hello”，这里是一个局部变量，下图给出其在内存中的表示。</p>
<p><img src="/2021/05/20/Snaphot/2.png"></p>
<p>再执行了下面一条语句后，其变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str + <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/20/Snaphot/3.png" alt="image-20210706184856276"></p>
<p>可以看到，其并没有改变堆里地址为0x2233存储的原来的字符串值，而是在堆里新建一个对象，其值为“HelloWorld”，然后改变栈里str的存储值。</p>
<p>用Snaphot图表示变化：</p>
<p><img src="/2021/05/20/Snaphot/4.png" alt="image-20210706190855510"></p>
<p>不可变数据类型的<strong>优点</strong>：因为其值不能改变，不可变类型更“安全”，在其他质量指标上表现更好。其安全性会在下面与可变数据类型对比时体现出来。</p>
<p><strong>缺点</strong>：使用不可变类型，对其频繁修改会产生大量的临时拷贝，需要垃圾回收。就正如上面所举的例子：改变了str的值，但“Hello”的值仍然在堆中，就需要垃圾回收。</p>
<h2 id="可变数据类型"><a href="#可变数据类型" class="headerlink" title="可变数据类型"></a>可变数据类型</h2><p>定义:可以<strong>改变</strong>值，且拥有方法可以修改自己的值。</p>
<p>这里举一个可变数据类型StringBuilder的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">str1.append(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里选择直接用Snaphot图表示变化：</p>
<p><img src="/2021/05/20/Snaphot/5.png" alt="image-20210706190817364"></p>
<p>看到这里，可能就会产生疑惑：这里的StringBuilder和前面的String的结果不都一样吗？没有什么区别啊。但这个还需要我们深思一下。</p>
<p>如果是当只有<strong>一个</strong>引用指向该对象，二者没有区别。</p>
<p>但是<strong>注意：</strong>有多个引用的时候，差异就出现了！！！</p>
<p>给出上课老师举的例子：</p>
<p><img src="/2021/05/20/Snaphot/6.png" alt="image-20210706191223709"></p>
<p>可以看到，变量t和s都最开始都指向同一个值“ab”，但当t修改值变为“abc”时，仅仅改变了t的指向，指向“abc”，而并未更改原来的值，s的值不变仍为“ab”；</p>
<p>再看变量sb和tb二者最开始都指向同一个值“ab”，但当tb改变值为“abc”时，是在原有的值上直接修改，不同于之前String类型变量t，这样一来sb也并未改变值，但其由于指向的值的改变，导致sb的值变为“abc”；这就相当危险了，看上去是对一个变量值的修改，却也同时改变了另一个变量的值，很难让人察觉出这一变化，从而产生一些副影响。这里就体现了不可变数据类型的<strong>安全性</strong>所在！</p>
<p>但可变数据类型还是有<strong>优点</strong>的：首先就是，我们的程序需要值的变化，其必不可少。</p>
<p>可变类型最少化拷贝以提高效率，减少垃圾；其次，也适合于在多个模块之间共享数据，例如全局变量。</p>
<p>但是我们上面提到了可变数据类型的一些<strong>“危险”</strong>，那就讲一讲如何<strong>安全</strong>的使用可变类型：</p>
<p>局部变量，只有一个引用，不会涉及共享，不会有危险。</p>
<p>但如果有多个引用（别名），使用可变类型就非常不安全。</p>
<p>主要办法就是：防御性拷贝，给客户端返回一个全新的对象，是要返回值的拷贝，但是新建的，地址不同，避免直接返回，传递地址，致使产生多个引用。</p>
<h2 id="Snophot-Diagram"><a href="#Snophot-Diagram" class="headerlink" title="Snophot Diagram"></a>Snophot Diagram</h2><p>Snophot图十分常用，其主要用于描述程序运行时的内部变化，如在栈中和堆中的对象、变量等等。</p>
<p>其优点是：直观、简洁，便于程序员之间交流，便于刻画各类变量随时间发生的变化，便于解释思路。</p>
<p>下面讲一讲其表示规范。</p>
<h3 id="基本类型的值"><a href="#基本类型的值" class="headerlink" title="基本类型的值"></a>基本类型的值</h3><p>其用箭头指向一个常量表示变量对这个值的引用。如图所示：</p>
<p><img src="/2021/05/20/Snaphot/7.png" alt="image-20210706195413812"></p>
<h3 id="对象类型的值"><a href="#对象类型的值" class="headerlink" title="对象类型的值"></a>对象类型的值</h3><p>对象类型的值用一个按其类型标记的圆表示。</p>
<p>定义一个圆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;  <span class="comment">//圆心横坐标</span></span><br><span class="line">    <span class="keyword">int</span> y;  <span class="comment">//圆心纵坐标</span></span><br><span class="line">    <span class="keyword">int</span> r;  <span class="comment">//圆的半径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要显示更多的细节时，可在这个圆里面写明成员变量名，用箭头指向它们的值。若想要更详细，可以标明其成员变量的类型。</p>
<p><img src="/2021/05/20/Snaphot/8.png" alt="image-20210706200318325"></p>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p> 其在对象类型的基础上改为双线椭圆。</p>
<p>如之前前面所举的例子。</p>
<p><img src="/2021/05/20/Snaphot/4.png" alt="image-20210706190855510"></p>
<h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>这个也较为简单，就是之前举的例子。</p>
<p><img src="/2021/05/20/Snaphot/5.png" alt="image-20210706190817364"></p>
<h3 id="不可变的引用"><a href="#不可变的引用" class="headerlink" title="不可变的引用"></a>不可变的引用</h3><p>这里不可变的引用是指，变量指不可变。其用双线箭头表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> y =<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="/2021/05/20/Snaphot/9.png" alt="image-20210706200914860"></p>
<p>同时我们还要注意：引用是不可变的，但指向的值却可以是可变的。比如说，定义了一个final StringBuilder sb，我们不能改变其指向，但其指向的值却是可改变的。</p>
<p>可变的引用，也可指向不可变的值，比如说，定义了一个String s，其指向一个存储在堆中不可变的值“Hello”，但我们可以改变s的指向，指向“Hello world”。</p>
<p>这就是关于Snophot的内容。</p>
<p>这些只是自己的一些浅薄的理解，若有问题，恳请批评指正。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】软件构造课程PPT</p>
<p>【2】自学JAVA的笔记</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Snaphot</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>UML类图简述及IDEA中UML插件的安装和使用</title>
    <url>/2021/06/15/UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在上软件构造这门课中，随着课程的深入，PPT上出现了许多的类图，初次看起来不太懂各种箭头指向表明的含义；此外，老师还提到了许多类与类之间的关系，依赖、组合、泛化、实现等等，其在UML类图上都有体现。同时考虑到UML类图的在工作学习种会广泛使用，以及其清晰简洁的类与类之间关系的表示，同时可以在我们的实验报告中用类图展示类与类之间关系，简洁明了，由此产生了学习UML类图的想法，到网上查阅资料学习并撰写博客记录。</p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><h3 id="UML图定义"><a href="#UML图定义" class="headerlink" title="UML图定义"></a>UML图定义</h3><p>​        UML图，实际上是一种<strong>语言</strong>， 统一建模语言，又称标准建模语言，是用来对软件密集系统进行可视化建模的一种语言。UML的包括<strong>UML语义</strong>和<strong>UML表示法</strong>两个元素。</p>
<p>​        UML是在开发阶段，说明、可视化、构建和书写一个<strong>面向对象</strong>软件密集系统的制品的开放方法。最佳的应用是工程实践，对大规模，复杂系统进行建模方面，特别是在<strong>软件架构</strong>层次，已经被验证有效。统一建模语言（UML）是一种模型化语言。模型大多以<strong>图表</strong>的方式表现出来。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。</p>
<p>​        UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</p>
<h3 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h3><ol>
<li>用例图。</li>
<li>静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图。</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图。</li>
</ol>
<p>说明：</p>
<ul>
<li>类图是描述<strong>类与类</strong>之间的<strong>关系</strong>，是UML图中最<strong>核心</strong>的。</li>
</ul>
<p>下面着重介绍UML类图</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>​        UML类图的介绍：</p>
<ul>
<li>描述系统中类（对象）本身的组成（成员属性和成员方法）和类（对象）之间的各种<strong>静态关系</strong>。</li>
<li>类之间的关系：依赖、泛化、实现、关联、聚合与组合。</li>
</ul>
<h3 id="类图的依赖关系（Dependence）"><a href="#类图的依赖关系（Dependence）" class="headerlink" title="类图的依赖关系（Dependence）"></a>类图的依赖关系（Dependence）</h3><p>​        只要是在类中用到了对方，那么他们之间就存在依赖关系，如果没有对方，甚至连编译都过不了。依赖关系是类与类之间最广泛、最普遍也是最基础的关系。</p>
<p>​        下面几条为判断类依赖关系的依据：</p>
<ul>
<li><p>类中用到了对方</p>
</li>
<li><p>类的成员属性</p>
</li>
<li><p>方法中使用到</p>
</li>
<li><p>是方法的返回类型</p>
</li>
<li><p>是方法接收的参数类型</p>
<p>​    就拿最简单的Person来举例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    每个人Person都有自己的身份证号，这里新建一个IDnumber类，使用到了IDnumber类，而id又是Peroson的成员变量，同时在setIDnumber方法传入参数类型也为IDnumber ，getIDnumber方法中返回的类型也为IDnumber，只要存在上述的任意一条出现，就可以说IDnumber类和Peroson类构成了依赖关系。</p>
<p>​    在UML类图中，用带箭头的虚线表示，箭头指向被依赖方，比如说，这里Person类指向IDnumber类。如下图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Dependence.jpg"></p>
</li>
</ul>
<h3 id="类图中的泛化关系（Generalization）"><a href="#类图中的泛化关系（Generalization）" class="headerlink" title="类图中的泛化关系（Generalization）"></a>类图中的泛化关系（Generalization）</h3><p>​        泛化关系实际上就是继承关系，比如B类（子类）继承了A类（父类），二者构成了泛化关系。泛化关系是依赖关系的特例。前面已经提到依赖关系是最普遍的关系，而这里则是针对关系的特点再细分。</p>
<p>​        这里就用Human和Person来举例，每个人都是人类，都要吃饭和睡觉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber idnumber;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在UML类图中，用带三角箭头的实线表示泛化关系，其箭头指向父类。如下图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/extend.jpg"></p>
<h3 id="类图中的实现关系（Realization）"><a href="#类图中的实现关系（Realization）" class="headerlink" title="类图中的实现关系（Realization）"></a>类图中的实现关系（Realization）</h3><p>​        实现关系就是A类实现B接口，表示类具备了某种能力，也是依赖关系的特例。</p>
<p>​        这里就用Person类和Swimming接口来举例，并不是每个人都会游泳，就比如说我这只“旱鸭子”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Swimming</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implenment</span> <span class="title">Swimming</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> 	<span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在UML类图中带三角箭头的虚线表示依赖关系，其箭头指向实现的接口。如下图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/implement.jpg"></p>
<h3 id="类图中的关联关系（Association）"><a href="#类图中的关联关系（Association）" class="headerlink" title="类图中的关联关系（Association）"></a>类图中的关联关系（Association）</h3><p>​        一个类中的成员变量（成员属性）用到了其他类，则称二者构成关联关系。关联关系实际上就是类与类之间的联系，也是依赖关系的特例。</p>
<p>​        关系具有导航性，即双向关系或单向关系，单向一对一关系，双向一对一关系。</p>
<p>​        关系具有多重性，如“1”表示有且仅有一个，“0…”表示0个或者多个，“0，1”表示0个或1个，“i…j”表示i到j个都可以，“m…*”表示至少m个。</p>
<p>​        这里依旧拿Person和IDnumber来举例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">现在Person类和IDnumber类的关系就是关联关系，Person类的成员属性中用到了IDnumber类，此时是单向一对一的，Person对应IDnumber，而IDnumber并没对应Person。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML类图如下：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Associate1.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段表示Person与IDnumber关系仍是关联关系，但与上面的单向一对一的不同，此时，Person对应IDnumber，而IDnumber也对应Person，是双向一对一关系。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    UML类图如下：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Associate2.jpg"></p>
<p>​    在UML类图中带箭头的实线表示关联关系，箭头指向关联类。</p>
<h3 id="类图中的聚合关系（Aggregation）"><a href="#类图中的聚合关系（Aggregation）" class="headerlink" title="类图中的聚合关系（Aggregation）"></a>类图中的聚合关系（Aggregation）</h3><p>​        聚合关系表示的是整体和部分的关系，整体与部分可以分离，部分具有一定的独立性。整体和部分具有各自的生命周期，部分可以属于多个对象，也可以被多个对象共享；比如计算机和CPU、鼠标、键盘，公司与员工的关系。</p>
<p>​        在代码层面来讲，聚合与关联是一致的，只能从语义上来区分。聚合关系是关联关系的特例，具有关联的导航性与多重性。</p>
<p>​        这里拿Computer类和Mouse类、Keyboard类来举例，电脑有鼠标、键盘等组成，但鼠标、键盘都可以拔下来，电脑损害不会损坏到鼠标、键盘，鼠标、键盘损坏也不会损坏电脑，换个新鼠标、键盘就是了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Mouse</span> <span class="title">mouse</span></span>;</span><br><span class="line">	<span class="keyword">private</span> Keyboard keyboard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMouse</span><span class="params">(Mouse mouse)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.mouse = mouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyboard</span><span class="params">(Keyboard keyboard)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.keyboard= keyboard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span></span>&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在UML类图中用带空心菱形的实线表示，菱形指向整体。如图所示。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/Aggreation.jpg"></p>
<h3 id="类图中的组合关系（Composition-）"><a href="#类图中的组合关系（Composition-）" class="headerlink" title="类图中的组合关系（Composition    ）"></a>类图中的组合关系（Composition    ）</h3><p>​        组合关系表示的也是整体和部分的关系，但是聚合关系的升级，整体和部分不可以分开，部分不能从整体中分离出来，创建了整体的同时，部分也随之创立，共诞生、共灭亡。同样是关联关系的特例。</p>
<p>​        这里依旧拿Person和Heart类举例，每个人都有心脏，自一出生下来，心脏无时无刻不跳动，当然不跳动了，人就die了，同生共死。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDnumber id;   <span class="comment">//聚合关系</span></span><br><span class="line">    <span class="keyword">private</span> Heart heart = <span class="keyword">new</span> Heart();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIDnumber</span><span class="params">(IDnumber id)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.IDnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IDnumber <span class="title">getIDnumber</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDnumber</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UML类图如下：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/composition.jpg"></p>
<p>​        此外，还有一种特例，会将聚合关系升级成组合关系，即级联删除。其前提是：类A与类B是聚合关系，A是整体，B是部分；当销毁删除A的同时，连同B一块销毁删除，这就是级联删除。当定义了级联删除时，那么A与B由原来的聚合关系升级为组合关系。就比如说上面举的Person和IDnumber的例子，删除Person时连同IDnumber一块删除，那么IDnumber和Person就是组合关系了。</p>
<p>​        在UML类图中用带实心菱形的实线表示，菱形指向整体。</p>
<h3 id="类图关系小结"><a href="#类图关系小结" class="headerlink" title="类图关系小结"></a>类图关系小结</h3><p>​        类图的6种关系中，其中依赖关系是最普遍、最基础、最广泛的一类关系，再根据关系的特点细分，可以划分出泛型、实现、关联、组合、聚合关系，其都是依赖关系的特例。就像人类社会一般，每个人都与他人之间有着依赖关系，维持着人际关系，再根据人际关系特点或身份等等，分成各种关系，诸如父子、师生、朋友等等关系。</p>
<h2 id="IDEA中UML插件的安装与使用"><a href="#IDEA中UML插件的安装与使用" class="headerlink" title="IDEA中UML插件的安装与使用"></a>IDEA中UML插件的安装与使用</h2><h3 id="UML的安装"><a href="#UML的安装" class="headerlink" title="UML的安装"></a>UML的安装</h3><p>​        第一步：打开IDEA，选中左上角的<strong>文件（File）—&gt;设置（Settings）—&gt;插件（Plugins）</strong>，搜索UML，这里推荐PlantUML，然后安装，安装完成后需要重新启动IDEA。</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/1.png"></p>
<p>​        第二步：重启IDEA完成后，选中左上角的<strong>文件（File）—&gt;新建（new）</strong>，可以发现一个<strong>PlantUML File</strong>，说明可以创建UML文件了</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/2.png"></p>
<p>​        点击出现文件创建，输入文件名，以及选择UML图的类型，这里选择class，即我们最常用的UML类图。</p>
<p>​        下面是初次创建其给我们的示例：</p>
<p><img src="/2021/06/15/UML%E7%B1%BB%E5%9B%BE/3.png"></p>
<p>​        如想了解更多有关其类图的信息可以到其官网。</p>
<p>​        传送门：<a href="https://plantuml.com/class-diagram">https://plantuml.com/class-diagram</a></p>
<p>​        若要学习绘制UML图的语法，可以到PlantUML的github上获取资源。</p>
<p>​        传送门：<a href="https://github.com/plantuml/plantuml">https://github.com/plantuml/plantuml</a></p>
<h3 id="PlantUML语法"><a href="#PlantUML语法" class="headerlink" title="PlantUML语法"></a>PlantUML语法</h3><p>​        这里给出常用语法：        </p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">示例含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–</td>
<td align="center">UML图中体现为实线</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">UML图中体现为虚线</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">..&gt;</td>
<td align="center">依赖</td>
<td align="center">A..&gt;B</td>
<td align="center">类A依赖于B</td>
</tr>
<tr>
<td align="center">–&gt;</td>
<td align="center">关联</td>
<td align="center">A..&gt;B</td>
<td align="center">类A关联于B</td>
</tr>
<tr>
<td align="center">–|&gt;</td>
<td align="center">继承</td>
<td align="center">A–|&gt;B</td>
<td align="center">类A继承于B</td>
</tr>
<tr>
<td align="center">..|&gt;</td>
<td align="center">实现</td>
<td align="center">A..|&gt;B</td>
<td align="center">类A实现接口B</td>
</tr>
<tr>
<td align="center">–o</td>
<td align="center">聚合</td>
<td align="center">A–oB</td>
<td align="center">类A聚合了B</td>
</tr>
<tr>
<td align="center">–*</td>
<td align="center">组合</td>
<td align="center">A–*B</td>
<td align="center">类A组合了B</td>
</tr>
</tbody></table>
<p>​        注：</p>
<ul>
<li>这里给符号&gt;, o, *指向那一侧，在UML图中会如实体现。</li>
<li>还支持双向箭头&gt;、o、*，比如说关联关系中的双向单一关系，可以用A&lt;–&gt;B，其效果如前面所展示的Person和IDnumber的双向单一关系的UML类图一致。</li>
<li>在左侧的类一般在UML图的上侧，如Human–|&gt;Person，Person..&gt;IDnumber，其UML图如前面所说类图中泛化关系的类图所示。</li>
</ul>
<p>​        然后是权限修饰符：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">示例</th>
<th align="center">示例含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">private</td>
<td align="center">-id: IDnumber</td>
<td align="center">private IDnumber id;</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">public</td>
<td align="center">+id: IDnumber</td>
<td align="center">public IDnumber id;</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">protected</td>
<td align="center">#id: IDnumber</td>
<td align="center">protected IDnumber id;</td>
</tr>
</tbody></table>
<p>​        再是抽象类和接口：</p>
<p>​        可直接用抽象类和接口对应关键词即可，abstract和interface来声明即可。</p>
<p>​        建议：根据第一次新建UML类图文件其官方给出的示例，照猫画虎，稍加研究，很快就可以上手，需要时间不到半小时，而且一旦熟练掌握后，效率十分之高，比拖拽画类图方便很多，同时plantUML做到了所见即所得，就是实时预览，十分方便。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 尚硅谷UML介绍：<a href="https://www.bilibili.com/video/BV1G4411c7N4?p=23&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1G4411c7N4?p=23&amp;spm_id_from=pageDriver</a></p>
<p>[2] PlantUML语法：<a href="https://www.cnblogs.com/liruilong/p/11506280.html">https://www.cnblogs.com/liruilong/p/11506280.html</a></p>
]]></content>
      <categories>
        <category>UML类图</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>IDEA</tag>
        <tag>UML类图</tag>
        <tag>依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/06/24/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>老师上课讲了7种设计模式，分为三种类型:创建型模式，结构型模式，行为类模式。</p>
<p>结构型模式中主要讲了，适配器模式和装饰器模式。其中个人理解了装饰器模式，就是通过装饰对象来在原有对象的基础上增加一些新特性，上课举的咖啡的例子，在最基础的咖啡上加糖、加牛奶等等，这就是一个装饰的过程。但对适配器模式，并未理解，依旧云里雾里，课下学习，写博客记录。</p>
<h2 id="适配器模式（Adapter-Pattern）简述"><a href="#适配器模式（Adapter-Pattern）简述" class="headerlink" title="适配器模式（Adapter Pattern）简述"></a>适配器模式（Adapter Pattern）简述</h2><p>先从字面意思来理解，适配器，生活中有电源适配器，也就是插头，其作用是将插座上220V的电压转化为一般为5V（万年5V1A）的电压，以供手机充电，解决了电压过大，无法充电的问题，其实现的是插座电源和手机充电电源之间两个不兼容的接口的问题。</p>
<p>形象地说，适配器是两个不兼容的接口之间的桥梁。</p>
<p><strong>意图</strong>：将一个类的接口转换成客户端Client希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>解决的问题：</strong>主要解决改变环境后，原有的类不能在新环境下使用的情况，导致我们设计好的类被浪费，不能复用，重写耗费时间。</p>
<p><strong>主要实现方式：</strong>继承。通过增加一个接口，将已存在的子类封装起来， client 面向接口编程，从而隐藏了具体子类。</p>
<p>UML类图关系：</p>
<p><img src="/2021/06/24/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/1.png" alt="image-20210707202243644"></p>
<p>不兼容：target想要调用Request方法，而Adaptee并没有这个方法，只有SpecificRequest方法，要进行一个转换。</p>
<p>下面举一个例子来说，还是拿手机电源和插座电源来说：</p>
<p>先定义创建二者的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutletPower</span></span>&#123;  <span class="comment">//插座电源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(String appliance)</span></span>;  <span class="comment">//appliance 充电电器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhonePower</span></span>&#123; <span class="comment">//手机电源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneCharge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建两个类分别实现上面的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutletPowerImpl</span> <span class="keyword">implements</span> <span class="title">OutletPower</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(String appliance)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插座电源220V：充电&quot;</span>+appliace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhonePowerImpl</span> <span class="keyword">implements</span> <span class="title">PhonePower</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneCharge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机充电电压5V：手机充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后，现在我们就需要一个手机电源设配器，将电压由220V转换成5V，让其可以给手机充电。定义创建一个实现了phonePower接口的电源适配器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">implements</span> <span class="title">phonePower</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutletPower outletPower;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PowerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">           OutletPowerImpl = <span class="keyword">new</span> OutletPowerImpl();  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phoneCharge</span><span class="params">(String appliance)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(appliace.equalsIgnoreCase(<span class="string">&quot;phone&quot;</span>))&#123;</span><br><span class="line">          OutletPowerImpl.charge(appliance);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现电源转换：</p>
<p>这样一来，插座电源通过手机电源设配器能给手机充电。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>优点：</strong> </p>
<ol>
<li><p>可以让任何两个没有关联的类一起运行。</p>
</li>
<li><p>提高了类的复用。 </p>
</li>
<li><p>增加了类的透明度。 </p>
</li>
<li><p>灵活性好。</p>
</li>
</ol>
<p><strong>缺点：</strong> </p>
<ol>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li>
<li> 由于 JAVA规定，一个子类 至多继承一个类，即只有一个父类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ol>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>【1】 <a href="https://www.runoob.com/design-pattern/adapter-pattern.html">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p>
<p>【2】 <a href="https://www.jianshu.com/p/9d0575311214">https://www.jianshu.com/p/9d0575311214</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>保护模式内存管理</title>
    <url>/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="2-保护模式内存管理"><a href="#2-保护模式内存管理" class="headerlink" title="2. 保护模式内存管理"></a>2. 保护模式内存管理</h1><h2 id="2-1-内存管理概览"><a href="#2-1-内存管理概览" class="headerlink" title="2.1 内存管理概览"></a>2.1 内存管理概览</h2><p>​    IA-32架构的内存管理机制主要分为两部分：<strong>段式</strong>和<strong>页式</strong>。 <strong>分段</strong>提供了一种隔绝各个代码、数据和堆栈区域的机制，以致多个程序（或任务）可以运行在同一个处理器上，但不会相互干扰。 <strong>分页</strong>则为传统需求页的虚拟内存系统提供了一种实现机制，在虚拟内存系统中，程序运行所需的环境的各个部分按需映射到物理内存中。 分页同样可以为多个任务之间提供隔离措施。 当在保护模式下运行时，必须采用某种形式的分段机制。 这里没有<strong>模式位</strong>以设置禁用分段机制，也就说在保护模式的内存管理中<strong>分段机制</strong>是<strong>必需</strong>的。 但是，<strong>分页机制</strong>是<strong>可选</strong>的。<br>​    这两种机制（分段和分页）是可以被配置以致支持使用共享内存的简单的单程序（或单任务）系统、多任务系统或多处理器系统。<br>​    如图1所示，段式管理提供了一种机制：其将处理器的<strong>可寻址内存空间</strong>（也被称为<strong>线性地址空间</strong>）划分为较小的受保护的地址空间区域，称为<strong>段</strong>。 段可以用来保存<strong>程序的代码、数据和堆栈</strong>，也可用于保存<strong>系统数据结构</strong>（例如TSS或LDT）。 如果一个处理器中有多个程序（或任务）正在运行，那么每个程序都会被分配自己的一组段空间。 然后处理器可以加强这些段之间的界限，并且确保一个程序不会通过访问写入另一个程序的段而干扰另一个程序的运行。分段机制还允许对段进行分类，这样一来便可限制对特定类型段所要执行的操作。<br> <img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment_and_page.jpg"></p>
<center style="color:#1a1a1a;">图1 分段与分页</center>    

<p>​    一个系统中的所有段都包含在处理器的线性地址空间中。 为了定位到指定段中的一个字节，程序必须提供一个逻辑地址（也称为远指针）。 <strong>逻辑地址</strong>由一个<strong>段选择子</strong>和一个<strong>偏移量</strong>组成。 <strong>段选择子</strong>是一个段的<strong>唯一标识</strong>。 此外，段选择子还提供了段描述符表（如全局描述符表，GDT）中到一个被称为段描述符的数据结构的偏移量。 每个段都有一个段描述符，它指定了段的大小、段的访问权限和特权级别、段的类型以及段的第一个字节在线性地址空间中的位置（即段基址)。 将逻辑地址的偏移量部分与段的基址相加，就可以定位段内的某个字节。 因此<strong>基址加上偏移量</strong>就形成了在处理器的线性地址空间中的一个<strong>线性地址</strong>。<br>​    如果不启用分页，那么处理器的线性地址空间会被直接映射到处理器的物理地址空间。 物理地址空间定义为处理器可以在其地址总线上生成的地址范围。<br>​    因为多任务计算系统定义的线性地址空间通常都要比其含有的物理内存容量大得多，所以需要采取一些“虚拟化”线性地址空间的方法。而这种线性地址空间的虚拟化是通过处理器的分页机制来处理的。<br>​    分页机制支持建立一个<strong>虚拟内存</strong>环境，在这个环境中，可以用小量的物理内存（RAM和ROM）和一些磁盘存储空间就可以模拟大容量的线性地址空间。启用分页机制时，每个段被划为分为页（通常每个页大小为4KB），这些页存储在物理内存或硬盘中。 操作系统或程序通过维护一个页目录和一组页表来跟踪这些页。当程序（或任务）视图访问线性地址空间中的一个地址位置时，处理器便会使用页目录和页表将线性地址转换为一个物理地址，然后在该内存位置上执行所要求的操作（读或写）。<br>​    如果当前被访问的页面不在物理内存中，处理器便会中断当前程序的执行（通过产生一个页错误异常）。 然后，操作系统执行程序将从磁盘读取该页面进入物理内存，然后继续执行刚才被中断的程序。<br>​      当分页机制在操作系统或执行程序正常运作时，对于正确执行的程序来说，物理内存和磁盘之间的页面交换是透明的。 即使在IA-32处理器中，16位的程序也可在虚拟8086模式下运行时进行分页（透明地）。</p>
<p>​    总结：</p>
<ul>
<li><strong>逻辑地址（Logical Address）</strong>：一个逻辑地址由两部份组成，<strong>段标识符</strong>: <strong>段内偏移量</strong>。段标识符是由一个16位长的字段组成，称为<strong>段选择子</strong>（段选择子就是段标识符）。</li>
<li><strong>线性地址（Linear Address）</strong>：一个<strong>段的基址</strong>加上<strong>段内偏移量</strong>，形成线性地址空间中的一个线性地址。线性地址是逻辑地址到物理地址变换之间的中间层。这里段内偏移量就是逻辑地址中的段内偏移量。而段的基址跟逻辑地址中段标识符有关，通过段标识符（段选择子）可获得段描述符表中与该段选择子相关联的段描述符，段描述符提供了该段的基址。</li>
<li><strong>物理地址（Physical Address）</strong>：物理内存中的地址。</li>
</ul>
<h2 id="2-2-分段机制"><a href="#2-2-分段机制" class="headerlink" title="2.2 分段机制"></a>2.2 分段机制</h2><p>​    IA-32架构支持的分段机制可用于实现多种系统设计。这些设计范围从最小使用分段来保护程序的平坦模型，到使用分段来创建良好健壮性的操作环境的多段模型，在这种环境中，多个程序和任务可同时可靠运行的<br>​    下面几节给出了几个例子，说明如何在系统中使用分段来提高内存管理的性能和可靠性。 </p>
<h3 id="2-2-1-基本平坦模型（Basic-Flat-Model）"><a href="#2-2-1-基本平坦模型（Basic-Flat-Model）" class="headerlink" title="2.2.1 基本平坦模型（Basic Flat Model）"></a>2.2.1 基本平坦模型（Basic Flat Model）</h3><p>​    最简单的系统内存模型就是就是基本<strong>“平坦模型”</strong>，在这种模型中，操作系统或应用程序可访问一个连续的、未分段的地址空间。这样一来最大程度地向系统设计人员和程序员隐藏了体系机构的分段机制。<br>​    若要在IA-32架构下实现内存的一个基本平坦模型，则需要至少创建两个段描述符，一个用于引用代码段，一个用于引用数据段（如图2所示）。 然而，这两个段都会被映射到整个线性地址空间：即，这两个段描述符具有相同的基址：0和相同的段限长（段的最大长度）：4 GB。 通过将段限长设置为4 GB，可以避免分段机制对超过段空间大小的内存的引用产生异常，即使指定的地址不存在物理内存中。 ROM （EPROM）通常位于物理地址空间的顶部，因为处理器从FFFF_FFF0H开始执行。 RAM （DRAM）则位于在地址空间的底部，因为复位初始化后DS数据段的初始基址为0。<br><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/flat_model.jpg"></p>
<center style="color:#1a1a1a;">图2 平坦模型</center>    

<h3 id="2-2-2-保护平坦模型（Protected-Flat-Model）"><a href="#2-2-2-保护平坦模型（Protected-Flat-Model）" class="headerlink" title="2.2.2 保护平坦模型（Protected Flat Model）"></a>2.2.2 保护平坦模型（Protected Flat Model）</h3><p>​    保护平坦模型类似于基本平坦模型，指示保护平坦模型将段限制在包含<strong>物理内存实际存在的地址范围内</strong>（如图3所示）。当尝试访问不存在的内存时，会产生一个<strong>通用保护异常（#GP）</strong>。该模型针对某些程序bug提供了最低水平的硬件保护。<br><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/protected_flat_model.jpg"></p>
<center style="color:#1a1a1a;">图3 保护平坦模型</center>    

<p>​    这个保护平坦模型可以被拓展变得更加复杂，以提供更多保护功能。例如，为了确保分页机制能提供用户程序和监控程序之间代码和数据的隔离，这里需要定义<strong>四个段</strong>：<strong>权限级别为3</strong>的<strong>用户程序</strong>代码段和数据段、<strong>权限级别为0</strong>的<strong>监管程序</strong>代码段和数据段。通常这些段都相互<strong>覆盖</strong>，并且在线性地址空间的<strong>起始地址都为0</strong>。这种平坦分段模型搭配简单的分页结构可以保护操作系统不受应用程序影响，此外通过为每个任务或进程增加单独的分页结构，其还可以确保一个应用程序不受其他应用程序影响。一些流行的多任务操作系统也使用此种类似的设计。</p>
<h3 id="2-2-3-多段模型（Multi-Segment-Model）"><a href="#2-2-3-多段模型（Multi-Segment-Model）" class="headerlink" title="2.2.3 多段模型（Multi-Segment Model）"></a>2.2.3 多段模型（Multi-Segment Model）</h3><p>​    多段模型（如图4所示）利用了分段机制所提供的全部功能，为<strong>代码、数据结构、程序和任务</strong>都提供了<strong>硬件级强制保护</strong>。在这个模型中，每个程序（或任务）都被分配了自己的段描述符和段空间。段可以是其分配段的程序所<strong>私有</strong>的，也可多个程序<strong>共享</strong>。此外，操作系统硬件来控制对运行在系统中的各个程序的所有段和执行环境的访问。<br>​    <img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/multi-sgement.jpg"></p>
<center style="color:#1a1a1a;">图4 多段模型</center>        

<p>​    对内存访问的检查不仅可以防止引用超过段大小的地址，还可以防止程序对某些段执行不被允许的操作。例如，一个代码为只读段，因此可使用硬件来防止对该代码段的写操作。每个段的访问权限信息也可用于设置保护区和保护级别。保护级别则可用于保护操作系统程序不被未经授权的应用程序访问。<br>​    分页机制可以与图2、图3和图4中所描述的任一分段模型搭配使用。 处理器的分页机制将线性地址空间（在线性地址空间中，段也被映射）划分为页面（如图1所示）。 然后在线性地址空间中的页面会映射到物理地址空间中的页面。 分页机制提供了几种页级保护功能，它们可以与段保护功能一起使用，也可以代替段保护功能。 例如，它允许逐页执行读写保护。 分页机制还提供了两级用户-监管保护，也可以逐页指定这种保护。</p>
<h2 id="2-3-逻辑地址和线性地址的转换"><a href="#2-3-逻辑地址和线性地址的转换" class="headerlink" title="2.3 逻辑地址和线性地址的转换"></a>2.3 逻辑地址和线性地址的转换</h2><p>​    在系统保护模式中，处理器需要经过两部分的地址转换以完成到物理地址空间的转换：逻辑地址转换和线性地址空间分页。<br>​    即使最小程度地使用分段，处理器地址空间中的每一个字节都需要使用逻辑地址访问。一个<strong>逻辑地址</strong>由<strong>16位段选择符</strong>和<strong>32位偏移量</strong>组成，如图5所示。<strong>段选择符</strong>标识该字节所位于的段，偏移量确定字节相对于段基址的<strong>段内位置</strong>。<br>     处理器会将每个逻辑地址转换成线性地址。 线性地址是处理器线性地址空间中的一个32位地址。 与物理地址空间类似，线性地址空间是一个平坦的（未分段的）、大小为$2^{32}$字节的地址空间，地址范围从0开始到0xFFFFFFFF结束。<strong>线性地址空间</strong>包含<strong>所有的段</strong>和<strong>系统定义的系统表</strong>。<br><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/logic_address.jpg"></p>
<center style="color:#1a1a1a;">图5 逻辑地址到线性地址的转换</center>    

<p>​    从逻辑地址转换到线性地址，处理器需要做如下操作：</p>
<ol>
<li>使用<strong>段选择子中的偏移量</strong>来定位在GDT或LDT中对应的段描述符，然后读取到处理器中。（这步仅当一个新的段选择子被加载到段寄存器时才需要）。</li>
<li>检查段描述符以检查<strong>段的访问权限和范围</strong>，以确保该段是可访问的，并且保证<strong>段偏移在段的大小范围</strong>内。</li>
<li>将<strong>段描述符中的段的基址</strong>与<strong>段偏移量</strong>相加，形成一个<strong>线性地址</strong>。  </li>
</ol>
<p>​    如果不使用分页机制，处理器将会将线性地址直接映射为物理地址（也就是说，也就是说，线性地址可以直接送到处理器的地址总线，也就是说，线性地址等同于物理地址）。 如果线性地址空间被分页，启用分页机制，则会使用第二级地址转换来将线性地址转换为物理地址。</p>
<h3 id="2-3-1-段选择子（Segment-Selectors）"><a href="#2-3-1-段选择子（Segment-Selectors）" class="headerlink" title="2.3.1 段选择子（Segment Selectors）"></a>2.3.1 段选择子（Segment Selectors）</h3><p>​    一个段选择子是一个<strong>段的16位标识符</strong>（如图6所示）。段选择子不直接指向一个段，反而指向定义了一个段的段描述符。一个段选择子包含了如下几项信息：</p>
<ul>
<li>Index：索引（第3到15位），共13位，可从GDT或LDT中8192（$2^{13}$）个段描述符中选择一个。处理器将索引值乘以8（一个段描述符的大小为8字节），并将其与GDT或LDT的基址（分别来自GDTR或LDTR寄存器）相加可定位一个段描述符。  </li>
<li>TI (table indicator) flag  ：表指示标志位（第2位），指示所使用段描述符表，当复位时，表示选择GDT；设置该表示位时，表示选择LDT。</li>
<li>Requested Privilege Level (RPL)  ：请求特权级别（第0和第1位），共两位，指示该段选择子的权限级别。权限级别的范围为0到3，<strong>权限级别0为最高权限级别</strong>。</li>
</ul>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/selector.jpg"></p>
<center style="color:#1a1a1a;">图6 段选择子</center>    

<p>​    处理器不使用GDT的<strong>第一个表项</strong>。 指向这个GDT表项的段选择子（即索引值为0且TI标志设置为01的段选择子）称为<strong>“空段选择器”</strong>。 当空选择器加载入段寄存器（除CS或SS寄存器（代码段寄存器、堆栈段寄存器）外）时，处理器不会产生异常。 然而，当使用存储空选择器的段寄存器访问内存时，它会产生一个异常。 空选择器可以用于<strong>初始化未使用的段寄存器</strong>。 用空段选择器加载CS或SS寄存器会导致生成一个通用保护异常（#GP）。<br>​    段选择子作为指针变量的一部分对应用程序可见，段选择子的值通常由链接编辑器或链接加载器分配或修改，而不是应用程序。    </p>
<h3 id="2-3-2-段寄存器（Segment-Registers）"><a href="#2-3-2-段寄存器（Segment-Registers）" class="headerlink" title="2.3.2 段寄存器（Segment Registers）"></a>2.3.2 段寄存器（Segment Registers）</h3><p>​    为了减少地址转换时间和降低编程复杂度，处理器提拱了至多可存储<strong>6个段选择子的寄存器</strong>（如图7所示）。每个段寄存器支持一种特定类型的内存引用（代码、堆栈或数据）。对于执行任何类型的程序，至少要将<strong>有效的段选择符</strong>加载到<strong>代码段（CS）、数据段（DS）和堆栈段（SS）</strong>。处理器还提供另外的数据段寄存器（ES、FS、GS），可贝用于让当前正在执行的程序（或任务）能够访问其他几个数据段。<br>​    对于访问一个段的一个程序，段选择器必须已经加载到一个段寄存器中。 因此，尽管一个系统可以定义上千个段，但只有6个段可立即访问使用。 在程序执行期间，通过将其他段的段选择子加载到这些寄存器中，就可以访问其他段。<br><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Segment_Register.jpg"></p>
  <center style="color:#1a1a1a;">图7 段寄存器</center>        

<p>​    每个段寄存器都有一个<strong>“可见”</strong>部分和一个<strong>“隐藏”</strong>部分 （隐藏部分有时被称为<strong>“描述符缓存”</strong>或<strong>“影子寄存器”</strong>）。当一个段选择符被加载到段寄存器的可见部分时，处理器会同时将<strong>段选择符所指向的段描述符的段基址、段限长、 以及访问控制信息</strong>加载到段寄存器的隐藏部分。 段选择符缓存在段寄存器中的信息（可见和隐藏部分）使得处理器可以直接进行地址转换，而不需要再花费额外的总线周期从段描述符读取段的基址和段限长信息。 在一个多处理器系统中，处理器都访问同一个描述符表，如果描述表被修改，则软件应负责重新加载段寄存器。 如果不重新加载，则可能出现段描述符已经被修改，却仍在使用缓存在段寄存器中的旧段描述符的清空。<br>​    提供了以下两种方法来加载段寄存器：</p>
<ul>
<li>使用MOV，POP，LDS，LES，LSS，LGS和LFS 等指令加载。这些指令<strong>显式</strong>地引用段寄存器。</li>
<li>隐式加载指令，例如使用长指针方法的CALL，JMP和RET指令，还有SYSENTER和SYSEXIT指令，IRET，INT <em>n</em>，INTO和INT3指令。这些指令执行时会附带修改CS寄存器的内容（有时也会修改其它寄存器的内容）。</li>
<li>MOV指令也可被用于把段寄存器的可见部分的内容加载到一个通用目的寄存器。</li>
</ul>
<h3 id="2-3-3-段描述符（Segment-Descriptors）"><a href="#2-3-3-段描述符（Segment-Descriptors）" class="headerlink" title="2.3.3 段描述符（Segment Descriptors）"></a>2.3.3 段描述符（Segment Descriptors）</h3><p>​    一个段描述符是GDT或LDT中的一个数据结构，其提供处理器中一个段的大小、位置、访问控制和状态信息。段描述符通常由编译器、链接器、加载器或操作系统或执行程序创建，而不是应用程序创建。图8展示了所有类型的段描述符的通用描述符格式。<br>​    <img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment_descripotor.jpg"></p>
  <center style="color:#1a1a1a;">图8 段描述符</center>        

<p>​    一个段描述符的标志位和字段信息如下：</p>
<ul>
<li>Segment limit field ：段限长字段，指明一个段的大小。处理器会把<strong>两个段限长字段</strong>拼接形成一个<strong>20位长的值</strong>。并根据颗粒度标志位G的两种不同的值来解释段限长字段的含义。<br>若G=0，段大小的范围为1字节到1MB字节，单位为1字节。若G=1，段大小的范围为4KB到4GB字节，单位为4KB字节。<br>处理器通过两种不同方式使用段限长，其依据是段是<strong>向上扩展段</strong>还是<strong>向下扩展段</strong>。  对于向上拓展的段，逻辑地址的段偏移量的范围为<strong>0字节到段限长值</strong>。大于段限长的偏移量将会产生一个一般保护异常（#GP，所有段都会产生除了堆栈段外）或一个堆栈错误异常（#SS表示SS段）  。对于一个向下拓展段，则相反，段偏移量的范围为<strong>段限长1字节增长到0xFFFFFFFFH或0xFFFFH</strong>（这个取决于B标志位的设置）。小于或等于段限制的偏移量会产生一般保护异常或堆栈故障异常。对于向下拓展段，减少段限长的值允许在段地址空间底部分配新的内存，而不是再顶部。因为IA-32架构所使用的栈总是向下增长的，所以这种机制便于栈的扩展。</li>
<li>Base address fields  ：基址字段，该字段定义了段的0字节在4GB大小的线性地址空间中的位置。 处理器将<strong>三个基址字段</strong>拼接在一起形成一个<strong>32位长</strong>的值。 段基址应按16字节边界进行对齐。 虽然16字节对齐不是必需的，但是通过把程序的代码和数据按16字节边界上对齐，可使得程序性能最佳。（即，边界对齐便于数据的访问）</li>
<li>Type field  ：类型字段，指示<strong>该段或门的类型</strong>，并指明段的访问类型和段的扩展方向。根据描述符类型标志位，这个字段会有两种含义：<strong>应用程序（数据、代码）段描述符</strong>或<strong>系统段描述符</strong>。对于代码段、数据段、系统段，这个字段的编码并不相同。</li>
<li>S (descriptor type) flag：描述符类型标志位，其指明了一个段描述符是一个系统段描述符（该标志位复位）还是一个代码或数据段描述符（该标志位被设置）。</li>
<li>DPL（descriptor privilege level  ）field：指明该段的特权级别。特权级别的取值范围为<strong>0 -3</strong>，<strong>0是权限级别最高</strong>。DPL用于控制对段的访问。</li>
<li>P(segment-present) flag：段存在标志位，指明段是否于内存中存在（P=1，在内存中；P＝0，不存在内存中）。若P＝0，当一个段描述符的段选择符加载进段寄存器时处理器会产生一个<strong>段不存在异常</strong>。内存管理软件可以使用此标志位来控制在某一给定时间将指定的段加载进物理内存中，这为管理虚拟内存提供了除分页以外的控制。图9展示了P＝0时一个段描述符的格式。当复位该标志位时，操作系统或执行程序可以<strong>自由使用格式中标为“可用”（Available）的位置</strong>来存储自己的数据，例如有关不存在段实际在什么地方的信息。</li>
<li>D/B(default operation size/default stack pointer size and/or upper bound) flag  ：D/B（默认操作大小/默认栈指针大小和/或上界限）标志，其根据段描述符描述的是一个可执行代码段、还是下扩数据段、或堆栈段来执行不同的功能。（对于32位代码和数据段，该标志位应该总被设置为1；对于16位数据和代码段，该标志段被设置为0）。<ul>
<li><strong>可执行代码段：</strong>此时这个标志被称为<strong>D标志位</strong>，其指明段中的指令引用有效地址和操作数的默认长度。当D＝1，则默认值为32位地址和32位或8位操作数；当D＝0，则默认值为16位地址和16位或8 位操作数。指令前缀0x66H可用来选择非默认值的操作数大小；指令0x67H可用来选择非默认值的操作地址大小。</li>
<li><strong>堆栈段（由SS寄存器指向的数据段）：</strong>此时这个标志被称为<strong>B标志位</strong>，它用于指明隐含栈操作（如pushes、pops、calls）时的栈指针的大小。当B＝1，则使用一个32位的栈指针，它存储在32位的ESP寄存器中；假如B=0，则使用一个16位的栈指针，它存储在16位的SP寄存器中。假如堆栈段被设置成一个下扩数据段，那么B标志也同时指定了堆栈段的上界限。</li>
<li><strong>下扩段（Expand-downdata segment）</strong>此时标志叫作<strong>B标志</strong>，它指明堆栈段的上界。当B=1,上界为0xFFFFFFFFH（4Gbytes）；当B＝0，上界为0xFFFFH（64KBytes）。</li>
</ul>
</li>
<li>G (granularity) flag  ：颗粒度标志位G，其决定了段限长域字段的单位。当G＝0时，段限长的单位为字节；当G＝1时，段限长的单位为4KB（这个标志位不会影响基地址的颗粒度，基地址的颗粒度总是字节单位。）。若设置了该标志位，则在使用段限长检查偏移量时，不会检查偏移量的12位最低有效位。 例如，当G=1时，段限长为0表明有效偏移量为0到4095。</li>
<li>L（64-bit code segment) flag  ：L标志位，在IA-32e模式下，段描述符第二个双字的第21位表示该代码段是否存储了本地64位代码。 当L=1时，表示在64位模式下执行该代码段中存储的指令。 当L=0时。表示在兼容模式下执行此代码段中存储的指令。 如果设置了L位，则必须复位D标志位。 当在非IA-32e模式或该段非代码段时，第21位是保留的，并且应该总是设置为0。  </li>
<li>Available and reserved bits  ：可用和保留位，段描述符的第二个双字的第20位是保留给操作系统软件使用的；</li>
</ul>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/descriptor(P=0).jpg"></p>
  <center style="color:#1a1a1a;">图9    P=0时的段描述符</center>        

<h2 id="2-4描述符的分类"><a href="#2-4描述符的分类" class="headerlink" title="2.4描述符的分类"></a>2.4描述符的分类</h2><h3 id="数据段和代码段描述符（Data-and-Code-segment-Descriptor）"><a href="#数据段和代码段描述符（Data-and-Code-segment-Descriptor）" class="headerlink" title="数据段和代码段描述符（Data and Code segment Descriptor）"></a>数据段和代码段描述符（Data and Code segment Descriptor）</h3><p>​    当段描述符中的<strong>S标志位被设置</strong>时，该描述符描述的是一个代码或数据段。类型字段（type）的<strong>最高有效位</strong>（第二个双字的第11位）用于决定是一个数据段（复位）还是一个代码段描（置位）。<br>​    即：</p>
<ul>
<li>当S=1，type的最高有效位为0时，该段描述符指向一个数据段；</li>
<li>当S=1，type的最高有效位为1时，该段描述符指向一个代码段。</li>
</ul>
<p>​    对于数据段描述符，类型字段的低3位（第8、9、10位）的含义分别为被访问accessed (A)、可写write-enable (W)和拓展方向expand -direction (E)。表1展示了代码段和数据段的类型字段比特位编码的说明。根据可写比特位W的设置, 数据段可以是只读的，也可以是可读/写的。<br><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/date_and_code.jpg"> </p>
  <center style="color:#1a1a1a;">表1   代码段和数据段描述符类型</center>        

<p>​    <strong>堆栈段</strong>必须是一个<strong>可读/写的数据段</strong>。若将不可写数据段的段选择符加载到 SS 寄存器中，则会导致产生一个一般保护异常。如果堆栈段的长度会动态变化，那么堆栈段可以是一个<strong>向下扩展的数据段</strong>（扩展方向标志被设置）。因而，动态改变段限长的值将导致栈空间被添加到栈底部。  如果希望堆栈段的大小保持不变，则堆栈段可以是向上拓展或向下拓展类型。<br>​    被访问位A指明该段自上次操作系统或执行程序复位<strong>该位后是否被访问过</strong>。 如果包含段描述符的内存类型支持<strong>处理器写操作</strong>，那么处理器每次将<strong>段选择符加载到段寄存器</strong>时都会设置这个位。 该位会一直保持被设置状态，直到其<strong>显式复位</strong>。 该标志位既可以用于虚拟内存管理，也可以用于调试。<br>​    对于代码段，类型字段的低三位的含义（第8、9、10位）分别为<strong>被访问accessed (A)、可读read enable (R)、 一致conforming (C)<strong>。代码段可以是</strong>只能执行或可执行/可读</strong>，这取决于<strong>可读位的设置</strong>。 当<strong>常数或其他静态数据以及指令码</strong>存储在了一个ROM 中时，就可以使用一个可执行/可读代码段。  通过使用<strong>带CS前缀的指令</strong>或者把<strong>代码段选择符</strong>加载进一个<strong>数据段寄存器</strong>（DS、ES、FS或GS寄存器），就可读取代码段中的数据。 在<strong>保护模式</strong>下，<strong>代码段是不可写</strong>的。<br>​    代码段可以是<strong>一致性和非一致性的</strong>。操作系统允许执行在当前特权级的程序向一个<strong>更高权级的一致性代码段</strong>进行转移。当向一个<strong>不同特权级别</strong>的<strong>非一致性代码段</strong>进行执行转移时，会产生一个通用保护异常（#GP），除非使用<strong>调用门（call gate）或任务门（task  gate）</strong>（这个我们已经在读书笔记1中，有所了解，通过门，可以进行<strong>跨权限级别的访问</strong>）。一些系统工具（不访问保护设施）和一些处理某些异常类型（如除出错，溢出）的处理程序可以放在一致性代码段内。<strong>需要保护其不能被更低特权级程序</strong>访问的程序应该放在非一致性代码段内。<br>​     所有的<strong>数据段</strong>都是<strong>非一致性</strong>的，这意味着它们不能<strong>被更低特权级（权限数字值较大）的程序或过程访问</strong>。与代码段不同的是，<strong>数据段</strong>总是能被<strong>更高特权级（权限数字值较小，数字越小，权限越高）的程序或过程访问</strong>，而不需要使用特别的访问门。<br>​    当GDT或LDT中的<strong>段描述符存储在在ROM</strong>中时，若软件或处理器试图<strong>更新（写入）位于ROM的段描述符</strong>，则处理器就会进入一个<strong>无限循环</strong>。 为了避免该问题发生，将ROM中所有段描述符的<strong>访问位都置位</strong>。同时，会将那些试图修改ROM中段描述符的操作系统代码或执行代码删除掉。<br>​    <strong>注意：</strong>不能通过call或jump转入更低权限级别（权限数字值较大）的代码段执行，不管目标段是一个一致性还是非一致代码段。这种转移执行的尝试操作，将会引起一个一般保护异常。</p>
<h3 id="系统描述符类型（SYSTEM-DESCRIPTOR-TYPES-）"><a href="#系统描述符类型（SYSTEM-DESCRIPTOR-TYPES-）" class="headerlink" title="系统描述符类型（SYSTEM DESCRIPTOR TYPES  ）"></a>系统描述符类型（SYSTEM DESCRIPTOR TYPES  ）</h3><p>​    当段描述符中的<strong>S标志位（描述符类型）被复位</strong>时，表明该段描述符为一个系统描述符。处理器能识别以下一些类型的系统段描述符：</p>
<ul>
<li><p>本地描述符表(LDT)的段描述符</p>
</li>
<li><p>任务状态段(TSS)描述符</p>
</li>
<li><p>调用门描述符</p>
</li>
<li><p>中断门描述符</p>
</li>
<li><p>陷阱门描述符</p>
</li>
<li><p>任务门描述符</p>
<p>这些描述符可分为两大类：<strong>系统段描述符和门描述符</strong>。系统段描述符指向一个系统段（LDT或TSS段）。门描述符就是他们自己——“门”，这些门描述符存储了代码段中指向程序入口点的指针（调用、中断和陷阱门），或者存储了TSS的段选择符（任务门）。  图2占了系统段描述符和门描述符类型字段的编码及说明。</p>
</li>
</ul>
<p><img src="/2022/04/03/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/system_descriptor.jpg"></p>
  <center style="color:#1a1a1a;">表2   系统段描述符类型</center>            

]]></content>
      <categories>
        <category>体系结构</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>X86</tag>
        <tag>体系结构</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习</title>
    <url>/2021/09/23/python%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>恰逢机器学习要做实验，肯定选择用python写代码来完成实验，那就快速恶补一下Python基本知识，一些语法之类的，就简单做些笔记，一份面向已有编程基础的速成笔记，主要记录一些Python3基础语法不同之处所在，简单的、相似的就略去了。</p>
<h2 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h2><h3 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h3><p>首先，我们需要注意的是缩进在Python中非常重要，因为Python不使用我们习惯的<code>&#123;&#125;</code>来划分逻辑块，<del>有些痛苦，刚开始看起来比较费劲</del>，但其目的是为了简明，就举个例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&gt;1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> b &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;b&gt;1&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;b&lt;=1&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> a == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a=1&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&lt;1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>等价的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&gt;1&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(b&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;b&gt;1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;b&lt;=1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&lt;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br></pre></td></tr></table></figure>

<p>缩进的空格数是可变的，但是<strong>同一个代码块</strong>的语句必须包含<strong>相同的缩进空格数</strong>，一般建议在每个缩进层次使用 <strong>单个制表符</strong> 或 <strong>两个空格</strong> 或 <strong>四个空格</strong> , 此外还要注意<strong>不能混用</strong>。</p>
<p>我们还可以注意到其不用以  <code>;</code> 结束，可谓’;’遗忘患者的福音了，其一般用新行作为语句的结束符。</p>
<p>既然Python不用<code>;</code>结束，且行和缩进这么重要，那么多行语句该怎么办呢？可以用多行连接符<code>\</code>进行连接，但存在 [], {} 或 () 括号就不需要使用多行连接符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span> + \</span><br><span class="line">    <span class="number">2</span> + \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">members = [<span class="string">&quot;Hans&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Stephen&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>或者是同一行显示多条语句，语句之间可以用<code>;</code>来分割，如下例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; &#39;runnoob&#39;; y &#x3D; &quot;john&quot;; print(x,y)</span><br></pre></td></tr></table></figure>

<p>此外，空行也较为重要。</p>
<ul>
<li>空行分隔函数或类的方法，表示一段新的代码的开始。</li>
<li>空行分隔类和函数入口，以突出函数入口的开始。</li>
<li>不是Python语法的一部分，书写时不插入空行，也不会出错。</li>
<li>空行分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>举例说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">&quot;请输入a的值:&quot;</span>)  <span class="comment"># 暂且不考虑变量a的类型，默认为int,后面再细讲。</span></span><br></pre></td></tr></table></figure>

<p>等价C语言代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入a的值&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure>

<p><code>print</code>表示输出，但其默认换行，若要实现不换行需要在变量末尾加上逗号 <code>,</code>来实现，或是在变量末尾加上 <code>end=&quot;&quot;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>(a,b) <span class="comment"># 不换行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( a, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( b, end=<span class="string">&quot; &quot;</span> )</span><br></pre></td></tr></table></figure>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>第一个字符必须是字母表中字母或下划线 <code>_</code>。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感</li>
<li>Python3中可以用中文作为变量名，非 ASCII 标识符也是允许的了</li>
</ul>
<h3 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h3><p>保留字就表示其有特殊用途，不能用作标识符，像是变量名，类名之类的，就比如说java语言中的<code>if</code>和<code>class</code>一样。</p>
<table>
<thead>
<tr>
<th align="center">and</th>
<th align="center">exec</th>
<th align="center">not</th>
</tr>
</thead>
<tbody><tr>
<td align="center">assert</td>
<td align="center">finally</td>
<td align="center">or</td>
</tr>
<tr>
<td align="center">break</td>
<td align="center">for</td>
<td align="center">pass</td>
</tr>
<tr>
<td align="center">class</td>
<td align="center">from</td>
<td align="center">print</td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center">global</td>
<td align="center">raise</td>
</tr>
<tr>
<td align="center">def</td>
<td align="center">if</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">import</td>
<td align="center">try</td>
</tr>
<tr>
<td align="center">elif</td>
<td align="center">in</td>
<td align="center">while</td>
</tr>
<tr>
<td align="center">else</td>
<td align="center">is</td>
<td align="center">with</td>
</tr>
<tr>
<td align="center">except</td>
<td align="center">lambda</td>
<td align="center">yield</td>
</tr>
</tbody></table>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Python注释并不是用我们熟悉的 <code>//</code>  而是用<code>#  </code>注释，且<code>#</code>后面需要空一格进行注释；或者是用<code>&#39;&#39;&#39;</code>（三个单引号）或<code> &quot;&quot;&quot;</code>(三个双引号)进行多行注释。</p>
<h3 id="import-和from…impor"><a href="#import-和from…impor" class="headerlink" title="import 和from…impor"></a>import 和from…impor</h3><p>Python方便的一点就是有大量的标准库可供调用。就要用相应语句进行导入库。</p>
<ul>
<li><p><code>import</code>表示将整个模块导入，格式：<code>import somemodule</code>。</p>
</li>
<li><p> <code>import...as...</code>可将导入的模块换个别名，格式：<code>import time as abc</code>,在引用时可用别名。</p>
</li>
<li><p><code>from...import</code>表示从某个模块中导入某个函数，格式：<code>from somemodule import somefunction</code>，还可以同时从一个模块导入多个函数，格式：<code>from somemodule import firstfunc, secondfunc, thirdfunc</code>。</p>
</li>
<li><p>将某个模块中的全部函数导入，格式：<code> from somemodule import *</code></p>
</li>
<li><p><code>import</code>和<code>from...import</code>在函数引用时还有区别，如下例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用import，</span><br><span class="line">import time</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 使用from...import</span><br><span class="line">from time import sleep</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line">#使用import...as</span><br><span class="line">import time as TIME</span><br><span class="line">TIME.sleep(1)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>依然用<code>=</code>进行变量赋值</p>
<p>允许为多个变量同时赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span>   <span class="comment"># 为a,b,c三个整型变量赋值为1</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2.1</span>, <span class="string">&quot;john&quot;</span> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">为a整型变量赋值为1</span></span><br><span class="line"><span class="string">b浮点类型赋值为2.1</span></span><br><span class="line"><span class="string">c字符串类型赋值为“john</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python3有六个标准的数据类型：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple （元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>其中要区分可变数据类型与不可变数据类型：</p>
<p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p>
<p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）</p>
<p>关于不可变数据类型和可变数据类型，详情可见前面博客有关不可见数据类型的文章。</p>
<p>Python 与 C 和 Java有不同，即python变量不需要声明变量类型，这是因为像 C 语言和 Java 语言来说，它们是静态的，而 python 是动态的（前者静态编译，后者动态编译），变量的类型由赋予它的值来决定。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>Python支持四种不同的数字类型，用于存储数值，是不可改变的数据类型。</p>
<p>不可变数据类型，若改变数字数据类型的值，将重新分配内存空间。</p>
<ul>
<li>int（整型），表示长整型，没有long，可充当long使用。</li>
<li>bool（布尔）</li>
<li>float（浮点型）    </li>
<li>complex（复数），可以用a + bj,或者complex(a,b)表示，复数的实部a和虚部b都是浮点型。</li>
</ul>
<p>不需要声明变量类型，其会自动识别，或者可以使用内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># int型</span></span><br><span class="line">b = <span class="number">1.1</span> <span class="comment"># 浮点型</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">2j</span> <span class="comment"># 复数</span></span><br><span class="line">d = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 复数：1为实部，2为虚部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d)) </span><br><span class="line"><span class="comment"># &lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外还可以用 isinstance 来判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>isinstance 和 type 的区别在于：</p>
<ul>
<li>type 是用于求一个未知数据类型对象。</li>
<li> isinstance 是用于判断一个对象是否是已知类型。</li>
</ul>
<ul>
<li><p>type()不会认为子类是一种父类类型。</p>
</li>
<li><p>isinstance()会认为子类是一种父类类型，例如，在Python3中，bool是int的子类，此外，True 和 False 可以和数字相加， True==1、False==0 会返回 <strong>True</strong>，但可以通过 is 来判断类型。</p>
</li>
<li><p>可以用 isinstance 判断子类对象是否继承于父类，type 不行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="literal">True</span> == <span class="number">1</span>  <span class="comment"># True</span></span><br><span class="line"><span class="literal">False</span> == <span class="number">0</span>  <span class="comment"># True</span></span><br><span class="line"><span class="literal">True</span> + <span class="number">1</span>  <span class="comment"># 2</span></span><br><span class="line"><span class="literal">False</span> + <span class="number">1</span>  <span class="comment"># 1</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span> <span class="comment"># False</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span> <span class="comment"># False</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>当你指定一个值时，Number 对象就会被创建，也可以使用del语句删除一些对象的引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span>  <span class="comment"># Number对象被创建</span></span><br><span class="line"><span class="keyword">del</span> a, b  <span class="comment"># 删除对象引用</span></span><br></pre></td></tr></table></figure>

<p>此外：</p>
<ul>
<li>一个变量可以通过赋值指向不同类型的对象。</li>
<li>在混合计算时，Python会把整型转换成为浮点数。</li>
</ul>
<h5 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h5><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<ul>
<li><strong>int(x)</strong> 将x转换为一个整数。</li>
<li><strong>float(x)</strong> 将x转换到一个浮点数。</li>
<li> <strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li>
<li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串表示格式：可以用<code>&#39;</code>或<code>&quot;</code>括起来，但前后要一致，前面用单引号，后面也用单引号。使用反斜杠 <code>\</code>转义特殊字符。</p>
<p>其字符列表有两种取值顺序。</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<table>
<thead>
<tr>
<th align="center">H</th>
<th align="center">e</th>
<th align="center">l</th>
<th align="center">l</th>
<th align="center">o</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">-5</td>
<td align="center">-4</td>
<td align="center">-3</td>
<td align="center">-2</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>一些其他操作：</p>
<ul>
<li><p>从字符在截取一段字符，采用<code>[头下标:尾下标]</code>来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾，此外它是<strong>“左闭右开”</strong>的形式，截取的子串包含<strong>头下标</strong>的字符，但不包含<strong>尾下标</strong>的字符；</p>
</li>
<li><p><code>*</code>表示重复，<code>+</code>表示连接；</p>
</li>
<li><p>P字符串截取还可以有第三个参数，其表示的截取的步长，在索引 1 到索引 4 的区间内并设置为步长为 2（间隔1位）来截取字符串</p>
</li>
<li><p>Python 使用反斜杠 \ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)            <span class="comment"># 输出完整的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">4</span>])         <span class="comment"># 输出字符串中第5个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">5</span>])        <span class="comment"># 输出字符串中第1个至第5个之间的子串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])       <span class="comment"># 输出字符串中第3个至第5个之间的子串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">3</span>:])        <span class="comment"># 输出字符串中第4个开始的子串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)        <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&quot; test&quot;</span>)  <span class="comment"># 输出连接的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>])     <span class="comment"># 从第1个字符开始至第5个字符间隔1位截取子串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">5</span>:<span class="number">3</span>])     <span class="comment"># 从第1个字符开始至第5个字符间隔2位截取子串 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello\nWorld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;Hello\nWorld&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">o</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">llo</span></span><br><span class="line"><span class="string">lo World!</span></span><br><span class="line"><span class="string">Hello World!Hello World!</span></span><br><span class="line"><span class="string">Hello World! test</span></span><br><span class="line"><span class="string">Hlo</span></span><br><span class="line"><span class="string">Hl</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">Hello\nWorld</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>此外：与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表主要作用是：其可以完成大多数集合类的数据结构实现，它支持字符，数字，字符串甚至可以包含列表（即嵌套），即列表是个有序的大集合，里面可以存放字符串，数字，字符，甚至嵌套个列表，用<code>[]</code>标识。下面举例说明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lisT = [<span class="string">&quot;list&quot;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">1</span>, <span class="number">1.1</span>, <span class="number">1</span> + <span class="number">2j</span>, [<span class="number">1</span>, <span class="number">1.1</span>, <span class="number">1.2</span>]]</span><br></pre></td></tr></table></figure>

<p>同字符串类型一样，其也可以用切割操作，此外，其索引取值方式也同字符串类似，列表被截取后返回一个包含所需元素的新列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">1111</span>, <span class="number">1</span> + <span class="number">2j</span>]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>])  <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># 输出第二个至第三个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">2</span>:])  <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(tinylist * <span class="number">2</span>)  <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="built_in">print</span>(list1 + tinylist)  <span class="comment"># 打印组合的列表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;list&#x27;, &#x27;t&#x27;, 2.23, &#x27;john&#x27;, 1111, (1+2j)]</span></span><br><span class="line"><span class="string">list</span></span><br><span class="line"><span class="string">[&#x27;t&#x27;, 2.23]</span></span><br><span class="line"><span class="string">[2.23, &#x27;john&#x27;, 1111, (1+2j)]</span></span><br><span class="line"><span class="string">[123, &#x27;john&#x27;, 123, &#x27;john&#x27;]</span></span><br><span class="line"><span class="string">[&#x27;list&#x27;, &#x27;t&#x27;, 2.23, &#x27;john&#x27;, 1111, (1+2j), 123, &#x27;john&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[9, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>List 内置了有很多方法，例如 append()、pop()。用时再进行查询。</p>
<p>同字符串一样，列表截取可以接收第三个参数，参数作用是截取的步长，如果第三个参数为负数，则表示逆向读取。</p>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是另一个数据类型，类似于 List（列表）。</p>
<p>元组用 <code>()</code>标识。内部元素用逗号隔开。但是元组不能二次赋值，修改元组元素的值，赋完初值后，其就相当于只读列表。</p>
<p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = [<span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="number">2.23</span>, <span class="string">&#x27;john&#x27;</span>, <span class="number">1111</span>, <span class="number">1</span> + <span class="number">2j</span>]</span><br><span class="line">tinytuple = [<span class="number">123</span>, <span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tuple1)  <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">0</span>])  <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># 输出第二个至第三个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">2</span>:])  <span class="comment"># 输出从第三个开始至元组末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(tinytuple * <span class="number">2</span>)  <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span>(tuple1 + tinytuple)  <span class="comment"># 打印组合的元组</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;list&#x27;, &#x27;t&#x27;, 2.23, &#x27;john&#x27;, 1111, (1+2j)]</span></span><br><span class="line"><span class="string">list</span></span><br><span class="line"><span class="string">[&#x27;t&#x27;, 2.23]</span></span><br><span class="line"><span class="string">[2.23, &#x27;john&#x27;, 1111, (1+2j)]</span></span><br><span class="line"><span class="string">[123, &#x27;john&#x27;, 123, &#x27;john&#x27;]</span></span><br><span class="line"><span class="string">[&#x27;list&#x27;, &#x27;t&#x27;, 2.23, &#x27;john&#x27;, 1111, (1+2j), 123, &#x27;john&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">tuple1[<span class="number">2</span>] = <span class="number">0.13</span>    <span class="comment"># 元组中是非法应用</span></span><br><span class="line">list1[<span class="number">2</span>] = <span class="number">1.13</span>     <span class="comment"># 列表中是合法操作</span></span><br></pre></td></tr></table></figure>

<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure>

<p>此外，string、list 和 tuple 都属于 <strong>sequence（序列）</strong>。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<ul>
<li><p>基本功能：成员关系测试、删除重复元素。</p>
</li>
<li><p>创建集合：大括号<code>&#123;&#125;</code>、或是<code>Set()</code>函数</p>
</li>
<li><p>创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
</li>
<li><p>特点：无序的，不支持索引，且元素具有唯一性，一个集合中没有重复元素</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sites = &#123;<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Douban&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>, <span class="string">&#x27;Zhihu&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(sites)   <span class="comment"># 乱序输出集合，重复的元素被自动去掉</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;Runoob&#x27;, &#x27;Baidu&#x27;, &#x27;Taobao&#x27;, &#x27;Google&#x27;, &#x27;Zhihu&#x27;, &#x27;Facebook&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Douban&#x27;</span> <span class="keyword">in</span> sites :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Douban 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Douban 不在集合中&#x27;</span>)   </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Douban 在集合中</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;r&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;d&#x27;, &#x27;b&#x27;, &#x27;r&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;l&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。</p>
<p>两者之间的区别在于：字典当中的元素是通过键来访问存取的，而不是通过下标访问存取，有点类似于java中的Map。</p>
<p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成，用<code>:</code>来区分键和值，<code>1 : 123</code>中，1表示键，123为整型值。</p>
<ul>
<li>键(key)必须使用不可变类型。</li>
<li>在同一个字典中，键(key)必须是唯一的，若插入重复的键，但对应的值改变，则会覆盖原来的键值对。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;This is one&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&quot;This is two&quot;</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;runoob&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">6734</span>, <span class="string">&#x27;dept&#x27;</span>: <span class="string">&#x27;sales&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>]          <span class="comment"># 输出键为&#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dict</span>[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> tinydict             <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">This is one</span></span><br><span class="line"><span class="string">This is two</span></span><br><span class="line"><span class="string">&#123;&#x27;dept&#x27;: &#x27;sales&#x27;, &#x27;code&#x27;: 6734, &#x27;name&#x27;: &#x27;runoob&#x27;&#125;</span></span><br><span class="line"><span class="string">[&#x27;dept&#x27;, &#x27;code&#x27;, &#x27;name&#x27;]</span></span><br><span class="line"><span class="string">[&#x27;sales&#x27;, 6734, &#x27;runoob&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。用时再进行查询。</p>
<p>在 python 中，类型属于对象，变量是没有类型的，如<code>a = 10</code>,<code>10</code>是整型的对象，<code>a</code>是一个变量，若要给<code>a</code>重新赋值，则<code>a=1.1</code>，则其值<code>1.1</code>为浮点型的对象，<code>a</code>依旧是一个变量，没有类型，只是这些对象的引用（一个指针）。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加法</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法或负数</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">两个数相乘或是返回一个被重复若干次的字符串</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除法</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余</td>
</tr>
<tr>
<td align="center">x**y</td>
<td align="center">x的y次幂</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">整除（向下取整），例9//2=4</td>
</tr>
</tbody></table>
<p>注：Python中没有<code>++</code>和<code>--</code>。</p>
<h4 id="位、比较、逻辑运算符"><a href="#位、比较、逻辑运算符" class="headerlink" title="位、比较、逻辑运算符"></a>位、比较、逻辑运算符</h4><p>位、比较、逻辑运算符无不同，与C相同。</p>
<p>比较：<code>==, &lt;=,&gt;=,&lt;,&gt;,!=</code>。</p>
<p>位：<code>&amp;, |, ^(异或), ~(取反), &lt;&lt;, &gt;&gt;</code>。</p>
<p>逻辑：<code>and, or, not</code>。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+=</td>
<td align="center">c += a 等效于 c = c + a</td>
</tr>
<tr>
<td align="center">-=</td>
<td align="center">c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td align="center">*=</td>
<td align="center">c *= a 等效于 c = c * a</td>
</tr>
<tr>
<td align="center">/=</td>
<td align="center">c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td align="center">%=</td>
<td align="center">c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td align="center">**=</td>
<td align="center">c **= a 等效于 c = c ** a</td>
</tr>
<tr>
<td align="center">//=</td>
<td align="center">c //= a 等效于 c = c // a</td>
</tr>
<tr>
<td align="center">:=</td>
<td align="center">海象运算符，可在表达式内部为变量赋值，if (n := len(a)) &gt; 10:</td>
</tr>
</tbody></table>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>成员运算符，顾名思义，就是判断一个元素是不是一个数据结构的成员。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">in</td>
<td align="center">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td align="center">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td align="center">not in</td>
<td align="center">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td align="center">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的存储地址。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">is</td>
<td align="center">is 是判断两个标识符是不是引用自一个对象</td>
<td align="center"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="center">is not</td>
<td align="center">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="center"><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="/2021/09/23/python%E5%AD%A6%E4%B9%A0/cal.jpg"></p>
<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><p>与C语言无太大差别。格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1:</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">elif</span> condition2:</span><br><span class="line">    statement2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement3</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>每个条件后面要使用冒号 <code>:</code>，表示接下来是满足条件后要执行的语句块。</li>
<li>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li>
<li>在Python中没有<code>switch – case</code>语句。</li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition：</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>

<p>while循环使用else语句：</p>
<p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p>
<p>条件语句为 true 则执行 statement语句块，如果为 false，则执行 additional_statement。</p>
<p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while condition:</span><br><span class="line">    statement</span><br><span class="line">else:</span><br><span class="line">    additional_statement</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure>

<p>注：循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。</p>
<h3 id="break、continue和pass"><a href="#break、continue和pass" class="headerlink" title="break、continue和pass"></a>break、continue和pass</h3><p><strong>break</strong> 跳出 for 和 while 的循环体，从当前位置跳出循环，不再进入循环。</p>
<p><strong>continue</strong> 跳过当前循环块中的剩余语句，即不执行循环的剩余部分，然后继续进行下一轮循环。</p>
<p><strong>pass</strong>是空语句，是为了保持程序结构的完整性，不做任何事情，一般用做占位语句。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明</li>
<li>函数内容以冒号 <code>:</code> 起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li>
</ul>
<p>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>

<p>函数调用可直接调用。</p>
<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>当传入参数为不可变对象实例时，在函数内修改形参的值，但不会改变实参的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">change(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">140733572060848</span></span><br><span class="line"><span class="string">140733572060848</span></span><br><span class="line"><span class="string">140733572061136</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当传入参数为可变对象实例时，在函数内修改了形参的值，则实参的值会随着改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">myList</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(myList))</span><br><span class="line">    myList[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(myList))</span><br><span class="line"></span><br><span class="line">myList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(myList))</span><br><span class="line">change(myList)</span><br><span class="line"><span class="built_in">print</span>(myList)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2023267500096</span></span><br><span class="line"><span class="string">2023267500096</span></span><br><span class="line"><span class="string">2023267500096</span></span><br><span class="line"><span class="string">[2, 2, 3, 4, 5]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>可使用的正式参数类型：</p>
<ul>
<li>必需参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<h4 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。就是我们在C语言中传参时须遵守的那些规则。</p>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>​    关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>​    使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params">name, age=<span class="number">35</span></span>):</span></span><br><span class="line">    <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用printinfo函数</span></span><br><span class="line">printinfo(age=<span class="number">50</span>, name=<span class="string">&quot;Tom&quot;</span>)  <span class="comment"># 自动用参数名匹配参数值</span></span><br><span class="line">printinfo(name=<span class="string">&quot;Tom&quot;</span>)  <span class="comment"># 使用默认参数值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">名字:  Tom</span></span><br><span class="line"><span class="string">年龄:  50</span></span><br><span class="line"><span class="string">名字:  Tom</span></span><br><span class="line"><span class="string">年龄:  35</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><ul>
<li><p>加了星号<code>*</code>的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p>
</li>
<li><p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="built_in">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> )</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure></li>
<li><p>加了两个星号 <code>**</code> 的参数会以字典的形式导入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>声明函数时，参数中星号 <code>*</code> 可以单独出现，星号 <code>*</code>后的参数必须用关键字传入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, b, *, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, c=<span class="number">20</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h4><p>Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d, e, f)</span><br><span class="line">    </span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)  <span class="comment"># 正确的传参方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误的传参方式</span></span><br><span class="line">f(<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)   <span class="comment"># b 不能使用关键字参数的形式</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, f=<span class="number">60</span>)           <span class="comment"># e 必须使用关键字参数的形式</span></span><br></pre></td></tr></table></figure>

<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>函数返回值的注意事项: 不同于 C 语言，Python 函数可以返回多个值，多个值以元组的方式返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a,b</span>):</span>    </span><br><span class="line">    <span class="string">&quot;返回多个值，结果以元组形式表示&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a,b,a+b</span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 输出结果为(1, 2, 3)</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul>
<li>使用lambda 来创建匿名函数。</li>
<li>匿名表示：不使用 def 语句这样标准的形式定义一个函数。</li>
<li>lambda 只是一个表达式，函数体比 def 简单很多，只能封装有限的逻辑进去</li>
<li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数</li>
<li>不等同于C或C++的内联函数</li>
</ul>
<p>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>中断处理</title>
    <url>/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="3-中断处理"><a href="#3-中断处理" class="headerlink" title="3. 中断处理"></a>3. 中断处理</h1><h2 id="3-1-中断和异常处理概述"><a href="#3-1-中断和异常处理概述" class="headerlink" title="3.1 中断和异常处理概述"></a>3.1 中断和异常处理概述</h2><p>​    <code>中断和异常</code>是指在系统、处理器或在当前执行的程序或任务的某处出现了一些<code>需要处理器注意并进行处理</code>的<code>事件</code>。 它们通常会导致从当前正在运行的程序或任务强制转移到一个称为<code>中断处理程序</code>或<code>异常处理程序</code>的特殊软件程序或任务(<strong>简单来说：中断和异常会导致处理器转移到中断处理程序或异常处理程序进行处理，再返回到刚才中断或异常处继续执行</strong>)。 处理器响应中断或异常所<code>采取的动作被</code>称为<code>中断/异常服务或处理</code>。<br>​    <strong>中断</strong>在一个程序执行期间内的<strong>任意时间</strong>都有可能发生，以响应<strong>硬件发出的信号</strong>。系统硬件使用中断处理来自处理器外部的事件。比如外围设备的服务请求。软件也可通过执行指令<code>INT n</code>产生中断。<br>​    <strong>异常</strong>则在<strong>处理器执行指令过程中检测到错误条件</strong>才发生，例如除零错误。处理器检测一系列各种类的错误，包括：违反保护机制、页缺失、机器内部故障。Pentium 4、Intel Xeon、P6系列和Pentium处理器的机器检查体系架构会在检测到<strong>内部硬件错误和总线错误</strong>时产生<strong>机器检查异常</strong>。<br>​    当收到一个中断或检测到一个异常时，当前运行的过程或任务会被<strong>挂起直到处理器执行完中断或异常处理程序</strong>。当执行完处理程序，处理器<strong>恢复执行被中断的过程或任务</strong>。恢复被中断的的过程或任务<strong>不会失去程序执行的连续性</strong>，除非<strong>不能从异常中恢复</strong>，或者<strong>中断导致当前运行程序终止</strong>。<br>​    </p>
<h2 id="3-2-有关中断和异常了解性的内容"><a href="#3-2-有关中断和异常了解性的内容" class="headerlink" title="3.2 有关中断和异常了解性的内容"></a>3.2 有关中断和异常了解性的内容</h2><h4 id="3-2-1-中断和异常向量"><a href="#3-2-1-中断和异常向量" class="headerlink" title="3.2.1 中断和异常向量"></a>3.2.1 中断和异常向量</h4><p>​    为了帮助处理异常和中断，处理器为每个需被处理器特殊处理的异常和中断条件都赋予了一个独一无二的标识号，称为向量号。处理器使用赋予给一个异常或中断的<strong>向量号</strong>作为访问<strong>中断描述符表（IDT）</strong>的一个索引。中断描述符表提供了到一个异常或中断处理程序的入口点位置。<br>​    向量号的范围为<code>0</code>到<code>255</code>。其中<code>0</code>到<code>31</code>保留用作n<code>Intel 64</code>和<code>IA-32</code>体系架构处理器的系统架构定义的中断和异常，目前并不是该范围内（<code>0-31</code>）的所有向量号都被定义了功能。未被定义功能的向量号被保留日后使用。<strong>不要使用这些保留的向量号。</strong><br>​    在<code>32</code>到<code>255</code>范围内的所有向量号用于用户定义的中断，而且不保留给<code>Intel 64</code>和<code>IA-32</code>使用。这些中断通常用于外部I/O设备，以确保这些设备可以通过外部硬件中断机制发送中断给处理器。<br>​    表1展示了分配给系统架构定义的异常以及NMI中断的向量号。该表还给出了异常类型以及是否会产生一个错误码并保存在栈上。同时还给出了每个预定义的异常和NMI中断源。<br><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/vector_num.jpg" alt="vector nums"></p>
<center style="color:#1a1a1a;">表1 保护模式下的异常和中断</center>    

<h3 id="3-2-2-中断源和异常源"><a href="#3-2-2-中断源和异常源" class="headerlink" title="3.2.2 中断源和异常源"></a>3.2.2 中断源和异常源</h3><h4 id="3-2-2-1中断源"><a href="#3-2-2-1中断源" class="headerlink" title="3.2.2.1中断源"></a>3.2.2.1中断源</h4><p>​    处理器从两种地方接收中断；</p>
<ul>
<li>外部（硬件产生）中断</li>
<li>软件产生的终端</li>
</ul>
<h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>​    处理器通过处理器上的引脚或本地上的APIC来接收中断。 Pentium 4、Intel Xeon、P6系列和Pentium处理器上的主要的中断引脚是<code>LINT[1:0]</code>引脚，其连接到<strong>本地APIC（高级可编程中断控制器）</strong>。当本地APIC启用时，可以通过<strong>APIC的本地向量表（LVT）</strong>对<code>LINT[1:0]</code>引脚编程，使其与任何处理器的异常或中断向量相关联。<br>​    当本地APIC被全局/硬件禁用，这些引脚分别被配置为<code>INTR</code>和<code>NMI</code>引脚。 当<code>INTR</code>引脚接收到外部发生的中断信号时， 处理器从系统总线上读取由外部中断控制器（例如82590A）提供的中断向量号。 当<code>NMI</code>引脚接收到信号时，会产生一个<strong>不可屏蔽中断（NMI）</strong>，其使用固定的向量号<code>2</code>。<br>​    处理器的<code>本地APIC</code>通常会与基于系统的<code>I/O APIC</code>连接。因而，I/O APIC的引脚所接收到的外部中断信号可以通过系统总线（Pentium 4, Intel Core Duo, Intel Core 2, Intel®Atom™和Intel Xeon处理器）或APIC串行总线（P6家族和Pentium处理器）直接传递给本地APIC。 I/O APIC获得该中断的向量号，然后发送给本地APIC。 当系统中有多个处理器时，处理器之间也可以通过系统总线（Pentium 4、Intel Core Duo、Intel Core 2、Intel Atom、Intel Xeon处理器）或APIC串行总线9P6族和Pentium处理器）相互发送中断信号。<br>​    在Intel486处理器和不包含片上本地APIC的早期Pentium处理器上，<code>LINT[1:0]</code>引脚是不可用的。 这些处理器有专用的<code>NMI</code>和<code>INTR</code>引脚。 对于这些处理器，外部中断通常由基于系统的中断控制器（8259A）产生，通过INTR引脚发送中断信号。<br>​    需注意的是，处理器上的其他几个引脚可能会导致发生处理器中断。 然而，这些中断并不会被本章中描述的中断和异常机制处理。 这些引脚包括<code>RESET#， FLUSH#， STPCLK#， SMI#， R/S#和INIT#</code>引脚。 不是每个处理器都有这些引脚，这却决于处理器的实现。</p>
<h5 id="可屏蔽硬件中断"><a href="#可屏蔽硬件中断" class="headerlink" title="可屏蔽硬件中断"></a>可屏蔽硬件中断</h5><p>​    任何通过<code>INTR</code>引脚或<code>本地APIC</code>接收到的<strong>外部中断</strong>都被称为<strong>可屏蔽硬件中断</strong>。 通过<code>INTR</code>引脚接收到的可屏蔽硬件中断包括<code>IA-32</code>体系结构定义的中断向量号<code>0到255</code>； 通过<code>本地APIC</code>接收到的可屏蔽硬件中断包括中断向量号<code>16到255</code>。</p>
<h5 id="软件产生的中断"><a href="#软件产生的中断" class="headerlink" title="软件产生的中断"></a>软件产生的中断</h5><p>​    <code>INT n</code>指令可通过指定一个中断向量号，在软件中生成中断。 例如，<code>INT 35</code>指令强制隐式调用中断35的中断处理程序进行。<br>​    向量号0到255种的任意一个都可以用作这个指令的中断号。 然而，如果使用处理器预定义的<code>NMI向量</code>，处理器的响应将与正常方式产生的NMI中断不同。 如果在这条指令中指定使用向量号2 （NMI向量），则会调用NMI中断处理程序，但是处理器的NMI处理硬件并不会被激活。<br>​    注意：EFLAGS寄存器中的IF标志位不能屏蔽使用<code>INT n</code>指令从软件中产生的中断。 </p>
<h4 id="3-2-2-2-异常源"><a href="#3-2-2-2-异常源" class="headerlink" title="3.2.2.2 异常源"></a>3.2.2.2 异常源</h4><p>​        处理器从三种来源接收异常；</p>
<ul>
<li>处理器检测到的程序错误异常</li>
<li>软件产生的异常</li>
<li>机器检查异常</li>
</ul>
<h5 id="程序错误异常"><a href="#程序错误异常" class="headerlink" title="程序错误异常"></a>程序错误异常</h5><p>在一个应用程序或操作系统执行期间，如果处理器检测到了程序错误，则会产生一个或多个异常。Intel 64和IA-32架构的处理器为其检测的每个异常都定义了一个向量号。一场可被分为故障、陷阱、中止。</p>
<h5 id="软件产生的异常"><a href="#软件产生的异常" class="headerlink" title="软件产生的异常"></a>软件产生的异常</h5><p>​    <code>INTO、INT 3和BOUND</code>指令可在软件中生成异常。 这些指令可对指令流中指定点执行的特殊异常条件进行检查。 例如，<code>INT 3</code>会产生一个断点异常。<br>​    <code>INT n</code>指令可用于在软件中模拟指定的异常；但也存在限制。 如果<code>INT n</code>指令指定的向量号<code>n</code>是系统架构定义的异常的向量号之一，那么处理器会为该向量号产生一个对应的中断（以访问异常处理程序），但不会把产生的错误码压入栈，因为处理器将其看作为一个中断，而不是异常。 即使与之关联硬件产生的异常通常会产生一个错误码。虽然前面处理器并没有将错误码压入栈，但当处理异常时，异常处理程序仍会尝试将错误码弹出堆栈。因为处理器没有将错误码压入堆栈，而处理程序会把EIP（代正好处于缺失的错误码的位置处）弹栈，从而造成返回位置错误。</p>
<h5 id="机器检查异常"><a href="#机器检查异常" class="headerlink" title="机器检查异常"></a>机器检查异常</h5><p>​    <code>P6系列</code>和<code>Pentium</code>处理器提供内、外部机器检查机制，其检查内部芯片硬件和总线事务的操作。 是否进行机器检查取决于处理器的实现。 当检测到机器检查错误时，处理器产生机器检查异常信号（<code>向量18</code>）并返回错误代码。  </p>
<h3 id="3-2-3-异常的分类"><a href="#3-2-3-异常的分类" class="headerlink" title="3.2.3 异常的分类"></a>3.2.3 异常的分类</h3><p>​    根据<strong>异常的报告方式以及导致异常的指令</strong>是否能在不损害程序或任务执行连贯性的情况下重新启动（简言之，就是重新执行导致异常的指令，并从此继续执行），可以将异常分为<strong>故障（Faults）、陷阱（Traps）或中止（Abort）</strong>。</p>
<ul>
<li> 故障：故障是一种通常<strong>可被纠正</strong>的异常。一旦纠正，程序可以在不丢失程序执行的连贯性情况下继续执行（就是从异常处继续运行）。当报告了一个故障时，处理器会把<strong>机器状态恢复到产生故障的指令执行前的状态</strong>。此时异常处理程序的<strong>返回地址（保存的CS和EIP寄存器的内容）指向产生故障的指令</strong>，而不是其之后的指令。</li>
<li>陷阱：陷阱是一种执行trapping指令后立即报告的异常。陷阱允许程序或任务<strong>继续执行</strong>，而不会丢失程序执行的连贯性。 trap处理程序的返回地址指向在trapping指令之的随后的一条指令。就是从异常指令的后一条指令处继续执行。</li>
<li>中止：中止是这样一种异常，其并不总是报告引起异常的指令的精确位置，并且<strong>不允许异常程序或任务的重新继续执行</strong>。 中止用于报告严重错误，例如硬件错误和系统表中存在不一致性或非法值。  </li>
</ul>
<p>注意：被报告为故障的一个异常子集是不能重新继续程序执行的。 这样的异常会丢失处理器的某些状态信息。 例如，执行POPAD指令会导致堆栈帧越界，从而报告错误。 在这种情况下，异常处理程序会看到指令指针（CS:EIP）已经恢复，就像POPAD指令没有被执行一样。 但是，内部处理器状态（通用寄存器）将被修改。 这种情况被认为是编程错误。 操作系统会终止引起这类异常的应用程序。  </p>
<h3 id="3-2-4-程序或任务的重新执行"><a href="#3-2-4-程序或任务的重新执行" class="headerlink" title="3.2.4 程序或任务的重新执行"></a>3.2.4 程序或任务的重新执行</h3><p>​    为了使得程序或任务在处理完异常或中断后重新恢复执行，所有的异常（<strong>除了中止</strong>）都必须能报告异常指令的精确位置。，并且所有中断必须在指令边界发生上。<br>​    对于<strong>故障类异常</strong>，返回指令的指针（在处理器产生异常时所保存）指向出错的指令。 因此，当程序或任务在处理完故障后重新开始执行时，将<strong>重新启动（重新执行）原来的出错指令</strong>。 重新执行故障指令通常用于<strong>处理访问操作数被阻塞所产生的异常</strong>。 这类故障最常见的例子是<strong>页故障异常（#PF）</strong>，当程序或任务<strong>引用不在内存中的页面上的操作数</strong>时，就会出现页故障异常。 当页面故障异常发生时，异常处理程序可以将该要引用页面加载到内存中，并通过重新执行出错指令来恢复程序或任务的执行。 为了确保重新执行对当前执行程序或任务是透明的（即用户意识不到发生了故障以及进行了处理），处理器会保存必要的寄存器和堆栈指针信息，以使得能返回到执行出错指令之前的状态。<br>​    对于<strong>陷阱类异常</strong>，返回指令的指针指向trapping指令的后一条指令。 如果在一条<strong>控制转移指令的执行期间</strong>检测到一个trap，则<strong>返回指令指针会反映出控制的转移情况</strong>。 例如，如果在执行JMP指令时检测到一个trap，则返回指令的指针会指向JMP指令的目的地址，而不是JMP指令之后一条指令的地址。 所有的陷阱异常都允许程序或任务在不丢失执行连贯性的情况下重新继续执行。 例如，溢出异常是陷阱异常。而返回指令的指针指向<strong>检查EFLAGS.OS（溢出）标志位</strong>的<code>INTO</code>指令的后一条指令。该陷阱异常的处理程序解决溢出情况。 从陷阱类异常处理程序返回后，程序或任务继续执行<code>INTO</code>指令后的指令。<br>​    <strong>中止类异常</strong>不支持可靠地重新执行程序或任务。 中止异常的处理程序通常会在中止异常发生时，<strong>收集有关处理器状态的诊断信息</strong>，然后尽可能优雅地关闭应用程序和系统。<br>​    <strong>中断会严格地支持被中断程序和任务的重新执行而不丢失执行的连贯性</strong>。 中断所保存的返回指令的指针指向处理器获取中断时将要执行的下一条指令边界处。 如果刚执行的指令有一个<code>repeat</code>（重复）前缀，则中断会在<strong>当前迭代结束</strong>，且<strong>寄存器已被设置好以执行下一次迭代</strong>后，才发生。<br>​    P6系列处理器的指令预测执行功能并不会影响处理器的中断。 中断发生在指令执行的<code>retirement</code>阶段的指令边界上；因此，它们总是在“按顺序”的指令流中获取。（这一部分与上一学期所学的计组中“指令级并行”相关）。<br>​      注意：Pentium 处理器和早期的IA-32处理器也执行不同数量的指令预取和初步译码。 对于这些处理器，异常和中断直到指令实际执行时才会发出信号。 对于给定的示例代码，当代码在任何IA-32处理器系列上运行时，异常信号都会发生（除非定义了新的异常或新的操作码）。</p>
<h3 id="3-2-5-不可屏蔽中断（NMI）"><a href="#3-2-5-不可屏蔽中断（NMI）" class="headerlink" title="3.2.5 不可屏蔽中断（NMI）"></a>3.2.5 不可屏蔽中断（NMI）</h3><p>​    不可屏蔽中断（NMI）可通过以下两种方式产生:  </p>
<ul>
<li>NMI引脚接收到外部硬件中断信号</li>
<li>处理器<strong>在NMI传输模式下</strong>在系统总线（Pentium 4、Intel Core Duo、Intel Core 2、Intel Atom和Intel Xeon处理器）或APIC串行总线（P6系列和Pentium处理器）上接收到消息</li>
</ul>
<p>​    当处理器从这两个来源之一收到一个NMI信号时，处理器会立即调用<strong>中断向量号2</strong>所指向的NMI处理程序来处理中断。 处理器也会设置某些硬件条件以确保在NMI处理程序执行完前不会收到其他中断，包括NMI中断。（即，当处理NMI中断时，不会被其他任何中断打断，也就说屏蔽了所有其他中断信号）。<br>​     此外，从上述的任一来源所收到的NMI信号时，其不能被EFLAGS寄存器中的IF标志位给屏蔽。<br>​     也可通过INTR引脚发送一个可屏蔽的硬件中断，且其中断向量号为2来调用NMI中断处理程序；然而，这个中断并不是一个真正的NMI中断。 一个真正的NMI中断必须通过上述两种来源的任一来源所传递，且处理器会激活相关的NMI处理硬件。</p>
<h3 id="3-2-6-开中断和关中断"><a href="#3-2-6-开中断和关中断" class="headerlink" title="3.2.6 开中断和关中断"></a>3.2.6 开中断和关中断</h3><p>​    处理器可以抑制某些中断的产生，这取决于<strong>处理器的状态以及EFLAGS寄存器中的IF和RF标志</strong>。</p>
<h4 id="屏蔽可屏蔽硬件中断"><a href="#屏蔽可屏蔽硬件中断" class="headerlink" title="屏蔽可屏蔽硬件中断"></a>屏蔽可屏蔽硬件中断</h4><p>​    IF标志位可以禁止为处理器INTR引脚或本地APIC收到的<strong>可屏蔽硬件中断</strong>提供服务。 当IF标志复位时，处理器会禁止发送到INTR引脚的中断或通过本地APIC产生的内部中断请求；当设置了IF标志位时，发送到INTR引脚或通过本地APIC的中断会作为正常的外部中断进行处理。<br>​    IF标志位<strong>不会影响</strong>发送到NMI引脚的<strong>不可屏蔽中断（NMI）</strong>，也不会影响在NMI传递模式通过本地APIC传递的消息，也不影响处理器产生的异常。 与EFLAGS寄存器中的其他标志一样，处理器在<strong>响应硬件复位操作</strong>时会复位IF标志位。<br>​    因这组可屏蔽硬件中断包括保留的中断和异常向量号0到32，这潜在地可能会引起混乱。 在架构上，当设置IF标志时，<strong>0到32</strong>内的任一向量号的中断都可<strong>通过INTR引脚</strong>发送到处理器，<strong>16到32</strong>内的任一向量号都可<strong>通过本地APIC</strong>发送。 处理器将产生一个中断，并调用由向量号指向的中断或异常处理程序。 例如，可以通过INTR引脚调用页面故障处理程序（通过向量号14）； 然而，这并不是一个真正的页面故障异常， 它实际是一个中断。 与<code>INT n</code>指令一样，当一个中断通过INTR引脚产生一个异常向量时，处理器不会将错误码压栈，所以异常处理程序可能不能正确执行。<br>​    可以通过<code>STI</code> （set interrupt-enable flag）和<code>CLI</code> （clear interrupt-enable flag）指令设置和复位IF标志。 这些指令只有在CPL等于或小于IOPL时才能执行（即，正在执行的程序的权限足够大）。 当CPL大于IOPL时（数字越大，权限越小），会产生一个一般保护异常（#GP）。<br>​    IF标志也会受到以下操作的影响:  </p>
<ul>
<li><code>PUSHF</code>指令将所有的标志位信息都存储在堆栈上，在栈中，这些标志位的信息可被检查和修改。<code>POPF</code>  指令可用于将被修改过的标志位信息加载回EFLAGS寄存器。 </li>
<li><strong>任务切换</strong>和<code>POPF</code>和<code>IRET</code>指令会加载EFLAGS寄存器； 因此，其可用于修改IF标志的设置。</li>
<li>当通过中断门进行中断处理时，IF标志被自动复位， 其禁止可屏蔽硬件中断。 （如果通过陷阱门处理中断，则IF标志位不会被复位）</li>
</ul>
<h4 id="屏蔽指令断点"><a href="#屏蔽指令断点" class="headerlink" title="屏蔽指令断点"></a>屏蔽指令断点</h4><p>​    EFLAGS寄存器中的RF （resume）标志位控制处理器对指令断点条件的响应。RF=1时，其禁止指令断点生成调试异常（#DB）； RF=0时，指令断点可以生成调试异常。 RF标志的主要功能是防止处理器进入指令断点上的调试异常循环。</p>
<h4 id="任务切换时屏蔽异常和中断"><a href="#任务切换时屏蔽异常和中断" class="headerlink" title="任务切换时屏蔽异常和中断"></a>任务切换时屏蔽异常和中断</h4><p>​    为切换到一个不同的堆栈段，软件通常使用一对指令，例如:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV SS, AX</span><br><span class="line">MOV ESP, Stack Top</span><br></pre></td></tr></table></figure>

<p>​    如果一个中断或异常发生在<strong>段选择符被加载到SS寄存器之后</strong>，但<strong>在ESP寄存器被加载之前</strong>，在中断或异常处理过程中，这两个逻辑地址在堆栈空间中是<strong>不一致</strong>的，。<br>​    为了防止这种情况发送，处理器在<code>MOV</code>到<code>SS</code>指令或<code>POP</code>到<code>SS</code>指令之后，屏蔽中断、调试异常和单步捕获异常，直到执行到下一条指令的指令边界。但这 仍然可能产生其他错误。 如果使用<code>LSS</code>指令修改SS寄存器的内容（推荐以此方法修改该寄存器），则不会发生此问题。 </p>
<h3 id="3-2-7-异常和中断的优先级"><a href="#3-2-7-异常和中断的优先级" class="headerlink" title="3.2.7 异常和中断的优先级"></a>3.2.7 异常和中断的优先级</h3><p>​    如果在一个指令边界上有多个异常或中断等待处理，处理器会按照规定的顺序对它们进行处理。 异常源和中断源的优先级如表2所示。处理器首先处理<strong>最高优先级的异常或中断</strong>，执行转移到异常或中断处理程序的第一条指令。 <strong>低优先级异常会被丢弃</strong>； 而<strong>低优先级的中断被挂起等待</strong>。 当中断处理程序返回到产生异常和/或中断的程序或任务中时，被丢弃的异常会重新产生。  </p>
<table>
<thead>
<tr>
<th>优先级</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>1（最高）</td>
<td align="left">硬件复位（REST）和机器检查</td>
</tr>
<tr>
<td>2</td>
<td align="left">任务切换陷阱、TSS中设置了T标志位</td>
</tr>
<tr>
<td>3</td>
<td align="left">外部硬件介入：FLUSH、STOPCLK、SMI、INIT</td>
</tr>
<tr>
<td>4</td>
<td align="left">前一指令陷阱：断点、调试陷阱异常</td>
</tr>
<tr>
<td>5</td>
<td align="left">不可屏蔽硬件中断</td>
</tr>
<tr>
<td>6</td>
<td align="left">可屏蔽硬件中断</td>
</tr>
<tr>
<td>7</td>
<td align="left">代码断点故障</td>
</tr>
<tr>
<td>8</td>
<td align="left">取下条指令故障：违反代码段限长、代码页故障</td>
</tr>
<tr>
<td>9</td>
<td align="left">下条指令译码故障：指令长度&gt;15字节、无效操作码、协处理器不存在</td>
</tr>
<tr>
<td>10（最低）</td>
<td align="left">执行指令故障：溢出、边界检查、无效TSS、段不存在、堆栈故障、一般报告、数据页故障、对齐检查、浮点错误、虚拟化异常</td>
</tr>
</tbody></table>
<center style="color:#1a1a1a;">表2 异常和中断的优先级</center>    

<h2 id="3-3中断描述符表（IDT）"><a href="#3-3中断描述符表（IDT）" class="headerlink" title="3.3中断描述符表（IDT）"></a>3.3中断描述符表（IDT）</h2><p>​    中断描述符表（IDT）将每个异常或中断向量与用于其对应的<strong>异常或中断处理过程</strong>或<strong>任务的门描述符</strong>关联起来。 与GDT和LDT类似，IDT是由<strong>8字节长的描述符</strong>组成的一个数组（在保护模式下）。 但与GDT不同，IDT的<strong>第一个表项可以包含一个描述符</strong>。 为了构成IDT表中的一个索引值，处理器将异常或中断向量<strong>变大为8倍</strong>（门描述符的字节数）。 因为<strong>最多有256个</strong>中断或异常向量，所以IDT不需要包含多于256个描述符。 IDT表可以包含<strong>少于256个描述符</strong>，因为只有在可能发生的中断和异常时才需要描述符。 但IDT中所有<strong>空描述符项都应该将存在标志位设置为0</strong>。<br>​    IDT表的基址应该在8字节边界上进行对齐，以最大化填充缓存行的性能。限长值以字节为单位，将其基址相加以获得最后一个有效字节的地址。 限长值位0则正好只有1个有效字节。 因为IDT每个表项总是8字节长，所以限长应该总是比8的整数倍（即8N - 1）小1，即[0,8N-1]。<br>​    IDT表可以驻留<strong>在线性地址空间的任何地方</strong>。 如图1所示，处理器通过IDTR寄存器定位IDT表。 该寄存器存储了32位IDT表的基址和16位IDT表限长。  </p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/IDT.jpg"></p>
<center style="color:#1a1a1a;">图1 中断描述符表IDT和寄存器IDTR</center>    

<p>​    <code>LIDT</code>（加载IDT寄存器）和<code>SIDT</code>（存储IDT寄存器）指令分别用于加载和存储IDTR寄存器的内容。 LIDT指令把<strong>存储在内存的基址和限长操作数</strong>加载到IDTR寄存器。 该指令只能在CPL为0时执行，通常被用于创建IDT表时的操作系统的初始化代码中。 操作系统也可以使用该指令从一个IDT变为一个IDT。 SIDT指令将存储在IDTR中的基址和段限长值复制到内存中，这个指令可在任何特权级别下执行。<br>​    如果中断或异常向量引用的描述符超出了IDT界限，则会产生一个通用保护异常（#GP）。<br>​    注意：因为中断只被发送到处理器核心一次，一个配置错误的IDT表可能会导致不完整的中断处理和/或阻塞中断。 在设置IDTR的<code>base/limit/access</code>字段以及<code>gate</code>描述符中的每个字段时，需要遵循IA-32架构规则。 这对Intel 64架构同样适用。 配置包括通过GDT或LDT隐式引用目标代码段和访问堆栈。  </p>
<h2 id="3-4-IDT描述符"><a href="#3-4-IDT描述符" class="headerlink" title="3.4 IDT描述符"></a>3.4 IDT描述符</h2><p>​    IDT 表中可以存放三种类型的门描述符：  </p>
<ul>
<li>中断门（Interrupt-gate descriptor）</li>
<li>陷阱门（Trap-gate descriptor）</li>
<li>任务门（Task-gate descriptor）</li>
</ul>
<p>​    图2展示了任务门、中断门和陷阱门描述符的格式。 在IDT表中任务门的格式和GDT或LDT中任务门格式一致。任务门描述符含有一个用于异常和/或中断处理任务的TSS的段选择符。 中断门和陷阱门与call gate非常相似，它们含有一个长指针（段选择符和偏移量），处理器使用这个长指针将程序执行权转移到代码段中异常或中断的处理过程中。 这些门的不同之处在于处理器操作EFLAGS寄存器中IF标志的方式 。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/gate.jpg"></p>
<center style="color:#1a1a1a;">图2 IDT门描述符</center>    

<h2 id="3-5-中断与异常处理"><a href="#3-5-中断与异常处理" class="headerlink" title="3.5 中断与异常处理"></a>3.5 中断与异常处理</h2><p>​    处理器对异常和中断处理过程的调用，与其使用CALL指令调用一个过程或者任务的方法类似。当响应异常或中断时，处理器首先使用<strong>异常或中断向量</strong>作为到IDT表中对应描述符的<strong>索引</strong>。如果该索引指向的是<strong>陷阱门或者中断门</strong>，则处理器<strong>调用异常或中断处理程序的方式与使用CALL指令调用一个调用门的方式类似</strong>。如果是索引指向的是一个<strong>任务门</strong>，处理器进行<strong>任务切换，切换到异常处理程序或中断处理程序任务</strong>，其<strong>调用方式与使用CALL指令调用一个任务门的方式类似</strong>。</p>
<h3 id="3-5-1-异常或中断处理程序"><a href="#3-5-1-异常或中断处理程序" class="headerlink" title="3.5.1 异常或中断处理程序"></a>3.5.1 异常或中断处理程序</h3><p>​    异常或中断门引用运行在当前任务上下文中的异常或中断处理过程，如图3所示 。 门的段选择符指向GDT或当前LDT中可执行代码段的段描述符。 门描述符的偏移量字段指向异常或中断处理过程的开始处。  </p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/Interupt_handle.jpg"></p>
<center style="color:#1a1a1a;">图3 中断过程调用</center>    

<p>​    当处理器执行异常或中断处理过程调用时会进行以下操作：</p>
<ul>
<li>如果处理过程将在一个数值更小（权限更大）的权限级别执行时，会发生堆栈的切换。堆栈切换时会发生如下操作：<ol>
<li>处理器从当前执行任务的TSS中获取中断或异常处理过程使用的堆栈的段选择符和栈指针。然后将被中断过程的堆栈段选择符和栈指针压入新栈。</li>
<li> 处理器将EFLAGS、CS、EIP寄存器的当前状态信息保存到新栈。（如图4所示）</li>
<li>如果异常会产生一个错误码，那么该错误码在压入EIP值之后被压入新栈。</li>
</ol>
</li>
<li>如果处理过程将在与被中断过程相同的权限级别执行时：<ol>
<li>处理器将EFLAGS、CS、EIP寄存器的当前状态信息保存到当前栈。</li>
<li>如果异常会产生一个错误码，那么该错误码在压入EIP值之后被压入当前栈。</li>
</ol>
</li>
</ul>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/stack_switch.jpg"></p>
<center style="color:#1a1a1a;">图4  转移到中断处理过程时堆栈的使用</center>    

<p>​    要从异常或中断处理程序过程返回时，处理程序必须使用IRET（或IRETD）指令。 IRET指令与RET指令类似，区别在于其<strong>将保存的标志位信息恢复到EFLAGS寄存器中</strong>。<strong>只有当CPL值为0时</strong>，才会<strong>恢复EFLAGS寄存器的IOPL字段</strong>。 只有当<strong>CPL小于等于IOPL</strong>时，<strong>IF标志才会改变</strong>。<br>​    如果在调用处理程序过程时发生了堆栈切换，IRET指令在返回时切换回被中断的过程的堆栈。</p>
<h4 id="异常和中断处理程序的保护机制"><a href="#异常和中断处理程序的保护机制" class="headerlink" title="异常和中断处理程序的保护机制"></a>异常和中断处理程序的保护机制</h4><p>​    <strong>异常和中断处理程序的特权级别保护方式</strong>与通过<strong>调用门调用普通过程时所使用的特权级别保护</strong>的方式类似。 处理器不允许把执行控制流转移到比<strong>CPL特权更小</strong>的代码段（数值上更大，权限小）中的异常或中断处理过程，否则将产生一个一般保护性异常 （#GP）。异常处理程序和中断处理程序的保护机制在以下方面有所不同:  </p>
<ul>
<li>因为中断和异常向量没有RPL，因此在隐式调用异常和中断处理过程时不会检查 RPL。  </li>
<li>处理器只对<code>INT n</code>、<code>INT 3</code>或<code>INTO</code>指令产生的异常或中断才进行中断门或陷阱门的DPL的检查。其<strong>CPL必须小于或等于门的DPL</strong>。 这一约束阻止了在特权级别3上运行的应用程序或过程使用软件中断来访问重要的异常处理程序，比如页面故障处理程序，前提是这些处理程序位于<strong>更高特权的代码段</strong>中（数字更小）。 对于硬件产生的中断和处理器检测到的异常，处理器<strong>忽略中断门和陷阱门中的DPL</strong>。</li>
</ul>
<p>​    因为异常和中断通常可能在任意时间发生，所以这些有关特权级别的规则有效地加强了异常和中断处理过程能够运行的特权级的限制。我们可以利用以下技术之一来避免违反特权级保护：  </p>
<ul>
<li>异常或中断处理程序可以存放在一个一致性的代码段内。 这种技术可用于只需要访问堆栈上的数据的处理程序（例如，除出错异常）。如果处理程序需要访问数据段中的数据，那么必须以特权级 3 访问该数据段，但这样一来保护机制就失效了。</li>
<li>异常或中断处理程序存放在一个非一致性且特权级别0的代码段内。这样一来处理程序总可以运行，而不管被中断程序或任务的当前特权级 CPL。</li>
</ul>
<h4 id="异常或中断处理程序标志位的使用"><a href="#异常或中断处理程序标志位的使用" class="headerlink" title="异常或中断处理程序标志位的使用"></a>异常或中断处理程序标志位的使用</h4><p>​    当通过一个中断门或一个陷阱门访问异常或中断处理程序时，处理器在把<strong>EFLAGS寄存器中的内容保存到堆栈上</strong>后，<strong>复位EFLAGS寄存器中的TF标志位</strong> （在调用异常和中断处理程序时，处理器还会将EFLAGS寄存器中VM、RF和NT标志位的信息保存在堆栈中，然后复位这些标志位）。 <strong>清除TF标志可以防止指令跟踪影响中断响应</strong>。 而随后的IRET指令会使用保存在堆栈上的EFLAGS寄存器内容中的值恢复TF（以及VM、RF和NT）标志位。<br>​    <strong>中断门和陷阱门</strong>之间的<strong>唯一区别</strong>在于处理器在EFLAGS寄存器中处理IF标志位的方式。 当通过<strong>中断门</strong>访问一个异常或中断处理过程时，处理器<strong>复位IF标志</strong>以防止其他中断干扰当前的中断处理程序。 随后的IRET指令使用保存在堆栈上的EFLAGS寄存器的值<strong>恢复IF标志位</strong>。 通过<strong>陷阱门</strong>访问处理程序过程<strong>不影响IF标志位</strong>。  </p>
<h3 id="3-5-2-中断任务"><a href="#3-5-2-中断任务" class="headerlink" title="3.5.2 中断任务"></a>3.5.2 中断任务</h3><p>​    当通过IDT表中的任务门来访问一个异常或中断处理程序时，就会发生一个任务切换。 用一个单独的任务处理异常或中断有以下几个优点：</p>
<ul>
<li>被中断的程序或任务的完整上下文会被自动保存</li>
<li>在处理异常或中断时，一个新的TSS允许处理程序使用新特权级别0的堆栈。如果当前的特权级别0的堆栈被损毁，导致产生了异常或中断时，可通过任务门访问处理程序，从而为处理程序提供新的特权级别0的堆栈来防止系统崩溃。 </li>
<li>通过使用单独的IDT给中断或异常处理任务分配一个单独的地址空间，可进一步将其与其他任务隔离开。 </li>
</ul>
<p>​    但是使用单独的任务处理中断的缺点是：进行任务切换需要<strong>保存大量的机器状态</strong>，远多于使用中断门，导致其响应速度要比中断门慢，从而<strong>增加了中断延时</strong>。<br>​    使用IDT中的任务门引用GDT中的TSS描述符的过程，如图5所示。 切换到处理任务的过程与普通任务切换的过程相同。 返回到被中断任务的链接被存储在<strong>处理任务的TSS段的前一个任务链接字段</strong>中。 如果异常导致产生错误码，则将该错误码复制到新任务的堆栈中。</p>
<p><img src="/2022/04/10/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/task.jpg"></p>
<center style="color:#1a1a1a;">图5  中断任务切换</center>    

<p>​     当在操作系统中使用异常或中断处理任务时，实际上有两种机制可用于任务调度：<strong>软件调度（操作系统的一部分）</strong>和<strong>硬件调度（处理器中断机制的一部分）</strong>。使用软件调度方法时则考虑到开启中断时，需要采用中断处理任务。            </p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>中断</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>x86系统架构概览</title>
    <url>/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-x86系统架构概览"><a href="#1-x86系统架构概览" class="headerlink" title="1. x86系统架构概览"></a>1. x86系统架构概览</h1><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>先对几个概念进行说明：</p>
<p>​    IA-32：Intel Architecture 32-bit简称，即英特尔32位体系架构，在英特尔公司1985年推出的80386微处理器中首先采用。IA-32属于X86体系结构的32位版本（X86-32），即具有32位内存地址和32位数据操作数的处理器体系结构，从1985年面世的80386直到Pentium，都是使用IA-32体系结构的处理器。而现在Intel把32位x86架构的名称x86-32改称为IA-32。而x86则是Intel开发的一类处理器体系结构的泛称，包括 Intel 8086、80286、i386和i486等，因此其架构称为“x86”。</p>
<p>​    Intel 64：Intel 64-bit的简称，64位这个概念最早是由AMD首先提出，提出了一个兼容IA-32指令集的64位版本，其 扩充了指令及寄存器长度和个数等，更新了参数传送方式，AMD称其为AMD 64，Intel称其为Intl 64（不同于IA-64），其被命名为“x86-64” ，有时也简称为x64。。</p>
<h2 id="1-1系统级体系结构概览"><a href="#1-1系统级体系结构概览" class="headerlink" title="1.1系统级体系结构概览"></a>1.1系统级体系结构概览</h2><h3 id="系统级体系结构的组成"><a href="#系统级体系结构的组成" class="headerlink" title="系统级体系结构的组成"></a>系统级体系结构的组成</h3><p>​    系统级体系结构是由一组寄存器、数据结构、指令组成。这里的指令是指被设计用于支持系统级操作的指令，例如：内存管理、中断、异常处理、任务管理、多线程控制等系统级操作。<br>​    下图概述了适用于32位模式下的系统寄存器和数据结构。  </p>
<p><img src="/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/overview.jpg"></p>
<center style="color:#1a1a1a;">图1 IA-32系统级寄存器和数据结构</center>

<p><img src="/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/overview2.jpg"></p>
<center style="color:#1a1a1a;">图2 IA-32e模式下系统级寄存器和数据结构</center>

<h3 id="全局和局部描述符表-Global-and-Local-Descriptor-Tables"><a href="#全局和局部描述符表-Global-and-Local-Descriptor-Tables" class="headerlink" title="全局和局部描述符表(Global and Local Descriptor Tables)"></a>全局和局部描述符表(Global and Local Descriptor Tables)</h3><p>​    当在<strong>保护模式</strong>下运行时，所有的<strong>内存访问</strong>操作必须都通过<strong>全局描述表(GDT)<strong>，或者一个</strong>可选的本地描述符表(LDT)<strong>来完成。如图1所示。这些表包含</strong>一些条目的描述符，如段(segment)<strong>。</strong>段描述符</strong>负责提供<strong>段的基址</strong>，访问权限、类型和该段的用途等信息。那不禁让人疑惑为什么要这样做？</p>
<p>​    传统的实地址模式下的汇编中，利用<code>CS:IP</code>来访问内存，<code>CS</code>左移四位加<code>IP</code>获得物理地址，但是通常不需要关心基地址，只需要偏移地址即可访问内存，因为实地址模式的基地址通常是固定的。但是在保护模式下，为了达到保护内存的目的，就需要让不同程序有不同的基地址（基地址如果固定，那么很容易就被他人直到程序的运行位置，很不安全）。所以，在保护模式下，内存是一段一段分配的，分配的那一段内存头地址就是基地址，也称段地址。同时，操作系统也需要记录分配出去的每一段内存，实际上，每段内存都使用一个8字节的段描述符记录着，所有的这些段描述符被放在一块连续内存空间中存储着，称为描述符表。<br>（参考：<a href="https://blog.csdn.net/sinat_35261315/article/details/78479523%EF%BC%89">https://blog.csdn.net/sinat_35261315/article/details/78479523）</a></p>
<p>​    每个段描述符都有一个与之关联的<strong>段选择子</strong>。一个<strong>段选择子</strong>为使用它的软件提供了一个GDT或LDT的<strong>索引</strong>（它所关联段的段描述符的<code>偏移量</code>）, 同时为指明段选择子指向的GDT还是LDT，其提供了一个<code>全局/局部标志</code>（global/local flag），此外还提供了程序对该段的访问权限信息。<br>​    若要访问一个段中的一个字节，则必须要有该段选择子和一个偏移信息。该段选择子提供访问该段的段描述符（在GDT或LDT）中。处理器可从段描述符中获得线性地址空间中该段的基址。然后偏移量则提供了这一字节相对于基址的位置。这一机制可用于访问任一有效代码、数据或堆栈段，但其前提是在处理器运行的当前特权级别（CPL，Current Privilege Level）下，这些段是可访问。<code>CPL</code>定义是指当前执行的代码段的保护级别。<br>​    看图1，图中的是实线箭头指示了线性地址，虚线指示了一个段选择子，而虚线箭头则指示了一个物理地址。为了简单起见，许多段选择子表示为指向段的直接指针。 然而，实际上段选择子并不是直接指向所关联的段，而是通过<code>GDT或LDT</code>。<br>​    GDT的线性地址的基址存储在<code>GDT寄存器（GDTR）</code>中; LDT的线性地址的基址存储在<code>LDT寄存器（LDTR）</code>中。</p>
<p>​    针对这里的<strong>线性地址</strong>说明：我们已在操作系统中学习了<code>逻辑地址</code>（logical address），<code>逻辑地址</code>就是段基址加上段内偏移，将逻辑地址合成以后的地址称为<code>线性地址</code>（linear  address）。如果没有分页，<code>线性地址</code>就是最终的<code>物理地址</code>，而如果有分页的存在，则还需要经过分页机制的翻译才能得到最终的物理地址。</p>
<p>​    总结：每个段都在GDT或LDT中存放了一个段描述符，同时对于每个段描述符，还有一个相关联的段选择子。如果访问内存的某一字节，要先获得这一字节所处段所关联的段选择子，通过这个段选择子到GDT或LDT找到该段的段描述符（具体过程：GDTR或LDTR提供GDT或LDT<code>基址</code>，段选择子提供该段在GDT或LDT中的<code>偏移</code>，相加得到该段描述符在GDT或LDT中的地址，然后就可获得段描述符），通过段描述符获得该段的基址，然后还需要获得该字节在相对于该基址的偏移量或者说相对地址，二者相加，就获得了该字节的实际地址，可访问该字节。</p>
<p>​    补充：全局描述符表（GDT）是 Intel x86 系列处理器（从 80286 开始）所使用的一种数据结构，目的是为了在程序运行期间划分具有不同属性的内存区域，比如：可以运行、可写入等区域的起始地址与访问权限。这些区域被称作段。<br>​    全局描述符表除了可以保存<code>段信息</code>外还可以保存其它信息。全局描述符表中的每个表项（描述子）长度为  8-byte，全局描述符表的选择子可以为：任务状态描述子（TSS）、本地描述符表描述子或者调用门描述子。调用门在 x86  不同特权级中转移控制权非常重要，但是现在的操作系统很少使用这种机制。<br>​    同时存在的还有局部描述符表（LDT）。局部描述符表用来存储程序内部的段信息，而全局描述符表用来描述全局的段信息。x86 系列的处理器具有一种机制，可以在发生某些事件时自动切换局部描述符表，但是针对全局描述符表却没有这样的机制。<br>​    程序如果想访问某个段，需要在全局描述符表或者局部描述符表中找到该段对应的索引。这个索引被称为段选择子。为了使用相应的段，段选择子必须被首先加载到段寄存器。除了可以通过机器指令读取或者设置全局描述符表（还有中断描述符表）的内存地址外，指令所引用的内存地址存在于一个隐式的段，有时有两个。大部分情况下，默认的段寄存器可以通过在地址前面加一个段地址来替换。加载段选择子到段寄存器的过程中，程序会自动读取全局描述符表或者局部描述符表，并将相关信息保存到处理器中。在全局描述符表或者局部描述符表被加载后，对二者的修改并不会起作用，除非重新将相应的表加载到寄存器。<br>（来源:<a href="https://www.cnblogs.com/Proteas/archive/2010/11/28/2335682.html%EF%BC%89">https://www.cnblogs.com/Proteas/archive/2010/11/28/2335682.html）</a></p>
<h4 id="IA—32e下的全局和局部描述符表-Global-and-Local-Descriptor-Tables-in-IA-32e-Mode"><a href="#IA—32e下的全局和局部描述符表-Global-and-Local-Descriptor-Tables-in-IA-32e-Mode" class="headerlink" title="IA—32e下的全局和局部描述符表(Global and Local Descriptor Tables in IA-32e Mode)"></a>IA—32e下的全局和局部描述符表(Global and Local Descriptor Tables in IA-32e Mode)</h4><p>​    在IA-32e的子模式(64位模式和兼容模式)下，GDTR和LDTR寄存器都扩展到了64位。 若要了解更多信息。<br>​    全局和局部描述符表被拓展至64位以支持64位基址（大小为16字节的LDT描述符保存了64位的基址和各种属性）。 需注意的是在兼容模式下，描述符将不会被拓展。  </p>
<h3 id="系统段，段描述符，门-System-Segments-Segment-Descriptors-and-Gates"><a href="#系统段，段描述符，门-System-Segments-Segment-Descriptors-and-Gates" class="headerlink" title="系统段，段描述符，门(System Segments, Segment Descriptors, and Gates)"></a>系统段，段描述符，门(System Segments, Segment Descriptors, and Gates)</h3><p>​    除了代码、数据、堆栈段，其组成了一个程序的运行环境外，该体系结构还定义了两个系统段：<code>任务状态段</code>（the task-state segment–TSS）和<code>LDT</code>。GDT因其不能通过段选择子和段描述符的方式访问，从而不被看作是一个段。TSSs和LDTs都有为其定义的段描述符。<br>​    该体系结构也定义了一组特殊的<code>描述符</code>，可以称为<code>门（调用门、中断门、陷阱门、任务门）</code>。这些门为系统程序提供了保护，以致其可以在与大多数应用程序不同的权限级别上运行。简而言之，门提供了一种机制——跨权限级别的访问。例如，通过调用门的一次调用，能以比当前的代码段所需的更低权限数值（意味着更大的权限）访问代码段中的一个程序。要通过<code>调用门</code>调用一个程序，调用者需要提供当前<code>调用门</code>的<code>段选择子</code>，然后，处理器获得该调用门<code>权限级别</code>、以及该调用门指向的目的代码段的权限级别，然后与CPL比较，对该调用门执行其访问权限的检查。（总共有4个权限级别，分别为0，1，2，3，数字越小权限越大），从而可以理解上面更低权限数值。<br>​    如果允许访问目的代码段，处理器获得目的代码段的<code>段选择子</code>，以及从调用门到该代码段的<code>偏移量</code>。如果此次调用需要更改权限级别，处理器则会切换到<code>堆栈</code>以获取<code>目标特权级别</code>。 然后从当前运行的任务的TSS中获得新堆栈的段选择子。 门还促进了16位和32位代码段之间的转换，反之亦然。  </p>
<p>​    补充：门描述符并不描述某种内存段，而是描述控制转移的入口点，也就是目标代码的门。通过这种门可以实现<code>特权级的转变和任务的切换</code>。门描述符主要由两部分组成：<code>选择子</code>、<code>偏移地址</code>以及<code>DPL</code>。<br>（来源于<a href="http://blog.chinaunix.net/uid-12276369-id-2952355.html%EF%BC%89">http://blog.chinaunix.net/uid-12276369-id-2952355.html）</a></p>
<ul>
<li><p> 调用门一般用于<code>特权级别的切换</code>，存在于GDT中或者LDT中。调用门的选择子指向<code>代码段描述符</code>，偏移地址对应代码段中的<code>偏移量</code>。当jump和call指令的操作对象是调用门的时候，就会跳转到对应的代码处，并更改特权级别，也就会发生堆栈的切换。</p>
</li>
<li><p>任务门一般用在<code>任务的切换</code>，可以存放在GDT、LDT或IDT中。任务门的选择子指向GDT中的TSS选择符，而其偏移地址没有意义。当Jmp和Call指令的操作数是任务门的时候，就会发生任务的切换。</p>
</li>
<li><p> 中断门和陷阱门描述符是<code>中断处理程序的入口</code>，存在于IDT中。中断门和陷阱门的选择子指向代码段选择符，偏移地址是代码段中中断处理程序的入口地址。</p>
</li>
</ul>
<h4 id="IA-32e模式下的门-Gates-in-IA-32e-Mode"><a href="#IA-32e模式下的门-Gates-in-IA-32e-Mode" class="headerlink" title="IA-32e模式下的门(Gates in IA-32e Mode)"></a>IA-32e模式下的门(Gates in IA-32e Mode)</h4><p>​    在IA-32e模式下，以下描述符是16字节的描述符(扩展以支持64位基地址):</p>
<ul>
<li>LDT描述符</li>
<li>64位TSSs</li>
<li>调用门</li>
<li>中断门</li>
<li>陷阱门</li>
<li>调用门  </li>
</ul>
<p>​    调用门促进了64位模式和兼容模式之间的转换。 IA-32e模式下不支持任务门。 在特权级别改变时，其不会从TSS读取堆栈段选择子。 相反，它们被设置为NULL。</p>
<h3 id="任务状态段和任务门-Task-State-Segments-and-Task-Gates"><a href="#任务状态段和任务门-Task-State-Segments-and-Task-Gates" class="headerlink" title="任务状态段和任务门(Task-State Segments and Task Gates)"></a>任务状态段和任务门(Task-State Segments and Task Gates)</h3><p>​    <code>TSS（任务状态段）</code>定义了任务的执行环境的状态。其包括以下几个部分：<code>通用寄存器，段寄存器，EFLAGS寄存器，EIP寄存器，3个堆栈段对应的段选择子</code>（每个权限级别都对应有一个堆栈，如果有三个权限级别：1，2，3，则会有3个栈分别对应每个权限级别）。TSS也包含了该任务的LDT的段选择子和页目录表的基地址的信息。<br>​    在保护模式下，系统中的每个程序都运行在一个任务（称为当前任务）的<code>上下文</code>中。而当前任务的TSS的段选择子存储在任务寄存器中。切换到一个任务的最简单方法就是调用或跳转到新任务。这个新任务的TSS段选择子由此次CALL或JMP指令给出。当切换任务的时候，处理器完成的几个步骤：</p>
<ol>
<li>将当前任务的状态信息存储到当前TSS中;</li>
<li>将新任务的段选择子加载到任务寄存器中;</li>
<li>通过GDT中的段描述子访问新TSS;</li>
<li>从新TSS中加载新任务的状态信息至通用寄存器、段寄存器、LDTR、控制寄存器CR3(页目录表的基地址)、EFLAGS寄存器和EIP寄存器；</li>
<li>开始执行新任务</li>
</ol>
<p>​     一个任务可通过任务门访问。任务门类似于调用门，唯一不同的是其访问的是TSS而不一个代码段。</p>
<p>​    关于上下文的补充：上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，他的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。（来源于CSAPP-P508）</p>
<h4 id="IA-32e模式下的任务状态段TSS-Task-State-Segments-in-IA-32e-Mode"><a href="#IA-32e模式下的任务状态段TSS-Task-State-Segments-in-IA-32e-Mode" class="headerlink" title="IA-32e模式下的任务状态段TSS(Task-State Segments in IA-32e Mode)"></a>IA-32e模式下的任务状态段TSS(Task-State Segments in IA-32e Mode)</h4><p>​    IA-32e模式并不支持硬件实现任务交换。然而，TSS依然存在。一个TSS的基址由其段描述符指明。<br>​    一个64位的RSS保存以下对64位操作很重要的信息：</p>
<ul>
<li>每个权限级别对应的堆栈指针地址</li>
<li>中断堆栈表的指针地址  </li>
<li>IO权限位图的偏移地址（以TSS为基地址）</li>
</ul>
<p>​    IA-32e模式任务寄存器也被拓展64位以致能保存64位基地址。可参见7.7节“64位模式下的任务管理”。  </p>
<h3 id="中断和异常处理-Interrupt-and-Exception-Handling"><a href="#中断和异常处理-Interrupt-and-Exception-Handling" class="headerlink" title="中断和异常处理(Interrupt and Exception Handling)"></a>中断和异常处理(Interrupt and Exception Handling)</h3><p>​    外部中断、软件中断以及异常通过<code>中断描述表(interrupt descriptor table--IDT)</code>处理。IDT存储了存储一组门描述符，其提供了对中断和异常处理程序的访问。同GDT一般，IDT也不是一个段。IDT线性地址的基地址存储在<code>IDT寄存器中（IDTR）</code>。<br>​    IDT的门描述符可以是中断、陷阱、任务门描述符。为访问一个<code>中断或异常处理程序</code>，处理器首先会从内部硬件、外部中断控制器或通过软件发出INT、INTO、INT 3或BOUND等指令接收中断向量（中断号）。中断向量提供了访问IDT的索引。如果被选中的门描述符是一个中断门或陷阱们，则其访问对应处理程序的过程就类似于通过一个调用门（call gate）来调用一个程序。如果描述符是一个任务门，则通过切换任务来访问处理程序。</p>
<h4 id="IA-32e模式下中断和异常处理-Interrupt-and-Exception-Handling-IA-32e-Mode"><a href="#IA-32e模式下中断和异常处理-Interrupt-and-Exception-Handling-IA-32e-Mode" class="headerlink" title="IA-32e模式下中断和异常处理(Interrupt and Exception Handling IA-32e Mode  )"></a>IA-32e模式下中断和异常处理(Interrupt and Exception Handling IA-32e Mode  )</h4><p>​    在IA-32e模式下，中断描述符被拓展到16字节以至于支持64位及地址。对于64位模式和兼容模式非常重要。<br>​    IDTR寄存器被扩展以致保存64位的基址。但不支持任务门。  </p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>​    系统体系结构支持内存的直接物理寻址或虚拟内存(通过分页机制)。当使用物理寻址时，线性地址就被是为实际物理地址。当通过<code>分页机制</code>寻址时，所有的代码、数据、系统段（包括GDT、IDT）所有代码、数据、堆栈和系统段（包括GDT和IDT）都可以进行分页寻址，只有最近访问的页面被保存在物理内存中。<br>​    <code>页（也被称为页帧）</code>在物理内存中的位置储存在在页目录表中。这些结构驻留在物理内存中。<br>​    控制寄存器CR3存储了页目录表物理地址的基址。页目录表中的条目指明了各页框物理地址的基址、访问权限和内存管理信息。<br>​    为使用分页机制，将连续的线性地址分为多个零碎的部分。每一部分为页目录表和页框提供其不同的偏移量。 一个系统可以有一个或多个页目录表。 例如，每个任务可以有自己的页目录表。<br>内存管理分为2种情况，<code>分段</code>或<code>分段+分页</code>。内存管理一定会进行分段，而分页则偏向于一种程序，可选的虚拟映射，由OS来指定是否需要开启的。</p>
<h4 id="IA-32e模式下的内存管理"><a href="#IA-32e模式下的内存管理" class="headerlink" title="IA-32e模式下的内存管理"></a>IA-32e模式下的内存管理</h4><p>​    在IA-32e模式下，使用一组系统数据结构堆物理内存页进行管理。在兼容模式下和64位模式下，系统数据结构分为四级，其包含：</p>
<ul>
<li> 四级页面映射表(The page map level 4 ——PML4)：四级页面映射表中的一个表项存储了一个页目录指针表物理地址的基址、访问权限和内存管理信息。 PML4物理地址的基址则存储在CR3中。</li>
<li>一组页目录指针表（A set of page directory pointer tables  ）：  页目录指针表中的一个表项存储了一个页目录表物理地址的基址、访问权限以及内存管理信息。</li>
<li>一组页目录表（Sets of page directories ）：页目录表中的一个表项存储了一个页表物理地址的基址、访问权限以及内存管理信息。</li>
<li>一组页表（Sets of page tables）：页表一个表项存储了一个页框物理地址的基址、访问权限以及内存管理信息。</li>
</ul>
<h3 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h3><p>​    为了帮助初始化处理器和控制系统操作，系统架构在EFLAGS寄存器和几个系统寄存器中提供了<code>系统标志位</code>：  </p>
<ul>
<li>EFLAGS寄存器的系统标志和IOPL字段控制任务和模式切换、中断处理、指令跟踪、访问权限中。 </li>
<li>控制寄存器(CR0、CR2、CR3和CR4)包含用于控制系统级操作的各种标志和数据字段。 这些寄存器中的其他标志用于指示某些特殊处理器功能对操作系统或执行程序的支持与否。   </li>
<li>调试寄存器(在图1中没有显示)则允许设置调试程序和系统软件所用的断点。 </li>
<li>GDTR、LDTR和IDTR寄存器包含各自表的线性地址和大小（限长）。 </li>
<li>任务寄存器包含当前任务的TSS的线性地址和大小。</li>
<li>任务寄存器包含当前任务的TSS的线性地址和大小。  </li>
<li>特殊模块寄存器(图1中没有显示)  。</li>
</ul>
<p>​    <code>特殊模块寄存器(MSRs)</code>是一组主要供操作系统或执行过程使用的寄存器（即在特权级别0上运行的代码，我们前面也提到数字越小，权限级别越高）。这些寄存器控制诸如调试扩展、性能监视计数器、机器检查体系和内存类型范围(MTRRs)等几项工作。在Intel 64和IA-32架构的处理器，这些寄存器的数量和功能中并不相同。 大多数系统都限制应用程序访问除EFLAGS寄存器外的系统寄存器。 然而，当程序运行在最高特权级别（特权级别0）时，应用程序将被允许修改系统寄存器。</p>
<h4 id="IA-32e模式下的系统寄存器"><a href="#IA-32e模式下的系统寄存器" class="headerlink" title="IA-32e模式下的系统寄存器"></a>IA-32e模式下的系统寄存器</h4><p>​    在IA-32e模式下，四个系统描述表寄存器（GDTR、IDTR、LDTR和TR）硬件上扩展至能储存64位基址。EFLAGS寄存器拓展至64位RFLAGS寄存器。 CR0-CR4扩展为64位。 CR8也变为可用。 CR8提供对任务优先级寄存器（TPR）的读写访问，如此一来，操作系统就可以控制外部中断类别的优先级。<br>​    在64位模式下，调试寄存器DR0-DR7变为64位。在兼容模式下，DR0-DR3中执行64位地址匹配。<br>​    在支持IA-32e模式的系统上，扩展特性确保寄存器（IA32_EFER）可以使用。 这个特殊模块寄存器控制激活IA-32e模式和其他IA-32e模式操作。此外，还有几个特殊模块寄存器来管理IA-32e模式指令 ：</p>
<ul>
<li>IA32_KernelGSbase ：管理SWAPGS指令 </li>
<li>IA32_LSTAR ：管理SYSCALL 指令  </li>
<li>IA32_SYSCALL_FLAG_MASK  ：管理SYSCALL 指令</li>
<li>IA32_STAR_CS  ：管理SYSCALL 和 SYSRET   指令</li>
</ul>
<h3 id="其他系统资源-Other-System-Resources"><a href="#其他系统资源-Other-System-Resources" class="headerlink" title="其他系统资源(Other System Resources)"></a>其他系统资源(Other System Resources)</h3><p>​    除了前面章节中描述的系统寄存器和数据结构之外，系统架构还提供了以下额外的资源:  </p>
<ul>
<li>操作系统说明</li>
<li>性能监控计数器（图1中未显示）</li>
<li>内部缓存和缓冲区（图1中未显示）</li>
</ul>
<p>​    性能监视计数器是事件计数器，可以通过编程来计数处理器处理事件，比如解码的指令数、接收到的中断数或缓存负载数。<br>​    处理器提供几个内部缓存和缓冲区。高速缓存用于存储数据和指令。 缓冲区用于存储，其存储，譬如：解码后的地址到系统和应用程序段，以及等待执行的写操作。 </p>
<h2 id="1-2-实模式和保护模式转换"><a href="#1-2-实模式和保护模式转换" class="headerlink" title="1.2  实模式和保护模式转换"></a>1.2  实模式和保护模式转换</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p> IA-32支持三种<code>工作模式和</code>一种<code>准工作模式</code>：（这些模式都是CPU的工作模式，而CPU的工作模式是指CPU的寻址方式、寄存器大小等用来反应CPU在该环境下如何工作的概念。）</p>
<ul>
<li><p>保护模式（Protected mode）：处理器原生支持的模式。在这个模式下运行，能体现处理器丰富的体系结构特性与功能，且处理器能以高灵活性、高性能运行，还提供对现有软件的向后兼容性。电脑运行的99.99%时间，处理器都是工作在保护模式下。在保护模式中，内存的管理模式分为两种——段模式和页模式。其中页模式也是基于段模式的。也就是说，保护模式的内存管理模式是：仅段模式或段页式。进一步说，段模式是必不可少的，而页模式则是可选的——如果使用页模式，则是段页式，否则这是仅段模式。</p>
</li>
<li><p>实地址模式（Real-address mode）：在这种操作模式下，处理器处于Intel 8086处理器的编译运行环境，但此外提供了一些扩展（例如切换到保护或系统管理模式的拓展）。 （这种模式只能跑Intel8086处理器对应的程序）。机器刚刚通电启动或CPU复位时，运行在实模式下。实模式只能访问地址在1M以下的内存称为常规内存，我们把地址在1M 以上的内存称为扩展内存。实模式的“实”体现在程序中用到的地址都是真实的物理地址，“段基址:段内偏移地址”产生的逻辑地址就是物理地址，即程序员可见的地址完全是真实的内存地址。由16位段寄存器的内容乘以16（左移4位）作为段基址，加上16位段偏移地址形成20位的物理地址，最大寻址空间1MB，最大分段64KB。</p>
</li>
<li><p>系统管理模式（System management mode (SMM)）：自Intel386 SL处理器开始，SMM是所有IA-32处理器的标准架构特性。 这种模式为操作系统或程序的执行提供了一个透明的机制来实现电源管理和OEM差异化特性。SMM是通过激活外部系统中断引脚(SMI#)进入中断，该引脚产生一个系统管理中断(SMI)。 在SMM中，处理器切换到一个单独的地址空间，同时保存当前运行的程序或任务的上下文。为SMM的设计代码可以透明地执行。 从SMM返回时，处理器被放置回SMI之前的状态</p>
</li>
<li><p>虚拟8086模式： 虚拟8086模式是运行在保护模式中的实模式，也称为准操作模式，为了在32位保护模式下执行纯16位程序。它不是一个真正的CPU模式，还属于保护模式。</p>
</li>
</ul>
<p>保护模式同实模式的<code>根本区别</code>是<code>进程内存受保护与否</code>。可寻址空间的区别是前因的结果。</p>
<p>Intel 64架构支持IA-32架构和IA-32e架构的所有工作模式:  </p>
<p>​    IA-32e模式：64位操作系统运行在该模式。该模式有两种子模式: </p>
<ul>
<li>兼容模式：该模式下，64位操作系统运行在32位兼容环境，能正常运行16，32位应用程序就像在基本的保护模式下运行一样。可以访问32位地址空间，但不能运行纯16位实模式程序（即不能运行虚拟86模式程序）。 </li>
<li>64位模式：在该模式下，处理器完全执行64位指令，使用64位地址空间和64操作数，运行16，32位程序必须切换到兼容模式。64位模式提供64位线性寻址，支持大于64GBytes的物理地址空间。  </li>
</ul>
<p>​    IA-32e子模式的切换完全基于代码段寄存器。这样一来，运行在IA-32e模式中（64位）的OS 通过设置32位后的CS，完全可以无缝的运行所有16，32，64为应用程序。</p>
<h3 id="模式切换："><a href="#模式切换：" class="headerlink" title="模式切换："></a>模式切换：</h3><p><img src="/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/mode_transition.jpg"></p>
<center style="color:#1a1a1a;">图3 模式切换</center>

<p>​    EFLAGS寄存器中的VM标志位决定处理器是在保护模式还是在虚拟8086模式下运行。保护模式和虚拟8086模式之间的转换通常作为任务切换或从中断或异常处理程序返回的一部分进行。<br>​    <code>LMA位(IA32_EFER.LMA[bit 10])</code>决定处理器是否在IA-32e模式下运行。 在IA-32e模式下运行时，又由代码段的CSA.L位决定是64位还是兼容模式 。处理器通过启用分页机制和设置<code>LME位    (IA32_EFER.LME[bit 8])</code>，然后从保护模式进入IA-32e模式。<br>​    当处理器处于实模式、保护模式、虚拟8086模式或IA-32e模式时，只要它接收到SMI中断，处理器就会切换到SMM模式。 在执行RSM指令之后，处理器总是返回到SMI中断发生前的模式。<br>​    机器上电，CPU进入实模式，从物理地址0xFFFFFFFF0处开始执行初始化代码，设置基本系统功能操作必要的数据结构信息，例如处理中断和异常的IDT表。接下来，如果继续在保护模式工作，需要加载操作系统模块；如果要进入实模式，那么需要进行模式切换。</p>
<h3 id="保护模式与实模式的切换"><a href="#保护模式与实模式的切换" class="headerlink" title="保护模式与实模式的切换"></a>保护模式与实模式的切换</h3><p>​    为了在硬件或软件复位后，处理器以保护模式运行，那么必须要从实地址模式切换到保护模式。 一旦切换到保护模式，软件通常不需要切换回实地址模式。 若要运行以实地址模式（8086模式）编写的软件，通常以虚拟8086模式运行软件比切换回实地址模式更方便。 </p>
<h4 id="切换到保护模式："><a href="#切换到保护模式：" class="headerlink" title="切换到保护模式："></a>切换到保护模式：</h4><p>​    处理器进入到保护模式之前，需要操作系统加载和初始化软件必须在内存中设置好保护模式下使用的数据结构的基本信息。这些数据结构包括<br> 1）保护模式中断描述符表IDT<br> 2）GDT<br> 3）任务状态段TSS<br> 4）LDT<br> 5）如果使用分页机制，最少要设置一个页目录和一个页表<br> 6）处理器切换到保护模式下运行的代码段</p>
<p>还需要设置设置以下系统寄存器<br> 1）GDTR<br> 2）中断描述符表基地址寄存器<br> 3）控制寄存器CR1～CR3</p>
<p>初始化这些数据结构、代码模块和系统寄存器之后，通过设置CR0寄存器的保护模式标志位PE即可进入保护模式。<br>切换到保护模式的步骤如下：</p>
<ol>
<li>禁用中断。 CLI指令禁用可屏蔽硬件中断。 NMI中断可以用外部电路禁用。 （软件必须保证模式切换过程中不产生异常或中断。）</li>
<li>执行LGDT指令，将GDT的基址加载入GDTR寄存器  </li>
<li>执行一条MOV CR0指令，在控制寄存器CR0中设置PE标志位（也可以设置PG标志位，启用分页机制）</li>
<li>执行完MOV CR0指令之后，执行FAR JMP或 FAR CALL指令。（这个操作通常是远跳转或调用指令流中的下一条指令。）</li>
<li>紧跟在MOVCR0指令的JMP或CALL指令改变了处理器执行流程并串行化处理器。  </li>
<li>如果启用了分页机制，那么MOV CR0指令和JMP或CALL指令的代码必须来自已经经过映射的页面（即，跳转前的线性地址与启用了分页和保护模式后的物理地址相同）。 JMP或CALL指令的目标指令不需要进行内存映射。  </li>
<li>如果要使用一个本地描述符表，则执行LLDT指令，在LDTR寄存器中加载LDT的段选择器。</li>
<li>执行LTR指令，用初始保护模式任务的段选择符或者可写内存区域的段描述符加载任务寄存器TR</li>
<li>进入保护模式后，段寄存器仍存储着实地址模式时候的内容。第4步中的JMP和CALL指令会重置CS寄存器。然后执行以下操作之一来更新剩余段寄存器的内容 ：（1）重新加载段寄存器DS, SS, ES, FS和GS。 若是不使用ES, FS和/或GS寄存器，则加载空选择子。  （2）对一个新任务执行JMP或CALL指令，这将自动重置段寄存器的值，并将其存储到一个新的代码段。</li>
<li>执行LIDT指令，用受保护模式IDT的地址和限长加载IDTR寄存器。</li>
<li>  开启中断。执行STI指令启用可屏蔽硬件中断，并执行必要的硬件操作启用NMI中断。</li>
</ol>
<h4 id="切换回实模式"><a href="#切换回实模式" class="headerlink" title="切换回实模式"></a>切换回实模式</h4><p>​    若MOV CR0指令复位CR0中的PE位，处理器从保护模式切换回实地址模式。重新进入实地址模式步骤如下：</p>
<ol>
<li>关中断；CLI指令禁用可屏蔽硬件中断。 NMI中断可以用外部电路禁用；</li>
<li>如果开启分页机制，那么需要执行：<br> 把程序的控制转移到对等映射的线性地址处，这些地址的标识映射到物理地址（线性地址等同于物理地址）<br> 确保GDT和LDT在对等映射的页面上<br>复位CR0中的PG标志位<br> 设置CR3寄存器内容为0x00，用于刷新TLB缓冲</li>
<li>把程序的控制转移到长度为64KB（0xFFFF）的可读段中。此操作使用实模式要求的段长度加载CS寄存器</li>
<li>使用包含以下设定值的描述符选择子来加载SS、DS、ES、FS、GS段寄存器<br> 段限长=64kb（0xFFFF）<br> 字节粒度 （G = 0）<br> 向上扩展 E=0<br> 可写 W=1<br> 存在 P=1<br> 基址= 任何值<br>段寄存器存储的是非空的段选择子，否则段寄存器在实地址模式下将不可用。 注意，如果段寄存器没有重新加载，那么在保护模式中继续使用加载的描述符属性执行。</li>
<li>执行LIDT指令来指向在1MB实模式地址范围内的实地址模式中断表</li>
<li>复位CR0中的PE位已进入实模式</li>
<li>执行一个FAR JMP指令跳转到一个实模式程序中。这个操作会刷新指令队列，并且为CS寄存器加载合适的基地址和访问权限值</li>
<li>加载实地址模式程序代码会使用的SS、DS、ES、FS、GS。如果其中哪一个在实模式下不会用到，则写入0</li>
<li>执行STI指令启用可屏蔽硬件中断，并执行必要的硬件操作启用NMI中断。   </li>
</ol>
<h2 id="1-3-80x86系统指令寄存器"><a href="#1-3-80x86系统指令寄存器" class="headerlink" title="1.3 80x86系统指令寄存器"></a>1.3 80x86系统指令寄存器</h2><h3 id="标志寄存器-EFLAGS"><a href="#标志寄存器-EFLAGS" class="headerlink" title="标志寄存器 EFLAGS"></a>标志寄存器 <code>EFLAGS</code></h3><p>​    EFLAGS寄存器的系统标志位和IOPL字段控制I/O、可屏蔽的硬件中断、调试、任务切换和虚拟8086模式（如图4所示）。一般情况下，只允许具有<code>特权级别</code>的代码（通常是操作系统或执行代码）才能修改这些标志位。  </p>
<p><img src="/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/EFLAG.jpg" alt="EFLAG"></p>
<center style="color:#1a1a1a;">图4 EFLAG寄存器中的系统标志位</center>

<p>​    系统标志和IOPL如下：</p>
<ul>
<li><p>TF (Trap (bit 8))：跟踪标志位（第8位），设置该标志位可启用<code>单步调试模式</code>; 复位则禁用单步模式。 在单步模式下，处理器在每条指令执行后生成一个<code>调试异常</code>。如果程序使用POPF、POPFD或IRET指令设置TF标志，处理器则会在紧跟POPF、POPFD或IRET之后的指令后产生一个调试异常。</p>
</li>
<li><p>IF(Interrupt enable (bit 9))：中断使能位（第9位），控制处理器对<code>可屏蔽硬件中断</code>请求的响应（参见6.3.2节“可屏蔽硬件中断”）。设置该标志位表明处理器可以响应可屏蔽硬件中断; 复位则不响应可屏蔽硬件中断。  IF标志不会屏蔽异常或不可屏蔽中断（NMI中断）。通过控制寄存器CR4中的CPL、IOPL和VME标志位的值决定IF标志是否可以被CLI、STI、POPF、POPFD和IRET修改。  </p>
</li>
<li><p>I/O (privilege level field (bits 12 and 13))：I/O特权级别字段（第12、13位），该标志位指明当前运行的程序或任务的IOPL （I /O privilege level）。 当前运行的程序或任务的CPL必须小于等于其访问I/O地址空间的IOPL。 POPF和IRET指令只能在CPL为0时才能修改该字段。当虚拟8086模式扩展生效时（即当CR4.VME = 1时）， IOPL也是控制IF标志的修改和中断处理的机制之一  。</p>
</li>
<li><p>  Nested task (bit 14)  ： 嵌套任务标志位（第14位），控制被中断和调用任务之间的链接。处理器在调用由CALL指令、中断或异常发起的程序时会设置此标志。 在通过使用IRET指令从一个任务返回时会检查和修改这个标志。 该标志可以通过POPF/POPFD指令显式设置或复位; 但是，在应用程序中更改该标志位的状态可能会导致产生意外的异常。</p>
</li>
<li><p>  Resume (bit 16)  ：恢复标志位（第16位），控制处理器对断点指令的响应。 若设置该标志位，该标志暂时禁止为指令断点生成调试异常(#DB)（尽管其他异常条件可能导致异常产生）。 当该标志位复位时，断点指令会生成调试异常。</p>
</li>
</ul>
<p>  RF标志的主要功能是允许在调试异常之后重新执行一条指令。 在使用IRETD指令返回被中断的程序之前，需要设置堆栈上的EFLAGS内容中设置RF标志位（以防指令断点引起另一个调试异常）。 当返回的指令成功执行后，处理器会自动复位这个标志位，从而再次允许指令断点异常。</p>
<ul>
<li><p>Virtual-8086 mode (bit 17) ：虚拟8086模式标志位（第17位），设置该标志位以切换到虚拟8086模式。复位则返回保护模式。</p>
</li>
<li><p>Alignment check (bit 18)：对齐检查位（第18位）  ：设置该标志位和CR0寄存器中的AM标志位可控制对内存引用进行对齐检查， 复位AC标志和/或AM标志以禁用对齐检查。当引用一个未对齐的操作数时，就会产生一个对齐检查异常，譬如：奇数字节地址上的一个字，或者不是4的整数倍地址上的一个双字。在用户模式下（特权级别3），才会产生对齐检查异常产生。默认特权级别为0的内存引用，例如引用段描述符，也不会产生此异常，即使该异常是由在用户模式下执行的指令引起的。</p>
<p>对齐检查异常可用于检查数据的对齐。对于和进行数据对齐的处理器交换数据时，这一点非常有用。解释器也可以通过将指针指向错误的方式来使用对齐检查异常，并将指针标记为特殊指针。其免去了检查每个指针的开销，并且只在使用时处理特殊指针。 </p>
</li>
<li><p>   Virtual Interrupt (bit 19) ：虚拟中断（第19位），包含IF标志的虚拟映射。 此标志位与VIP标志位一同使用。 当设置了控制寄存器CR4中的VME或PVI标志位，并且IOPL小于3时，处理器才会识别VIF标志。（设置VME标志启用虚拟8086模式扩展；设置PVI标志位启用保护模式下的虚拟中断。）  </p>
</li>
<li><p> Virtual interrupt pending (bit 20)  ：虚拟中断等待位，软件设置该标志位表示有中断正在等待处理； 复位表示没有中断等待处理中。该标志位与VIF标志一起使用。 处理器会读取该标志位，但不会修改。当控制寄存器CR4中的VME或PVI标志被设置且IOPL小于3时，处理器才会识别VIP标志。 设置VME标志启用虚拟8086模式扩展；设置PVI标志位启用保护模式下的虚拟中断。</p>
</li>
<li><p>Identification (bit 21)：标识位（第21位），程序或过程可设置或复位该标志位以表示对CPUID指令的支持。 </p>
</li>
</ul>
<h4 id="IA-32e模式下的系统标志位和字段"><a href="#IA-32e模式下的系统标志位和字段" class="headerlink" title="IA-32e模式下的系统标志位和字段"></a>IA-32e模式下的系统标志位和字段</h4><p>​    在64位模式下，RFLAGS寄存器扩展到64位，上面的32位保留。 RFLAGS（64位模式）和EFLAGS（兼容模式）的系统标志位如图4所示。<br>​    在IA-32e模式下，处理器不允许设置VM位，因为其不支持虚拟8086模式（尝试设置该标志位的操作会被忽略）。此外，处理器也不会设置NT位。 然而，处理器允许软件设置NT位（在IA-32e模式下，若设置了NT位，IRET会通常导致保护故障）。<br>​    在IA-32e模式下，可通过编程的方式使用SYSCALL/SYSRET指令来指定复位RFLAGS / EFLAGS中的一些标志位。 这些指令保存/恢复EFLAGS/RFLAGS。 </p>
<h3 id="内存管理寄存器"><a href="#内存管理寄存器" class="headerlink" title="内存管理寄存器"></a>内存管理寄存器</h3><p>​    处理器提供四个内存管理寄存器(<code>GDTR、LDTR、IDTR和TR</code>)，用于指明内存分段管理所用的数据结构的基地址（见图5）。 处理器还为这些寄存器的加载和保存提供了特定的指令。<br><img src="/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/Memory_Control.jpg"></p>
<center style="color:#1a1a1a;">图5 内存管理寄存器</center>

<ul>
<li><p>全局描述符表寄存器GDTR（Global Descriptor Table Register (GDTR)  ）：GDTR寄存器用于存放全局描述符表的线性基地址（保护模式下32位，IA-32e模式下64位）和16位的GDT表限长值。基地址指定GDT表中字节0在线性地址空间中的地址，表限制长度指明GDT表的字节长度值。</p>
<p>LGDT、SGDT指令分别用于加载和保存GDTR中的值。在机器刚通电或处理器复位后，基地址被默认设置为0，而长度被设置为0xFFFF。在保护模式初始化的过程中必须为GDTR加载一个新的值。</p>
</li>
<li><p>局部描述符表寄存器LDTR(Local Descriptor Table Register LDTR)：LDTR寄存器用于存放局部描述符表的16位的段选择子，基地址（保护模式下32位，IA-32e模式下64位），段限长和描述符属性值。基地址指明LDT段中字节0在线性地址空间中的地址，段限长度指明LDT段的字节数目。<br>LLDT、SLDT指令分别用于加载和保存LDTR寄存器中段描述符的部分。包含LDT表的段必须在GDT表中有一个段描述符项。当使用LLDT指令把含有LDT表段的选择符加载进LDTR时，LDT段描述符的段基址、段限长度以及描述符属性会被自动加载进LDTR中。当出现任务切换时，新任务的LDT段的段选择子和段描述符会自动加载到LDTR中。在写入新的LDT信息之前，LDTR的内容不会被自动保存寄存器中。</p>
<p>当机器通电或处理器复位后，段选择符和基地址被默认设置为0，而段长度被设置成0xFFFF。</p>
</li>
<li><p>中断描述符表寄存器IDTR(IDTR Interrupt Descriptor Table Register )：IDTR寄存器用于存放中断描述符表的线性基地址（保护模式下32位，IA-32e模式下64位）和16位的中断描述符表限长值。基地址指定IDT表中字节0在线性地址空间中的地址，表限制长度指明IDT表的字节数目。LIDT、SIDT指令分别用于加载和保存IDTR中的值。在机器刚通电或处理器复位后，基地址被默认设置为0，而长度被设置为0xFFFF。在保护模式初始化的过程中必须为GDTR加载一个新的值。IDTR寄存器中的基址和限长可以在处理器初始化过程中进行更改。  </p>
</li>
<li><p>任务寄存器TR(Task Register (TR))：TR寄存器存放了当前任务TSS段的16段选择子，基地址（保护模式下32位，IA-32e模式下64位）、段长度和描述符属性值。其引用GDT表中的一个TSS类型的描述符。基地址指定TSS段中字节0在线性地址空间中的地址，段长度指明TSS的字节数目。LTR、STR指令分贝用于加载和保存TR寄存器的段选择符的部分。当LTR指令把选择符加载进任务寄存器时，TSS描述符中的段基址、段限长以及描述符属性会被自动加载到TR中。当机器通电或处理器复位后，段选择符和基地址被默认设置为0，而段长度被设置成0xFFFF。当执行任务切换时，处理器会把新任务的TSS的段选择子和段描述符自动加载入TR中。在写入新的LDT信息之前，LDTR的内容不会被自动保存寄存器中。在写入新的TSS信息之前，TR的内容不会被自动保存寄存器中。</p>
</li>
</ul>
<h3 id="控制寄存器（CONTROL-REGISTERS-）"><a href="#控制寄存器（CONTROL-REGISTERS-）" class="headerlink" title="控制寄存器（CONTROL REGISTERS ）"></a>控制寄存器（CONTROL REGISTERS ）</h3><p>​    控制寄存器（CR0，CR1， CR2， CR3， CR4；如图6所示）决定了处理器的工作模式和当前正在执行的任务的特性。 这些寄存器在所有32位模式和兼容模式下都是32位的。 在64位模式下，控制寄存器扩展到64位。 MOV CRn指令用于操作控制寄存器寄存器标志位。</p>
<p><img src="/2022/04/01/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/contol.jpg"></p>
<center style="color:#1a1a1a;">图6 控制寄存器</center>

<p>​    控制寄存器总结如下，控制寄存器在每个体系结构定义的不同控制字段会被单独描述。 在图6中，64位模式下的寄存器宽度在括号中表示（CR0除外）。 </p>
<ul>
<li><p>CR0：存储系统控制标志位，这些标志位控制处理器运行模式和状态。</p>
</li>
<li><p>CR1：保留不用</p>
</li>
<li><p>CR2：存储导致页错误的线性地址（发生错误处）。</p>
</li>
<li><p>CR3：存储页目录表物理内存的基地址和两个标志位（PCD和PWT），因此该寄存器也被称为页目录基地址寄存器PDBR。PCD和PWT标志位控制处理器内部数据缓存中页目录表的缓存（它们不控制页目录信息的TLB缓存）</p>
<p> 控制寄存器各标志位、字段说明如下：</p>
</li>
<li><p> PG(Paging (bit 31 of CR0))：分页标志位（CR0中的第31位），设置该位启用分页。复位不启动分页。不启用分页时，线性地址就等同于物理地址。如果没有设置PE位（CR0中的第0位），设置该标志位也不会启用分页。若没有设PE位，而尝试设置PG位会导致一般保护异常（#GP）。</p>
</li>
<li><p>CD(Cache Disable (bit 30 of CR0))：当复位CD和NW标志位时，会启用了处理器内部(和外部)缓存中整个物理内存的缓存。当设置了CD标志时，缓存则不启用。 为了防止处理器访问和更新它的缓存，必须设置CD标志并使缓存失效，这样就不会发生缓存命中。</p>
</li>
<li><p> NW（Not Write-through (bit 29 of CR0)）：当复位NW和CD标志位时，启用写回策略（写入缓存）（适用于Pentium 4、Intel Xeon、P6系列和Pentium处理器）或写直达策略（直接写内存）(适用于Intel486处理器)，来实现命中缓存的写操作，并启用失效周期。 </p>
</li>
<li><p>AM（Alignment Mask (bit 18 of CR0)）：设置该标志位时，可进行自动对齐检查；复位时禁用对齐检查。当且仅当设置AM、EFLAGS寄存器中的AC，且CPL为3，并且处理器在保护模式或虚拟8086模式下运行时，才会执行对齐检查。</p>
</li>
<li><p>WP（Write Protect (bit 16 of CR0) ）：写保护位（CR0的第16位），设置该标志位时，禁止管理员级程序写入只读页面; 复位时，允许管理员级程序写入只读页面（无论U/S位设置）。 这个标志有助于实现写时复制方法，还可用于创建UNIX等操作系统使用的新进程（fork）。  </p>
</li>
<li><p>NE(Numeric Error (bit 5 of CR0))：设置该标志位启用本机（内部）机制报告x87 FPU错误。并且输入IGNNE#，忽略x87 FPU错误。 复位时，没有输入IGNNE#，一个未被屏蔽的x87 FPU错误会导致处理器在FERR#引脚产生一个外部中断，并在执行下一个等待浮点指令或WAIT/FWAIT指令之前立即停止指令的执行。</p>
</li>
<li><p>ET（Extension Type (bit 4 of CR0))：扩展类型位（CR0的第4位），Pentium 4、Intel Xeon、P6系列和Pentium处理器中使用。 在Pentium 4、Intel Xeon和P6系列处理器中，该标志被硬编码为1。 在Intel386和Intel486处理器中，设置该标志表示支持intel387 DX数学协处理器指令。</p>
</li>
<li><p>TS (Task Switched (bit 3 of CR0)  )：任务切换标志位（CR0的第3位），允许切换任务的x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4上下文的延迟保存，直到新任务执行一个x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4指令。 处理器在每个任务开关上设置这个标志，并在执行x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4指令时测试它。如果设置了TS并且复位了EM(CR0的第2位)，在执行任何x87 FPU/MMX/SSE/ SSE2/SSE3/SSSE3/SSE4指令之前会引发设备不可用异常(#NM)；而PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI、CLFLUSH、CRC32和POPCNT指令除外。如果设置TS，复位MP标志(CR0的第1位)和EM标志，在执行x87 FPU WAIT/FWAIT指令之前，不会引发#NM异常。 如果设置了EM标志，TS标志的设置对x87 FPU/MMX/SSE/SSE2/SSE3/SSSE3/SSE4指令的执行没有影响。</p>
</li>
<li><p>EM(Emulation (bit 2 of CR0))：仿真位（CR0的第2位），设置该标志位时表示处理器没有内部或外部x87 FPU;；复位时表示系统又协处理器。 这个标志位也影响MMX/SSE/SSE2/SSE3/SSSE3/SSE4指令的执行</p>
</li>
<li><p>MP(Monitor Coprocessor (bit 1 of CR0))：监控协处理器标志位（CR0的第1位），控制WAIT(或FWAIT)指令与TS标志（CR0的第3位）的交互作用。 若设置了MP标志位TS标志位，则WAIT指令会产生一个设备不可用异常(#NM)。 如果复位MP标志，则WAIT指令忽略TS标志的设置。   </p>
</li>
<li><p>PE(Protection Enable (bit 0 of CR0))：保护启用标志位（CR0的第0位），设置该标志位时启用保护模式; 复位时启用实地址模式。 设置该标志位不会直接启用分页。 它只启用段级保护。 若要启用分页功能，必须同时设置PE和PG标志。  </p>
</li>
<li><p>PCD(Page-level Cache Disable (bit 4 of CR3) )：页级缓存禁用(CR3的第4位)，控制访问页目表的第一个页表的内存类型。如果禁用分页，将不使用PAE分页；若CR4.PCIDE = 1，则使用IA-32e分页。</p>
</li>
<li><p>PWT(Page-level Write-Through (bit 3 of CR3))：页级透写（CR3的第3位），控制访问的当前页目表中第一个页表的内存类型。 如果禁用分页，将不使用PAE分页；若CR4.PCIDE = 1，则使用IA-32e分页。</p>
</li>
</ul>
<h2 id="1-4-系统指令"><a href="#1-4-系统指令" class="headerlink" title="1.4 系统指令"></a>1.4 系统指令</h2><p>​    系统指令主要负责处理系统级函数，如加载系统寄存器、管理缓存、管理中断或设置调试寄存器。 其中许多指令只能由操作系统软件或者处于特权级别0的程序执行。其他指令可以在任何特权级别执行，因此应用程序也可使用。<br>​    给出常用系统指令的总结：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>指令全名</th>
<th>受保护</th>
<th>指令描述</th>
</tr>
</thead>
<tbody><tr>
<td>LGDT</td>
<td>Load GDTR Register</td>
<td>是</td>
<td>从内存加载GDT基址、限长到GDTR</td>
</tr>
<tr>
<td>SGDT</td>
<td>Store GDTR Register</td>
<td>否</td>
<td>将GDTR中的基址、限长存储到内存</td>
</tr>
<tr>
<td>LIDT</td>
<td>Load IDTR Register</td>
<td>是</td>
<td>从内存加载IDT基址、限长到IDTR</td>
</tr>
<tr>
<td>SIDT</td>
<td>Load IDTR Register</td>
<td>否</td>
<td>将IDTR中的基址、限长存储到内存</td>
</tr>
<tr>
<td>LLDT</td>
<td>Load LDT Register</td>
<td>是</td>
<td>从内存加载LDT段选择子、段描述符到LDTR或一个通用目的寄存器（段选择子操作数也可以位于通用目的寄存器中）</td>
</tr>
<tr>
<td>SLDT</td>
<td>Store LDT Register</td>
<td>否</td>
<td>将LDTR中LDT段的选择子存储到内存或一个通用目的寄存器</td>
</tr>
<tr>
<td>LTR</td>
<td>Load Task Register</td>
<td>是</td>
<td>从内存中将一个TSS的段选择子和段描述符加载进TR寄存器。（段选择子操作数也可以位于通用寄存器中）</td>
</tr>
<tr>
<td>STR</td>
<td>Store Task Register</td>
<td>否</td>
<td>将TR中的当前任务TSS的段选择子和段描述符存储到内存或一个通用目的寄存器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>体系结构</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>论文翻译</title>
    <url>/2021/09/19/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<h1 id="需求，瓶颈，好运：微处理器演变的动力"><a href="#需求，瓶颈，好运：微处理器演变的动力" class="headerlink" title="需求，瓶颈，好运：微处理器演变的动力"></a>需求，瓶颈，好运：微处理器演变的动力</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>​    第一台微处理器——Intel 4004于1971年问世，其集成了2300个晶体管，时钟频率为108KHz。在三十年后的今天，一个微处理器中集成了近2亿个晶体管，其时钟频率超过了1GHz。在未来的5年里，集成在单个芯片上的晶体管的数量预计将超过10亿，以从6GHz到10GHz的时钟频率运行。</p>
<p>​    微处理器的演变，始于1971年，发展到今日的状况，再到未来5年后可能到达的位置，是因为几个贡献性的力量。我们的立场是：这种演变不是恰好发生的，而是演变的每一步都是三件事其一影响的结果，而且其背景总是计算机架构师于三者中做权衡、折衷。这三件事是：1)新需求；2)瓶颈；3)好运气。我将它们统称为演变的动力。</p>
<p>​    这篇文章尝试从三个方面展开：描述微处理器领域的一个基本框架，展示自第一台微处理器问世后的三十年里的重大发展，最后，提出一些新事物，有望于在未来的5年内看到发生在高性能微处理器上的新事物。</p>
<p>​    <strong>关键词</strong>——计算机体系结构，微体系结构，微处理器， 微处理器设计，微处理器进化。</p>
<h2 id="Ⅰ-基本框架"><a href="#Ⅰ-基本框架" class="headerlink" title="Ⅰ. 基本框架"></a>Ⅰ. 基本框架</h2><h3 id="A-计算机体系结构：折衷（权衡）的科学"><a href="#A-计算机体系结构：折衷（权衡）的科学" class="headerlink" title="A. 计算机体系结构：折衷（权衡）的科学"></a><em>A. 计算机体系结构：折衷（权衡）的科学</em></h3><p>​    计算机体系结构，与其说是“科学”，不如说是“艺术”。随着阅历的增长，我们的能力和洞察力都有所提升。计算机架构师会借鉴以往的设计经验来对当前项目做出决策。如果说计算机体系结构是一门科学，那么它是一门关于权衡的科学。在过去的半个世纪里，计算机架构师一直在学习钻研基础知识，以帮助他们能够实践他们的工艺。 计算机架构师的工作几乎总是需要使用这些基础知识来进行权衡，尤其在微处理器的整个发展过程中，亦是如此。 </p>
<p><img src="/2021/09/19/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/fig1.jpg" alt="image"></p>
<p>​                                                 图1  现代微处理器</p>
<h3 id="B-抽象变换的层次结构"><a href="#B-抽象变换的层次结构" class="headerlink" title="B. 抽象变换的层次结构"></a><em>B. 抽象变换的层次结构</em></h3><p>​    晶体管的数量以及其开关时间是工艺技术所提供的资源。（以上为直译，个人理解为：集成在单个芯片上的晶体管的数量和晶体管的开关时间由加工技术决定。）我们将这些资源用于什么则取决于市场的需求。 我们如何使用这些资源就是微处理器的全部意义所在（个人理解为：根据市场需求，而后使用这些资源来制造微处理器，也就是需求和资源的一种折衷）。 图1展示了抽象变换的层次结构，一个用自然语言描述的问题如英语，必须通过这几层的抽象变换（根据问题，求解算法，选择适当算法编写程序，然后高级语言程序翻译成机器语言程序，再到微程序解释机器语言程序，最后硬件执行微指令，再到底层的电路，最后是最底层的电子，也就高低电平变换01变换，也就是电子）最终才能得以解决。在现实中，是电子运动做动解决了问题。然而，我们并不会在实际中说“电子”，同时“电子”也不会说任何自然语言，我们能做的最好的事情就是通过图1所示的层次结构系统地来转换问题，直到到达电子（或着说设备）层，这一层也就是集成了2亿个集体管，时钟频率为1GHz的芯片。</p>
<p>​    在这个过程中，问题的解决方案首先被用算法的形式来明确阐述以致消除自然语言的一些不可接受的特性，如歧义性。然后用机器语言对其编码并编译为特定微处理器的指令集架构（ISA）。ISA是一致商定的接口:1)编译后的程序用来告诉微处理器该程序需要做什么；2）微处理器用来知道它必须代表程序执行什么。ISA由一组硬件结构实现，其被统称为微处理器的微体系架构。每个硬件结构以及之间的相互连接均由电子数字电路组成，而电子数字电路又由电子设备组成。</p>
<p>​    当我们今天讨论微处理器时，我们通常是指图1的阴影部分。每个微处理器由电路组成，电路实现了硬件结构（统称为微体系架构），其提供了一个面向软件的接口（被称为ISA）。在个人计算机中，ISA一般是IA-32，个人电脑的ISA是IA-32，微架构是Intel的Pentium IV，或者是早期的Pentium III、Pentium II、Pentium Pro、486等等，或者AMD的K-8， 或者为更早的K-7、K-6 等。 </p>
<p>​    还有一些其他的ISA：例如SPARC(来自Sun Microsystems)，Alpha（来自Compaq），以及Power-PC(来自Motorola and IBM)。每种ISA都有其自己的特性来为编译器提供更好或更坏的接口，或者说微体系架构跟好或更坏地执行工作。对于每个ISA，都有多个不同的微体系架构。 我们已经提到了IA-32 的几个微架构。 于Alpha而言， 有 21064、21164 和 21264。</p>
<p>​    在层次结构的每一步中，从算法的选择到语言，到ISA 到微体系结构，到电路，都有选择，因此就有权衡。 </p>
<p>​    人们通常在更高的性能和更低的价格之间做选择，但并非总是如此。举一个汽车的类比可能更有启发性。可以制造一台高性能跑车，其可以在几乎0秒内从0英里/小时加速到 100 英里/小时。但是其造价会非常高。或者，可以制造一辆非常便宜的汽车，它的时速永远无法达到 100 英里/小时，但每加仑汽油可以行驶 100 英里。性能和经济性不可兼得。这就是权衡。</p>
<h3 id="C-设计要点"><a href="#C-设计要点" class="headerlink" title="C. 设计要点"></a><em>C. 设计要点</em></h3><p>​    微处理器的设计就是做相关的权衡（折衷）。我们将微处理器设计中的这组考虑因素以及每个考虑因素相关重要性成为微处理器的“设计要点”–也就是说，于微处理器用途而言最重要的特性，以至于较少关注于其他特性。性能、成本、散热和功耗是强烈影响设计点的特性的示例。另一个示例是“高可用性”——设计一个微处理器时其中考虑最多的就是这个微处理器永远不会出故障。如果可以确保微处理器永远不会出现故障，一些客户愿意接受更低的性能或更高的价格。我们将这种处理器称为“容错”或高可用性的。</p>
<p>​    其他客户则愿意为节能、续航牺牲一部分性能，随着最高性能芯片的功率和能耗越来越大，大得令人无法接受，这个设计要点愈发重要。这就存在一个最高性能与功耗意识的权衡。</p>
<p>​    值得一提的是，“功耗意识”与另一个重要的设计要点“低功耗”不同，在许多应用中，首先考虑的是微处理器消耗非常少量的能源但能长时间运行。</p>
<h3 id="D-应用空间"><a href="#D-应用空间" class="headerlink" title="D. 应用空间"></a><em>D. 应用空间</em></h3><p>图1中“问题”一词是应用空间的统称，或者说我们希望使用微处理器的一组应用程序。应用程序的数量正在以惊人的速度增加，而且预计未来仍会保持增长的趋势。实际上，只要人们期望计算机的用途更加广泛（或者说计算机能实现更多功能），则对于微处理器的需求和权衡将会持续扩大。也就是说，应用空间（或更准确说，具有核心重要性的应用）驱动着这个设计要点。我们前面那已经提到了高可用性处理器，其中应用程序要求微处理器永远不出故障，以及在低功耗处理器中，应用程序必须能够消耗少量能量而能长时间运行。</p>
<p>​    持续驱动独特设计要点需求的应用空间的其他示例如下：</p>
<pre><code>1. 科学应用，例如，计算控制核电站，决定开采石油的位置，预测天气；
2. 基于事务的应用程序，例如办理ATM转账和电子商务业务;
3. 业务数据处理应用程序，例如处理库存控制、工资、IRS活动和各种个人记录的应用程序，无论这些个人是雇员、学生还是选民;
4. 网络应用，例如高速路由的互联网数据包，使你的家庭系统连接利用互联网;
5. 有保证的交付(即实时)应用程序，要求在某个关键期限之前得到计算结果;
6. 嵌入式应用程序，其中处理器是更大系统的一个组件，用于解决(通常)专用应用程序;
7. 解码视频和音频文件等媒体应用程序;
8. 桌面用户希望在自己的电脑上运行的随机软件包。
</code></pre>
<p>每个应用领域都有其特点，与其他领域大不同。每个应用领域都要求做不同的权衡、折衷来设计微处理器来满足其完成工作。</p>
<h3 id="E-基本处理"><a href="#E-基本处理" class="headerlink" title="E. 基本处理"></a><em>E. 基本处理</em></h3><p>​        微处理器处理执行指令，简单地说，有三个步骤：1)向处理器核心提供指令，让每条指令都能完成它的工作;2)提供每条指令所需的数据;3)执行每条指令。</p>
<h3 id="F-指令供给"><a href="#F-指令供给" class="headerlink" title="F. 指令供给"></a><em>F. 指令供给</em></h3><p>在提供指令的早期阶段，一次取一条指令，解码并发送到内核进行处理。 随着时间的流逝，一次能取到指令的数量已经从一个增加到了四个，而且很可能不久就增长到六或八。 有三个因素会妨碍为内核充分提供待处理的指令：指令缓存未命中、获取中断和条件分支错误预测。 当对指令缓存不命中时，指令的供应量下降到零，直到高速缓存未命中得到解决。 当被提取的指令是一个已采取的分支时，则会发生提取中断，这使得在同一周期中提取的所有后续指令都变得无用，与问题宽度无关。 条件分支错误预测意味着自错误预测分支以来取出的所有指令都是无用且浪费了资源，并且必须在执行正确的指令路径继续之前将其丢弃。 </p>
<h3 id="G-数据供给"><a href="#G-数据供给" class="headerlink" title="G. 数据供给"></a><em>G. 数据供给</em></h3><p>为了提供一条指令所需的数据，人们需要能够在接近0的时间内（尽可能的快）以合理的成本（成本和速度的折衷）无限地提供所需数据。实际数据存储器无法满足这三个要求。 我们能做的最好的是一个存储层次结构，其中可以在一到三个周期内访问少量数据（在芯片上），在十到十六个周期内可以访问更多数据（也在芯片上）， 并且可以在数百个周期内访问更多数据（片外）。 <del>结果是实际数据存储器受到取出特定数据元素的时延和将该数据元素从其在存储层次结构中的位置移动到需要它的处理器核心所必需的带宽的二者的制约。</del> </p>
<p>尽管这种片外延迟在今天依旧很糟糕，而这种情况一直在变得更差。 处理器的指令周期时间（这里联系上文中的处理器，这里的周期应该为指令周期——CPU每取出并执行一条指令所需要的时间，是从取指令、分析指令到执行完指令所需的全部时间。）的改进一直在增长，，且比内存周期时间快得多的速度增长。 几年后，我们希望看到对内存的片外数据访问需要数千个处理器周期。</p>
<h3 id="H-指令处理"><a href="#H-指令处理" class="headerlink" title="H. 指令处理"></a><em>H. 指令处理</em></h3><p>为了执行这些指令所需的操作，需要足够数量的功能单元来在数据可用时立即处理数据，并且需要足够的互连以将一个功能单元产生的结果立即提供给需要它的功能单元 来源。 然而，足够的互连是不够的。 随着片上周期时间的减少，将芯片某一部分的功能单元所产生的结果转发到芯片其他部分的功能单元，在这个功能单元中结果是源操作数的一部分，其所需的延迟会变得更糟。  </p>
<h2 id="Ⅱ-演变的动力"><a href="#Ⅱ-演变的动力" class="headerlink" title="Ⅱ. 演变的动力"></a>Ⅱ. 演变的动力</h2><p>许多因素促进了微处理器的发展：消费者愿意购买供应商生产的产品——如果没有市场，我们早就回家了。 工程师解决问题的创造性——没有解决方案，就没有更新演化。 </p>
<p>我认为这些事情是次要的，强制性的功能（我称之为演变的动力）是新的需求、瓶颈和幸运。 </p>
<h3 id="A-动力-Ⅰ：新的需求"><a href="#A-动力-Ⅰ：新的需求" class="headerlink" title="A. 动力 Ⅰ：新的需求"></a>A. <em>动力 Ⅰ：新的需求</em></h3><p>早期的微处理器将处理限制为在每个周期内取指、译码，并将其及其数据转发到内核中的功能单元进行处理。但对于更高性能的需求来说，每个周期获取一条指令是远远不够的。 结果是宽发射微处理器（wide-issue microprocessor），其中取指机制允许在每个时钟周期内取指、译码和转发多条指令到执行核心。 </p>
<p>另一个例子，也是由于对高性能的要求，需要同时处理多条指令。 如果只有一个 ALU，则一次只能做一个 ADD。 其结果是目前在一个执行核心中集成了多个功能单元。 </p>
<p>今天，普遍的新需求涉及功耗，或称为功耗感知计算。 要求是提供与先前设计相同水平的计算机性能，同时功率小于先前设计所需功率。 请注意，这与嵌入式处理器的低功耗要求不同，后者在一段时间内一直是一个重要的设计要点。 </p>
<p>有很多人认为未来的新需求将涉及人机交互界面，随着计算机/人机交互变得越来越普遍，人机界面需要越来越多的关注。 </p>
<h3 id="B-动力-Ⅱ：瓶颈"><a href="#B-动力-Ⅱ：瓶颈" class="headerlink" title="B. 动力 Ⅱ：瓶颈"></a>B. <em>动力 Ⅱ：瓶颈</em></h3><p>我们已经在上面确定了指令处理的三个组成部分（取指、取数和执行指令的操作），以及每个组成部分的含义。 到目前为止，微处理器的大部分改进都是为了消除阻碍这三个组件完成工作的瓶颈。 </p>
<p>例如，取指需要在每个周期取一定数量的指令——今天是四个——指令。 如果这些指令存储在内存中，那么获取的时间会太长。 瓶颈是缓慢的访存。 因此，发明了指令缓存。 </p>
<p>如果硬件有能力获取四条指令，但第二条指令是条件分支，则只能获取两条指令，而不是四条指令。 由条件分支引起的瓶颈是指令按照编译器生成的顺序排列，而不是指令执行的（动态）顺序。 最近添加到 Pentium IV 的新功能是跟踪缓存，它按照最近执行的顺序而不是编译器编译的（静态的）顺序来存储指令。 </p>
<p>最后，如果每个周期都提供指令（取指），则在遇到分支时会出现问题，因为尚不确定是否满足条件而采取分支转移，有可能转移，也有可能不转移。可以等待得出指令的执行结果，先暂时停止指令的获取，直到确定是否满足条件，（即确定该指令的下一条指令）。 通过引入分支预测器突破了这个瓶颈，它猜测是否应该采用分支，并根据这个猜测立即取指。 </p>
<h3 id="C-动力-Ⅲ：好运气"><a href="#C-动力-Ⅲ：好运气" class="headerlink" title="C. 动力 Ⅲ：好运气"></a>C. <em>动力 Ⅲ：好运气</em></h3><p>当某些事情导致意外收获时，这就是幸运，然后其意外收获可被用于为微处理器提供额外的功能。 这方面的一个很好的例子是技术收缩，它允许微处理器的下一代实现比以前的实现占用更少的芯片空间。 由于旧设计所需的空间更少，因此可以有更多空间用于做其他事情。 以这种方式引入微处理器的其他两个例子是 1980 年代中期的片上浮点加速器和 1990 年代后期在片上添加的多媒体指令扩展功能。</p>
<h2 id="Ⅲ-演变历程：从1971到今天"><a href="#Ⅲ-演变历程：从1971到今天" class="headerlink" title="Ⅲ. 演变历程：从1971到今天"></a>Ⅲ. 演变历程：从1971到今天</h2><p>微处理器已经从 Intel 4004 的简单 2300 个晶体管发展到今天的样子。这种演变是源于几个原因，正如上面所述。 其结果是今天的 Pentium IV 与 1971 年的 Intel 4004 几乎没有相似之处。</p>
<p>这种演变的一些例子如下。 </p>
<h3 id="A-流水线"><a href="#A-流水线" class="headerlink" title="A. 流水线"></a><em>A. 流水线</em></h3><p>早期的微处理器在开始处理下一条指令之前，处理一条指令要经历取指到指令休止。流水线，最晚自 1960 年代以来就在大型计算机中出现，是解决该性能瓶颈的重要方案。 具有商业利益(商用)的微处理器（例如 Intel 8086）在 1970 年代后期通过在执行当前指令时预取出下一条指令，向流水线迈出了第一步。 </p>
<p>片内缓存稍微些才出现在微处理器中。 从片外存储器取指令和数据到片内处理元件的时延太大。解决方案是：片内缓存。 1984 年，第一个具有片上缓存的商业可行（商业）微处理器是摩托罗拉 MC68020。 在具有流水线技术的处理器中，能够在同一周期内取指令和取数据，而不是争用一个端口到缓存读取，突破了瓶颈，这是很有用的。1986 年，摩托罗拉的 MC68030 是第一批包含独立的片内的指令和数据缓存的微处理器。 </p>
<p>缓存要么速度快要么容量大，不能两者兼得。因为缓存必须很快，那么它的容量不得不很小，从而导致缓存未命中率过大。 高速缓存未命中的问题是片外为解决未命中的延迟太大。解决方案是：芯片上有两级缓存，因此较快、容量小的一级缓存中的未命中可以通过容量较大、速度较慢的二级缓存来解决，这仍然比片外快得多。 直到 1994 年左右Alpha 21164 问世，这个技术才出现在微处理器上。今天，几乎所有的高性能微处理器都有两级缓存。 </p>
<h3 id="C-分支预测"><a href="#C-分支预测" class="headerlink" title="C. 分支预测"></a><em>C. 分支预测</em></h3><p>如果条件分支产生流水线停顿，等待处理分支条件且执行完分支指令，则失去了流水线的优势。 硬件（运行时）分支预测器直到 1990 年代初才在微处理器芯片上实现。早期，一些引入运行时分支预测器的微处理器是摩托罗拉的 MC88110、Digital 的 Alpha 21064 和英特尔的 Pentium。 </p>
<h3 id="D-片内浮点单元"><a href="#D-片内浮点单元" class="headerlink" title="D. 片内浮点单元"></a><em>D. 片内浮点单元</em></h3><p>早期的微处理器有一个单独的芯片来处理浮点运算。 随着晶体管越来越小，芯片越来越大，通过利用“新”的空闲容量并节省不必要的片外通信，芯片上集成的晶体管数目达到了可以将浮点单元与主处理单元放在同一芯片上的程度。 摩托罗拉 MC88100 和英特尔 486 是 80 年代后期在主处理器芯片上集成浮点单元的两款早期芯片。 </p>
<h3 id="E-其余专业功能单元"><a href="#E-其余专业功能单元" class="headerlink" title="E. 其余专业功能单元"></a><em>E. 其余专业功能单元</em></h3><p>早期的微处理器只有一个或很少的功能单元。 随着芯片上晶体管数量的增多，人们也认识到可以通过利用多个功能单元来并发执行。 首先添加了诸如单独处理 ALUs之类的功能单元。 然后，更复杂的加载/存储功能单元其包含写缓冲区、未命中未决队列和处理内存消歧机制等，成为 1990 年代通用微处理器芯片的一部分。1986 年，英特尔的 I860 是首批拥有多个专用功能单元之一，除了浮点加法和乘法单元之外，还有一个单元用于辅助图形处理。 </p>
<h3 id="F-乱序执行"><a href="#F-乱序执行" class="headerlink" title="F. 乱序执行"></a><em>F. 乱序执行</em></h3><p>程序员/编译器和微体系结构之间的契约要求指令必须按照翻译程序指定的顺序执行。而这就导致了一个瓶颈：如果当前指令因需要其后续指令为他提供其开始执行所需的全部内容，而不能执行，则会阻止其他指令执行。（简而言之，就是当前指令需要后续指令为其提供数据才能开始执行，那么当前数据不能执行，因为只有执行了当前指令，才能执行后续指令，就陷入了一个死锁）</p>
<p>自 1960 年代中期以来， 就已经提出这一瓶颈的机制，即乱序处理，例如，IBM 360/91。然而，该机制仅限于高性能科学计算，同时在高性能计算中，能够处理精确异常并不是重要需求。然而目前几乎所有制造商都认可IEEE 浮点标准，这表明处理精确异常并非不是重要需求。 尽管如此，虽然乱序执行已在大型机上使用了 35 年，但直到在1990 年代中期，它与精确异常处理的结合使用才在微处理器上首次出现。</p>
<p>为了适应乱序执行，微处理器调整了早期大型机上使用的寄存器别名和执行部件中的驻留站 。为了做到这一点，微处理器必须能区分指令执行和指令退出。指令在它们的执行所需资源（数据和功能单元）可用时才被允许执行，独立于它们在程序中的顺序，但被迫以它们在执行程序中出现的相同顺序退出。也就是说，内部微架构可以乱序执行指令，但必须按照指令在执行程序中出现的顺序报告执行结果（即改变计算的永久状态）。如果要实现这样功能，则需要一个能在异常情况下恢复状态的机制。这种状态恢复机制在当今大多数微处理器上通常表现为重新排序缓冲区，在少数微处理器上表现为检查点退休结构。尽管其他微处理器更早地出现了无序执行的情况，但第一个充分实现这一机制的是 1995 年的 Pentium Pro。</p>
<h3 id="G-集群"><a href="#G-集群" class="headerlink" title="G. 集群"></a><em>G. 集群</em></h3><p>单芯片尺寸继续增大，特征尺寸继续减小，片内频率继续增大。 结果是芯片一角上的功能单元得到的值不能在片间传输，从而不能在下一个周期内中于芯片对角上的功能单元为源操作数使用。 解决方案——将执行核心划分为集群，以便在大多数情况下，一个集群中的功能单元产生的结果将被同一集群中的另一个功能单元使用。 但仍然存在不知道将特定指令引导到哪个集群取执行的问题，但是如果成功，原来因一个执行结果必须经芯片的主要部分传输而需要多个周期的不正常延迟消失。 此功能在 1990 年代后期首次出现在 Alpha 21264 上。 </p>
<h3 id="H-芯片多处理器"><a href="#H-芯片多处理器" class="headerlink" title="H. 芯片多处理器"></a><em>H. 芯片多处理器</em></h3><p>芯片日益丰富的另一种用途（更多的晶体管，与更快的工作频率相结合）是将芯片划分为多个区域，每个区域使用相同的处理器。 该范例被称为 CMP，用于芯片多处理器。 对于易于划分为独立指令流的任务，其中需要指令流之间的大量通信，CMP 是一种有用的范例。 它提供了发生在片内的处理器间通信的额外好处，其中这种通信比片外通信快得多。 IBM 于 2000 年实现了此功能，其 G4 芯片上有两个处理器。 </p>
<h3 id="I-同步多线程"><a href="#I-同步多线程" class="headerlink" title="I. 同步多线程"></a><em>I. 同步多线程</em></h3><p>当指令高速缓存访问出现未命中时，指令供应会受到影响。 在等待缓存命中时浪费了大量容量。 Burton Smith 在 1978 年 [3] 建议使用该空闲容量从其他指令流中获取指令。 这个概念首先在他的 Donelcor HEP 上实现。 这个概念直到 1990 年代才在微处理器世界中亮相，在微处理器中，它被扩展为允许在交替周期中从交替的单个指令流中取指，但基于所需数据的可用性，在同一周期中同时从所有指令流中执行 取指。第一个实现此功能的微处理器是 2000 年的 Pentium IV。 </p>
<h3 id="J-更快的内核"><a href="#J-更快的内核" class="headerlink" title="J.更快的内核"></a><em>J.更快的内核</em></h3><p>在密集型计算任务中，等待较早执行指令产生的结果为源操作数的数据依赖可能是一个重要的瓶颈。 一个解决方案是——以比微处理器其他部分快得多的频率运行执行核心。 2000 年推出的 Pentium IV 芯片的工作频率为 1.7 GHz，但 ALU 的工作频率为 3.4 GHz。 </p>
<h2 id="Ⅳ-十亿晶体管芯片的未来"><a href="#Ⅳ-十亿晶体管芯片的未来" class="headerlink" title="Ⅳ. 十亿晶体管芯片的未来"></a>Ⅳ. 十亿晶体管芯片的未来</h2><p>正如我们所说，在当前的十年内，工艺技术有望在单个芯片上集成 10 亿个晶体管，并以 6 至 10 GHz 的频率运行。 那么我们将如何利用所有这些能力？ </p>
<p>今天的计算机架构师并不认同。 有些人主张扩展我们上面描述的 CMP 理念。 论据是，如果有 10 亿个晶体管，我们可以在单个芯片上集成 100 个微处理器，每个处理器由 1000 万个晶体管组成。 该论点进一步指出，一个 1000 万晶体管处理器仍然非常庞大，建造任何比这更大的东西只会适得其反，导致更大的收益递减。 </p>
<p>其他人则是建议扩大使用同步多线程。 他们认为 CMP 所需的许多资源可以在单个处理器 SMT 芯片上共享，从而将节省的资源释放给其他功能，例如更大的缓存、更好的分支预测器、更多功能单元等 </p>
<p>而包括本文作者在内的一些人指出，虽然 SMT 在共享资源方面肯定比 CMP 有所改进，但在加快大多数重要的非科学基准测试方面，它们都存在不足。 原因：这些基准测试中的大多数都有令人失望的特性，re: SMT，由单个指令流组成。 一个非常昂贵的芯片应该解决多计算机网络无法解决的问题，这个计算机网络由许多更小更便宜的芯片组成的。这一观点主张使用所有的10亿个晶体管来生产一个非常高性能的单处理器。</p>
<p>还有一些人抱怨说，由于 CAD 工具已经无法准确验证我们当前的芯片，所以设计更复杂的芯片是不负责任的。 他们提倡一个非常简单的核心处理器，其有较大容量的片上缓存。</p>
<p>那些以成本为中心(这是一个非常不同的设计要点)的厂商认识到，更高水平的集成可以生产出更便宜的产品，并建议使用10亿个晶体管，将整个非激进的系统放在一个芯片上。</p>
<p>这些都是可供选择的建议，我推测它们中的每一个都会在未来十年内出现在某些产品中。我个人的偏好是使用十亿个晶体管来发展最高性能的单处理器，以处理单指令流应用。推动这一发展的因素和以前一样:新的需求、瓶颈和好运。以下是我们可能会看到的一些想法。 </p>
<h3 id="A-新微处理器"><a href="#A-新微处理器" class="headerlink" title="A. 新微处理器"></a>A. 新微处理器</h3><p>到目前为止，微处理器的设计方式如图1所示。但是为什么这样做呢？如果我们把我们的抽象变换层次并把算法和语言包含在微处理器中，那么微处理器就变成了使用 器件工艺来解决问题的东西。参见图2。为什么不能为解决应用空间中的某一点，而设计一个微处理器，在这个微处理其中，将解决该问题所需的专用算法嵌入到微处理器中，为什么这样实现是不合理的呢？我们今天在低成本的嵌入式应用程序中这样实现。但为什么不能在可接受的高成本的有高性能要求的机器中实现呢呢？</p>
<p>这种定做可以采用以下讨论的可重构逻辑的形式，ISA中的特殊专用指令，或者芯片上提供的集成功能单元(如DSP引擎。</p>
<p><img src="/2021/09/19/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/fig2.jpg" alt="image"></p>
<p>​                                                图2   未来的微处理器</p>
<h3 id="B-新的数据路径"><a href="#B-新的数据路径" class="headerlink" title="B. 新的数据路径"></a><em>B. 新的数据路径</em></h3><p>片内的时钟频率有望于到达很高以至于必须认真考虑芯片上任何信号线的长度。有些信号需要多个周期才能在芯片完成传输。必须仔细检查哪些信号可以这样做。大多数信号可能都不行。 这就产生了挑战：根据线长的新限制重新设计数据路径。</p>
<h3 id="C-内部容错"><a href="#C-内部容错" class="headerlink" title="C. 内部容错"></a><em>C. 内部容错</em></h3><p>片内的时钟频率提升的另一个后果是对软错误的敏感性——由于材料的物理特性，在有望实现的如此高的时钟频率下运行，这些错误将间歇性地和不频繁地出现。未来的微处理器将必须提供在这些软错误发生时进行检查和纠正的功能。 </p>
<h3 id="D-异步和同步单元共存"><a href="#D-异步和同步单元共存" class="headerlink" title="D. 异步和同步单元共存"></a><em>D. 异步和同步单元共存</em></h3><p>时钟脉冲相位差（查阅资料：<strong>时钟脉冲相位差</strong>是指同时产生的两个时钟信号，到达接收端的时间不同步。）已经成为一个严重的问题。在时钟频率为 6 GHz 时，情况会更糟糕。 诚然，异步结构更难设计，但它们确实解决了所有部件都要同步的全局时钟的问题。这一点非常重要，值得我们应对设计困难这一挑战。我的期望是，我们将看到一些部件在一段固定的时间内异步运行(以时钟周期衡量)，之后它们与全局时钟同步。 不同的部件需要不同的时间来进行异步操作，以解决其独特的时钟脉冲相位差问题。</p>
<h3 id="E-不同功能的不等周期时间"><a href="#E-不同功能的不等周期时间" class="headerlink" title="E. 不同功能的不等周期时间"></a><em>E. 不同功能的不等周期时间</em></h3><p>对于那些同步运行的部件，没有必要它们都以芯片的额定频率运行。例如，不需要以高速运行的部件可以设计成以慢速运行，从而节省电力。未来的晶体管预算可以提供巨大的灵活性，以适当地满足片上需求的可变性。</p>
<p>ALU以处理核上其余部分运行频率的两倍运行，这只是冰山一角。 未来的微处理器可以智能地使用时钟，在需要的地方提高速度，在不需要的地方降低速度，在速度根本不重要的地方可以非常慢。</p>
<h3 id="F-新材料"><a href="#F-新材料" class="headerlink" title="F. 新材料"></a><em>F. 新材料</em></h3><p>我不知道这些材料从何而来，但摩尔定律仍然适用，尽管每五年左右就会出现一些末日论者来宣告它的消亡。 关键的重要材料要与芯片上的导电性相比，更重要的是，与功率要求和散热相比（关键材料要关注导电性、功率、散热）。 因此，本着纯粹的一厢情愿的精神，我希望工程的独创性再次占上风。 （即，有新材料的出现实现更好的性能）。</p>
<h3 id="G-微程序的扩展使用"><a href="#G-微程序的扩展使用" class="headerlink" title="G. 微程序的扩展使用"></a><em>G. 微程序的扩展使用</em></h3><p>片外带宽十分昂贵，片上带宽十分充足。 我的期望是：我们将更有效地利用片上带宽。 微程序的扩展使用是实现这一点的一种方法。 例如，微程序可以利用处于主指令流从属地位的未充分利用的功能单元的空闲容量。 我们创造了术语：从属同步微线程 (SSMT) 来反映其在 SMT 机器中的作用 [4]。 这些微程序可以执行动态重新编译、计算一些复合指令、调整缓存替换策略，或者以其他方式执行计算，使主指令流执行得更快。 </p>
<h3 id="H-可重构逻辑"><a href="#H-可重构逻辑" class="headerlink" title="H. 可重构逻辑"></a><em>H. 可重构逻辑</em></h3><p>与图2一致，我希望未来的许多微处理器能够满足特定应用的要求。一个应用程序可以很好地利用一些对其他应用程序无用的逻辑功能，而另一个应用程序可以很好地利用另一个对第一个应用程序无用的逻辑功能。也许这两个应用程序都可以在具有运行时动态调整能力的微处理器有效运行。也就是说，我认为片上结构(可能是低粒度FPGA，但更可能是高粒度可重构逻辑结构)将是未来微处理器的通用结构。</p>
<h3 id="I-集锦"><a href="#I-集锦" class="headerlink" title="I. 集锦"></a><em>I. 集锦</em></h3><p>最后，我列出了我希望在 2008 年或 2009 年的高性能微处理器中实现的功能的清单，或者是无论何时工艺技术最终使得我们可在单个心片上集成了 10 亿个晶体管。 </p>
<ol>
<li>跟踪缓存的扩展使用，其中动态指令流段每个条目将包含远远超过8条指令，可能在编译器的帮助下预先安排(类似于块结构ISA或重放机制)，但在运行时进行优化。</li>
<li>片内微程序，其用于使用执行核心的空闲容量来调整片上硬件结构。</li>
<li>执行程序的动态重新编译，可能由填充单元执行，或者片上微程序实现，这将会十分常见。</li>
<li> 多个（至少三个）级别的缓存以及相应的ISA的 添加（多个预取和后存储指令）以响应内核对数据的需求 ，将数据移近内核并远离内核。</li>
<li>激进的价值预测硬件，可能是程序级别的预测，以及有相应的编译器优化以帮助其有效性。</li>
<li>性能监控硬件，其允许在运行时调整硬件以更有效地与执行程序的需求相匹配。 </li>
<li>一种用于监控和影响芯片能源使用的片上部件</li>
</ol>
<h2 id="Ⅴ-总结"><a href="#Ⅴ-总结" class="headerlink" title="Ⅴ. 总结"></a>Ⅴ. 总结</h2><p>自 1971 年问世以来，微处理器经历了一段激动人心的历程。很少有技术可以夸耀它取得的巨大进步。 不幸的是，有些人会争辩说这个黄金时代即将结束。 但这样的反对者以前也有过。 1986年，他们说MIPS R2000是所有人需要的微处理器，十年后，他们说Intel Pentium Pro 是任何人都需要的微处理器。 该行业将会继续发展得很好，享用该技术的用户能继续“更好地”享用这种技术。 </p>
<p>这并不是说这样的情况会一成不变，不再需要新的独创性。在下层，我们可能需要底层结构发生彻底的根本的变化，比如量子计算，来拯救我们，但我们现在几乎没有受到限制。</p>
<p>当然，我们需要开发更好的 CAD 工具。 当前的 CAD 工具无法验证当今的微处理器，更不用说本文中的建议了。 而且，我们确实需要更广泛地思考微处理器的概念（例如，图 2）。但底线是，摩尔定律仍然存在，并且仍然提供了大量的机会。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>这篇导论脱胎于多年来与以前和现在的学生以及同事的许多互动交流。 也感谢S. J. Patel、R. Belgard 和 R. R. Ronen 对本文的评论和批评。 值得一提的是，Ronen 和他在英特尔的同事 [5] 的一篇论文中提供了对这里涉及的许多问题的出色以及更详细的回答，本文作者向读者推荐该论文。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1] H. Mazor, “The history of the microcomputer-invention and evolution,”<br>Proc. IEEE, vol. 83, pp. 1601–1608, Dec. 1995.</li>
<li>[2] Intel web site [Online]. Available: <a href="http://www.intel.com/pressroom/kits/quickrefyr.htm#1971">http://www.intel.com/pressroom/kits/quickrefyr.htm#1971</a>.</li>
<li>[3] B. Smith, “A pipelined, shared resource MIMD computer,” in Proc.<br>1978 Int. Conf. Parallel Processing, Aug. 1978, pp. 6–8.</li>
<li>[4] R. S. Chappell, J. Stark, S. P. Kim, S. K. Reinhardt, and Y. N. Patt,<br>“Simultaneous subordinate microthreading (SSMT),” in Proc. 26th<br>Annu. Int. Symp. Computer Architecture, May 1999, pp. 186–195.</li>
<li>[5] R. Ronen, A. Mendelson, K. Lai, S.-L. Lu, F. Pollack, and J. P. Shen,<br>“Coming challenges in microarchitecture and architecture,” Proc.<br>IEEE, vol. 89, pp. 325–340, Mar. 2001.</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理与体系结构</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>程序人生-Hello的前世今生</title>
    <url>/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    <content><![CDATA[<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image001.jpg"></p>
<p>​                                                                 <strong>计算机系统</strong></p>
<p>​                                                                     <strong>大作业</strong></p>
<p>​                                                     题   目：   程序人生-Hello’s P2P  </p>
<p>​                                                     专   业：   计算学部    </p>
<p>​                                                     学   号：   1190201307    </p>
<p>​                                                     班   级：   1903010    </p>
<p>​                                                     学   生：    徐伟     　</p>
<p>​                                                     指 导 教 师：  史先俊老师    </p>
<p>​                                                           <strong>计算机科学与技术学院</strong></p>
<p>​                                                                  <strong>2021年5月</strong>    </p>
<p><strong>摘 要</strong></p>
<p>​    Hello是最简单的程序，是每个程序员的初见，不过短短几行，不是很难理解和编写，但从其出生到死亡可谓是一段漫长而又丰富的历程，本论文主要介绍了hello这一最简单程序的生命周期。在这一生命周期，他遇到过生命中的“贵人”帮助他从program变成process，“从静止到跑起来”，即从.c源文件经过预处理、编译、汇编、链接生成可执行文件，再到shell为其fork进程成为process。还有020，从无到有再到化为历史长河的一粒沙，execbe加载运行hello完成内存映射，访问内存读取数据、再到结束shell回收相关资源。从诞生到结束，从运行到终止，探讨追踪了hello这一最简单程序在计算机系统内软硬件结合如何一步步运行直到死亡的过程。</p>
<p><strong>关键词：编译汇编链接，进程管理，内存管理，IO管理。</strong>             </p>
<p>（摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分）</p>
<p><strong>目 录</strong></p>
<p><a href="#_Toc532238396">第1章 概述…………………………………………………………………………………… - 4 -</a></p>
<p><a href="#_Toc532238397">1.1 Hello简介…………………………………………………………………………………. - 4 -</a></p>
<p><a href="#_Toc532238398">1.2 环境与工具………………………………………………………………………………. - 4 -</a></p>
<p><a href="#_Toc532238399">1.3 中间结果………………………………………………………………………………….. - 5 -</a></p>
<p><a href="#_Toc532238400">1.4 本章小结………………………………………………………………………………….. - 5 -</a></p>
<p><a href="#_Toc532238401">第2章 预处理……………………………………………………………………………….. - 6 -</a></p>
<p><a href="#_Toc532238402">2.1 预处理的概念与作用………………………………………………………………… - 6 -</a></p>
<p><a href="#_Toc532238403">2.2在Ubuntu下预处理的命令………………………………………………………… - 8 -</a></p>
<p><a href="#_Toc532238404">2.3 Hello的预处理结果解析……………………………………………………………. - 8 -</a></p>
<p><a href="#_Toc532238405">2.4 本章小结………………………………………………………………………………….. - 9 -</a></p>
<p><a href="#_Toc532238406">第3章 编译…………………………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238407">3.1 编译的概念与作用………………………………………………………………….. - 10 -</a></p>
<p><a href="#_Toc532238408">3.2 在Ubuntu下编译的命令…………………………………………………………. - 11 -</a></p>
<p><a href="#_Toc532238409">3.3 Hello的编译结果解析……………………………………………………………… - 11 -</a></p>
<p><a href="#_Toc532238410">3.4 本章小结………………………………………………………………………………… - 20 -</a></p>
<p><a href="#_Toc532238411">第4章 汇编…………………………………………………………………………………. - 21 -</a></p>
<p><a href="#_Toc532238412">4.1 汇编的概念与作用………………………………………………………………….. - 21 -</a></p>
<p><a href="#_Toc532238413">4.2 在Ubuntu下汇编的命令…………………………………………………………. - 21 -</a></p>
<p><a href="#_Toc532238414">4.3 可重定位目标elf格式…………………………………………………………….. - 21 -</a></p>
<p><a href="#_Toc532238415">4.4 Hello.o的结果解析………………………………………………………………….. - 25 -</a></p>
<p><a href="#_Toc532238416">4.5 本章小结………………………………………………………………………………… - 28 -</a></p>
<p><a href="#_Toc532238417">第5章 链接…………………………………………………………………………………. - 29 -</a></p>
<p><a href="#_Toc532238418">5.1 链接的概念与作用………………………………………………………………….. - 29 -</a></p>
<p><a href="#_Toc532238419">5.2 在Ubuntu下链接的命令…………………………………………………………. - 29 -</a></p>
<p><a href="#_Toc532238420">5.3 可执行目标文件hello的格式………………………………………………….. - 29 -</a></p>
<p><a href="#_Toc532238421">5.4 hello的虚拟地址空间………………………………………………………………. - 33 -</a></p>
<p><a href="#_Toc532238422">5.5 链接的重定位过程分析…………………………………………………………… - 35 -</a></p>
<p><a href="#_Toc532238423">5.6 hello的执行流程……………………………………………………………………… - 37 -</a></p>
<p><a href="#_Toc532238424">5.7 Hello的动态链接分析……………………………………………………………… - 39 -</a></p>
<p><a href="#_Toc532238425">5.8 本章小结………………………………………………………………………………… - 41 -</a></p>
<p><a href="#_Toc532238426">第6章 hello进程管理………………………………………………………………….. - 42 -</a></p>
<p><a href="#_Toc532238427">6.1 进程的概念与作用………………………………………………………………….. - 42 -</a></p>
<p><a href="#_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程………………………………………. - 42 -</a></p>
<p><a href="#_Toc532238429">6.3 Hello的fork进程创建过程……………………………………………………… - 42 -</a></p>
<p><a href="#_Toc532238430">6.4 Hello的execve过程………………………………………………………………… - 44 -</a></p>
<p><a href="#_Toc532238431">6.5 Hello的进程执行…………………………………………………………………….. - 44 -</a></p>
<p><a href="#_Toc532238432">6.6 hello的异常与信号处理…………………………………………………………… - 46 -</a></p>
<p><a href="#_Toc532238433">6.7本章小结…………………………………………………………………………………. - 46 -</a></p>
<p><a href="#_Toc532238434">第7章 hello的存储管理………………………………………………………………. - 49 -</a></p>
<p><a href="#_Toc532238435">7.1 hello的存储器地址空间…………………………………………………………… - 49 -</a></p>
<p><a href="#_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理……………………………… - 50 -</a></p>
<p><a href="#_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理…………………………. - 51 -</a></p>
<p><a href="#_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换…………………………….. - 51 -</a></p>
<p><a href="#_Toc532238439">7.5 三级Cache支持下的物理内存访问…………………………………………. - 54 -</a></p>
<p><a href="#_Toc532238440">7.6 hello进程fork时的内存映射…………………………………………………… - 55 -</a></p>
<p><a href="#_Toc532238441">7.7 hello进程execve时的内存映射……………………………………………….. - 57 -</a></p>
<p><a href="#_Toc532238442">7.8 缺页故障与缺页中断处理……………………………………………………….. - 58 -</a></p>
<p><a href="#_Toc532238443">7.9动态存储分配管理…………………………………………………………………… - 58 -</a></p>
<p><a href="#_Toc532238444">7.10本章小结……………………………………………………………………………….. - 59 -</a></p>
<p><a href="#_Toc532238445">第8章 hello的IO管理………………………………………………………………… - 62 -</a></p>
<p><a href="#_Toc532238446">8.1 Linux的IO设备管理方法……………………………………………………….. - 62 -</a></p>
<p><a href="#_Toc532238447">8.2 简述Unix IO接口及其函数…………………………………………………….. - 62 -</a></p>
<p><a href="#_Toc532238448">8.3 printf的实现分析…………………………………………………………………….. - 62 -</a></p>
<p><a href="#_Toc532238449">8.4 getchar的实现分析………………………………………………………………….. - 65 -</a></p>
<p><a href="#_Toc532238450">8.5本章小结…………………………………………………………………………………. - 66 -</a></p>
<p><a href="#_Toc532238451">结论……………………………………………………………………………………………… - 66 -</a></p>
<p><a href="#_Toc532238452">附件……………………………………………………………………………………………… - 68 -</a></p>
<p><a href="#_Toc532238453">参考文献………………………………………………………………………………………. - 69 -</a></p>
<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p>​    P2P：即从 Program to process由我们在IDE像是VScode、Codeblocks里一行行用C语言这一高级语言编写代码开始，在静态检查无错误后保存得到hello.c文件，而这样的文件仅我们程序员可理解，机器无法理解，也就是programmer（程序员）写出的程序（program），然后经过一系列处理：预处理（预处理器cpp生成hello.i修改的源文件代码）、编译（编译器cc1生成编译文件hello.s）、汇编(汇编器as生成hello.o可重定位目标文件)、链接（链接器ld生成hello可执行目标文件），最后在shell里输入命令运行hello可执行目标文件，shell为其fork一个子进程， hello就实现了从program到process（进程）的转变。</p>
<p>​    020：即: From Zero-0 to Zero-0。shell为hello程序fork进程后，子进程调用execve，将hello加载到内存，由0开始，对hello这个文件进行内存映射，将可执行目标文件中的代码和数据从磁盘中复制到内存中，设置当前进程上下文中的程序计数器，使PC为hello的入口点，然后开始运行hello，运行过程中，PC发生变化，将指令和数据入内存，CPU以流水线形式读取并执行指令，执行逻辑控制流。操作系统负责进程调度，为进程分时间片，进行上下文切换。执行过程其多次访问L1、L2、L3高速缓存、TLB、多级页表等进行存储管理，通过I/O系统进行键盘输入输出来改变异常控制流直到结束。当程序运行结束后，成为僵死进程，hello的父进程shell/bash回收hello进程的内存，hello结束了，又回归到0，则就是O2O过程。</p>
<h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>​    硬件环境：X64 CPU Intel酷睿i7 9750H;2.9GHZ;16G RAM; 512G SSD;</p>
<p>​    软件环境：Windows10 64位；VMware WorkStation Pro16.1；Ubuntu 20.04 LTS；</p>
<p>​    开发工具：Visual Studio 2019 64位；CodeBlocks 64位；GDB；edb-debugger；gedit；</p>
<h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><table>
<thead>
<tr>
<th>文件名称</th>
<th>文件作用</th>
</tr>
</thead>
<tbody><tr>
<td>hello.c</td>
<td>保存hello源代码即源文件</td>
</tr>
<tr>
<td>hello.i</td>
<td>经过预处理的修改了的源文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>编译器编译hello.i生成的汇编文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>编译器编译hello.s生成的可重定位目标文件</td>
</tr>
<tr>
<td>hello.elf</td>
<td>hello.o文件的ELF格式文件，查看hello.o各节的信息</td>
</tr>
<tr>
<td>hello.txt</td>
<td>objdump反汇编hello.o生成的汇编文件与hello.s对比</td>
</tr>
<tr>
<td>hello</td>
<td>链接器重定位、链接生成的可执行目标文件</td>
</tr>
<tr>
<td>hello2.elf</td>
<td>hello文件的ELF格式文件，查看hello各节的信息</td>
</tr>
<tr>
<td>hello2.txt</td>
<td>objdump反汇编hello文件生成的汇编文件</td>
</tr>
</tbody></table>
<h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>​    本章主要简述了hello的诞生，即Hello的简介，介绍了个人的实验环境包括硬件环境和软件环境，以及大作业中用到的开发工具，列出了论文中间文件的名字及作用，是本篇论文的背景和简要介绍。</p>
<p>（第1章0.5分）</p>
<h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>​    预处理的概念：</p>
<p>​    先介绍预处理指令的概念：C 语言编程过程中，经常会用到如 #include、#define 等指令，这些标识开头的指令被称为预处理指令，预处理指令由预处理程序（预处理器）操作。</p>
<p>​    预处理指令及分类：</p>
<p>​    ANSI C 定义的预处理指令主要包括：文件包含、宏定义、条件编译和特殊控制等 4 类。</p>
<ol>
<li><p>文件包含：#include 是 C 程序设计中最常用的预处理指令。例如，几乎每个需要输入输出的 C 程序，都要包含 #include&lt;stdio.h&gt; 指令，表示把 stdio.h 文件中的全部内容，替换该行指令。</p>
<p>此外，包含文件的格式有 #include 后面跟尖括号 &lt;&gt; 和双引号 “” 之分。两者的主要差别是搜索路径的不同。</p>
<p>(1)尖括号形式：如 #include&lt;math.h&gt;，预处理器直接到系统目录对应文件中搜索 math.h 文件，搜索不到则报错。系统提供的头文件一般采用该包含方式，而自定义的头文件不能采用该方式。</p>
<p>(2)双引号形式：如 #include”cal.h”，首先到当前工作目录下查找该文件，如果没有找到，再到系统目录下查找。包含自定义的头文件，一般采用该方式。虽然系统头文件采用此方式也正确，但浪费了不必要的搜索时间，故系统头文件不建议采用该包含方式。</p>
</li>
<li><p>宏定义：包括定义宏 #define 和宏删除 #undef。如我们常用的#define N 5</p>
<p>定义无符号宏，或定义符号常量N;</p>
</li>
<li><p>条件编译：主要是为了有选择性地执行相应操作，防止宏替换内容（如文件等）的重复包含。常见的条件编译指令有 #if、#elif、#else、#endif、#ifdef、#ifndef。</p>
</li>
<li><p>特殊控制：ANSI C 还定义了特殊作用的预处理指令，如 #error、#pragma。</p>
<p>#error：使预处理器输出指定的错误信息，通常用于调试程序。</p>
<p>#pragma：是功能比较丰富且灵活的指令，可以有不同的参数选择，从而完成相应的特 定功能操作。调用格式为：#pragma 参数。</p>
<p>再介绍一下C预处理器（C Pre-Processor）也常简写为 CPP，是一个与 C 编译器独立的小程序，预处理器并不理解 C 语言语法，它仅是在程序源文件被编译之前，实现文本替换的功能。如我们常用#define N 100，其会将程序.c文件所有的N替换为100，仅仅修改程序源文件罢了。</p>
</li>
</ol>
<p>​    预处理过程进行的操作：</p>
<ol>
<li><p>将所有的“#define”删除，并且展开所有的宏定义</p>
</li>
<li><p>处理所有的条件编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”</p>
</li>
<li><p>处理“#include”预编译指令，将被包含的头文件插入到该编译指令的位置。（这个过程是递归进行的，因为被包含的文件可能还包含了其他文件）</p>
</li>
<li><p>删除所有的注释“//”和“/* */”。</p>
</li>
<li><p>添加行号和文件名标识，方便后边编译时编译器产生调试用的行号心意以及编译时产生编译错误或警告时能够显示行号。</p>
</li>
<li><p>保留所有的#pragma编译指令，因为编译器需要使用它们。</p>
</li>
</ol>
<p>​    预处理的作用：</p>
<p>​    我们先看hello.c的源代码</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image002.png"></p>
<center>图2‑1 hello.c的源代码</center>

<p>​    预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。比如上图中hello.c中第一行的代码：#include &lt;stdio.h&gt; 命令高速预处理器读取系统头文件stdio.h的内容，以此类推，第二、三行代码#include &lt;unistd.h&gt;;#include&lt;stdlib.h&gt;则是命令高速预处理器读取系统头文件unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中。结果得到另一个C程序，通常是以.i作为文件拓展名，其是一个修改了的源程序（文本），将源程序文件hello.c进行拓展，便于后面编译。</p>
<h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p>​    在ubutun终端输入如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linux&gt; gcc –E –o hello.i hello.c</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image003.png"></p>
<center>图2‑2 ubutun下预处理命令及生成的hello.i文件</center>



<h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>​    linux下gedit打开刚才所得到hello.i文件进行查看：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image004.png"></p>
<center>图2‑3 hello.i文件的内容</center>

<p>​    从上图可以看到其不再是#include &lt;stdio.h&gt;; #include &lt;unistd.h&gt;;#include&lt;stdlib.h&gt;;等语句，而是高速预处理器读取读取系统头文件stdio.h、unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中，那我们原来main函数的内容还在吗？继续往下查看hello.i的内容，原来hello.c文件中，main函数在最后面，cpp将原来#include的预处理指令替换成系统头文件的内容，那么main函数应该也是在hello.i的末尾，查看后果然如此，前面三千多行都是头文件内容，并未发生变化。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image005.png"></p>
<center>图2‑4 hello.i文件中main函数的内容</center>

<p>​    这里我们就验证了预处理的作用：就是预处理器CPP处理预处理指令，预处理器读取了系统头文件unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中，对原来的预处理指令进行文本替换，得到修改了的源程序hello.i，便于后面的编译器对程序进行编译。</p>
<h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>​    这一章主要先是介绍了预处理指令的概念，通常以#开头，再介绍了预处理器，然后预处理器CPP处理预处理指令，其并不理解 C 语言语法，它仅是在程序源文件被编译之前，实现文本替换的功能，将预处理指令替换，在hello.c文件中就是，预处理器读取了系统头文件unistd.h 、stdlib.h的内容，然后将这些系统头文件的内容直接插入到程序文本中，对原来的预处理指令进行文本替换，得到修改了的源程序hello.i，便于后面的编译器对程序进行编译。</p>
<p>（第2章0.5分）</p>
<h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>​    编译的概念：</p>
<p>​    要介绍编译，就需要先介绍CPU指令集，指令集包括汇编语言形式和二进制机器码格式，然后根据CPU指令集，去完成处理器的架构，就是处理器的硬件架构，称为微架构，是一堆硬件电路，去实现指令集所规定的操作运算。处理器是一堆硬件电路，只能识别二进制数据，所以其执行的是二进制代码或是机器代码（这叫机器指令，机器能理解并且执行），而汇编代码或汇编指令就是人类可读的机器代码的表示，每条汇编指令都有对应的机器码指令。现有CPU架构包括鼎鼎有名的Intel的X86架构（x86指令集）、ARM的ARM架构、MIPS的MIPS架构、DEC的Alpha架构。</p>
<p>​    编译，其就是将我们前一步预处理器CPP对hello.c文件进行预处理之后得到修改的源文件hello.i翻译成文本文件hello.s，把代码转化为汇编代码的过程，编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成机器代码，而编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，是人类可读的，不像机器代码是一串二进制数。</p>
<p>​    编译的作用：</p>
<p>​    编译程序过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p>
<ol>
<li><p>词法分析：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词（亦称单词符号或简称符号），如基本字（begin、end、if、for、while），标识符、常数、运算符和界符（标点符号、左右括号）。</p>
</li>
<li><p>语法分析：在词法分析的基础上，根据语言的语法规则，把单词符号串分解成各类语法单位（语法范畴），如“短语”、“句子”、“程序段”和“程序”等。</p>
</li>
<li><p>词义分析与中间代码产生：对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译（产生中间代码）。</p>
</li>
<li><p>代码优化：优化的任务在于对前段产生的中间代码进行加工变换，以期在最后阶段能产生出更为高效（省时间和空间）的目标代码。</p>
</li>
<li><p>目标代码生成：这一阶段的任务是：把中间代码（或经优化处理之后）变换成特定机器上的低级语言代码。目标代码的形式可以是绝对指令代码或可重定位的指令代码或汇编指令代码。如目标代码是绝对指令代码，则这种目标代码可立即执行。如果目标代码是汇编指令代码，则需汇编器汇编之后才行运行。</p>
</li>
</ol>
<h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>​    在ubutun终端输入如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc –S –o hello.s hello.i</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image006.png" alt="img"></p>
<center>图3‑1 Ubuntu下编译的命令及编译生成的hello.s文件</center>




<h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p>​    先观察hello.c的源代码：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image002.png" alt="img"></p>
<center>图3‑2 hello.c的源代码</center>

<p>​    我们可以发现其中主要定义了3种类型的数据：</p>
<p>​    int argc，main函数的形参全局int型变量：argc，表示传入main函数的参数个数；</p>
<p>​    char *argv[]，main函数的形参全局char指针类型变量：argv，表示传入main函数的参数序列或指针，该指针指向一个字符串数组的首地址。</p>
<p>​    int i；main函数中的局部int型变量：i；</p>
<p>​    再观察其中C语言的操作：</p>
<p>​    先是控制转移和关系操作：if(argc != 4) 一个if判断，if控制转移， !=关系操作；</p>
<p>再是for(i=0;i&lt;8;i++)一个循环，for表示控制转移，=赋值操作，&lt;关系操作，++算术操作，argv[i]数组操作；</p>
<p>​    此外还有函数操作，最常见的printf函数，sleep函数，getchar函数的调用，其中包含了参数传递，最后是main函数返回 return 0。</p>
<p>下面则根据上述这些数据类型及操作说明，编译器是怎么处理C语言的各个数据类型以及各类操作的。</p>
<h3 id="3-3-1常量"><a href="#3-3-1常量" class="headerlink" title="3.3.1常量"></a>3.3.1常量</h3><p>​    这里主要有两个字符串常量，既然是字符串常量，那么存放在文件.rodata节中，只读，如图3-3所示，</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image007.png" alt="img"></p>
<center>图 3‑3 字符串常量</center>


<p>​    那么这两个字符串常量又在哪里使用呢？查看汇编代码可发现，其是printf函数输出的语句，作为参数被传入printf函数调用，如图3-4划线所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image008.png" alt="img"></p>
<center>图 3‑4 字符串常量对应汇编代码</center>


<p>再看对应源代码，其就是被printf函数输出，只是汇编代码中汉字被编码，而不是汉字的形式。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image009.png"></p>
<center>图 3‑5 字符串对应源代码</center>


<h3 id="3-3-2变量"><a href="#3-3-2变量" class="headerlink" title="3.3.2变量"></a>3.3.2变量</h3><p>​    这里主要有三个变量：argc，argv，i；</p>
<p>​    先是argc，其作为main函数的第一个参数，那么根据CPU传参寄存器顺序，其应该保存在%edi中，为什么不是%rdi，因为这里argc为int类型，4字节，32位寄存器%edi恰好放得下，这里就是movl %edi, -20(%rbp)，movl传送双字，4字节，将argc的值保存到栈内%rbp-20处，栈内保存的是局部变量。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image010.png" alt="img"></p>
<center>图 3‑6 参数argc和argv</center>


<p>​       再是第二个参数<em>argv，其应该保存在%rsi中，对应汇编语句movq $rsi,-32(%rbp)；</em>argv是一个指针，指向一个字符串数组，其存储的就是字符串数组的首地址，8字节，64位寄存器%rsi恰好能放得下，movq表示传送四字，8字节，将argv的值保存到栈内%rbp-32处。</p>
<p>​       再是另一个整形变量i，我们在上面的汇编代码中并没有找到，其实因为这里只是对其定义，而未赋值初始化，所以找不到，但是栈内开辟了存储这个局部变量i的空间。在后面.L2节中，对i赋值为0，我们发现了i。如下图所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image011.png" alt="img"></p>
<center>图 3‑7 变量i</center>


<h3 id="3-3-3赋值操作"><a href="#3-3-3赋值操作" class="headerlink" title="3.3.3赋值操作"></a>3.3.3赋值操作</h3><p>​        这里仅有一处赋值操作，对应movl $0, -4 (%rbp)</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image011.png" alt="img"></p>
<center>图 3‑8 赋值i=0</center>


<p>​        movl就是将0传递给栈内%rbp-4处的变量i，也就是将i的值赋为0。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image012.png" alt="img"></p>
<center>图 3‑9 赋值对应源代码</center>


<h3 id="3-3-4算术操作"><a href="#3-3-4算术操作" class="headerlink" title="3.3.4算术操作"></a>3.3.4算术操作</h3><p>​    源代码只有一处算术操作，查看汇编代码，寻找对应汇编语句：</p>
<p>addl $1, -4(%rbp)，如图3-6所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image013.png" alt="img"></p>
<center>图 3‑10 算术操作++</center>


<p>​    通过前面赋值操作已知，栈内%rbp-4存放的是局部变量i，这里是对其进行i+1的算术操作，同时我们可以发现其是.L4段的最后一条语句，.L4段对应for循环体内容，i++就应该在循环体内的语句都执行完以后再执行，然后再判断i&lt;8，符合C语言逻辑。其对应源代码就是：i++;</p>
<h3 id="3-3-5关系操作"><a href="#3-3-5关系操作" class="headerlink" title="3.3.5关系操作"></a>3.3.5关系操作</h3><p>​    源代码共有2处关系操作，我们查看汇编代码来寻找对应的关系操作，先是!=关系操作: cmpl $4, -20(%rbp)</p>
<p>![img](这里仅有一处赋值操作，对应movl $0, -4 (%rbp)</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image014.png" alt="img"></p>
<center>图 3‑11 !=关系操作</center>


<p>​    通过对前面数据的分析，已经得知栈内%rbp-20处存放的是传进main函数的形参argc，这里将其与4比较，mpl指令行为和sub指令的行为指令是一样的，其根据两个操作数之差来设置条件码，下一条汇编指令je，根据条件码，相等才发生跳转.L2执行，不相等则不跳转执行下一条语句，正好对应了图3-5所展示源代码所作的比较。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image015.png" alt="img"></p>
<center>图 3‑12 !=关系操作对于源代码</center>


<p>​    再看另一处关系操作&lt;：cmpl $7, 44(%rbp)</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image016.png" alt="img"></p>
<center>图 3‑13 &lt关系操作</center>


<p>​    通过对前面分析，已经得知栈内%rbp-4处存放的是main函数中定义的局部整型变量i，这里与7作比较，似乎与我们图3-7所示对应源代码不一致，再看下一条汇编指令jle，表示i小于等于7才跳转执行循环，其就等价于i&lt;8，才执行循环，与之相对应。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image017.png" alt="img"></p>
<center>图 3‑14 &lt 关系操作对应源代码</center>


<h3 id="3-3-6控制转移"><a href="#3-3-6控制转移" class="headerlink" title="3.3.6控制转移"></a>3.3.6控制转移</h3><p>​    源代码共有2处控制转移，我们查看汇编代码来寻找对应的控制转移，先是if控制转，对应图3-8划线两条语句所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image018.png"></p>
<center>图 3‑15 控制转移if</center>


<p>​    前面我们已经分析过了关系操作，这里先将argc与4比较对应cmpl，cmpl指令行为和sub指令的行为指令是一样的，其根据两个操作数之差来设置条件码，je根据条件码，argc等于4则跳转执行.L2的代码，不等于就执行下一条语句调用printf函数输出，对应源码图3-5所示的“if(argc!=4);”的这条语句。</p>
<p>再看另一处控制转移，for的控制转移，对应图3-9划线两条汇编代码所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image019.png" alt="img"></p>
<center>图 3‑16 for控制转移的汇编代码</center>


<p>​    前面我们已经分析过了关系操作，这里先将i与7比较对应cmpl，其根据两个操作数之差来设置条件码，jle根据条件码，i&lt;= 7则跳转执行.L4的代码，即for循环体内的代码，i&gt;8则跳出循环执行下一条语句调用getchar函数，对应源码图3-9所示的for循环的源代码。</p>
<h3 id="3-3-7-数组-指针-结构体操作"><a href="#3-3-7-数组-指针-结构体操作" class="headerlink" title="3.3.7 数组/指针/结构体操作"></a>3.3.7 数组/指针/结构体操作</h3><p>​       在源代码中我们共发现了三处数组操作，我们在汇编代码中寻找，如图3-17所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image020.png" alt="img"></p>
<center>图 3‑17 对argv数组的操作</center>


<p>​    我们前面已知%rbp-32存放的是argv，即argv数组的首地址，这里先是通过地址+16的偏移量访问argv[2]，将其传入寄存器%rdx中，再是通过地址+8的偏移量访问argv[1]，将其传入寄存器%rsi中，为下面调用printf函数做传参准备；再往下走，通过地址+24的偏移量访问argv[3]，将其传入寄存器%rdi中，为下面调用atoi函数做传参准备，如下图对应源码。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image021.png" alt="img"></p>
<center>图 3‑18 数组操作对应源码</center>


<h3 id="3-3-8函数操作"><a href="#3-3-8函数操作" class="headerlink" title="3.3.8函数操作"></a>3.3.8函数操作</h3><p>​    这里的函数操作较多，从头到尾先看源码分析。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image022.png" alt="img"></p>
<center>图 3‑19 hello.c中源代码的函数操作</center>


<p>​    第一处调用printf函数输出，汇编代码如图3-20所示，</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image023.png" alt="img"></p>
<center>图 3‑20 第一处printf函数调用</center>


<p>​    我们可以看到，其将.L0存储的字符串传入寄存器%rdi，恰好也是CPU传参使用寄存器的传递第一个参数所用的寄存器，然后简化调用puts函数输出，对应源代码图3-19中划线的1。</p>
<p>​    然后是调用exit函数退出，其汇编代码如图3-21所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image024.png" alt="img"></p>
<center>图 3‑21 调用exit函数退出</center>


<p>​    其先是将1传递到寄存器%edi，恰好也是CPU传参使用寄存器的传递第一个参数所用的寄存器，1为参数，为exit(1)中的‘1’，exit(1)表示异常退出，在退出前可以给出一些提示信息，然后调用exit函数退出，对应源代码图3-19中划线的2。</p>
<p>​    再是第二处调用printf函数输出，汇编代码如图3-22所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image025.png" alt="img"></p>
<center>图 3‑22 第二处调用printf函数</center>


<p>​    之前对数组操作分析可知，通过对栈内存放argv数组首地址加偏移量+16、+8，访问了argv[2]、argv[1]，并将其分别传入寄存器%rdx、%rsi中，传参使用对应寄存器的第三个、第二个，而传参用的第一个寄存器却是传进的.LC1的字符串常量，有些奇怪，与我们的源代码并不符合。这里其实对printf函数的一个理解，其先传进去的是printf函数输出的格式，告诉printf按照一个什么样的格式输出，然后再是传递我们要输出的值的参数，对应源代码图3-19中划线的3。</p>
<p>​    再是调用atoi函数，汇编代码如图3-23所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image026.png" alt="img"></p>
<center>图 3‑23 调用atoi函数</center>


<p>​    之前对数组操作分析可知，通过对栈内存放argv数组首地址加偏移量+24，访问了argv[3]，然后传入%rdi，作为调用atoi函数的参数，atoi是将字符串存储的数转化为整数类型，对应源代码图3-19中划线的4。</p>
<p>​    接着是调用sleep函数，汇编代码如图3-24所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image027.png" alt="img"></p>
<center>图 3‑24调用sleep函数</center>


<p>​    前面我们已经分析了atoi函数的调用，其将argv[3]作为参数，将argv[3]字符串类型转换为整数数值，然后返回，其返回值就保存在寄存器%eax中，然后这里在传递给%edi，变成了sleep函数的参数，然后调用sleep函数，对应源代码图3-19中划线的5。</p>
<p>​    再接着是调用getchar函数，汇编代码如图3-25所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image028.png" alt="img"></p>
<center>图 3‑25 getchar函数的调用</center>


<p>​    这里getchar函数的调用的汇编代码较为简单，但没有运行，不知道其功能，猜测可能是读取键盘输入，对应源代码图3-19中划线的6。</p>
<p>​    然后最后一个函数操作，汇编代码如图3-26所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image029.png" alt="img"></p>
<center>图3‑26 main函数返回</center>

<p>​    这里也较为简单，main函数结尾return 0；返回值设为0，保存在寄存器%eax中，然后main函数返回，程序退出。对应源代码图3-19中划线的7。</p>
<h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>   本章主要介绍编译，编译是C语言编译器对经过预处理后修改完的源代码hello.i文件的一个翻译，基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例将其翻译为人类可读、可理解的二进制代码或者说机器代码的文本表示——汇编代码，保存在hello.s文件中，依然是文本文件，接下来一步就是将汇编代码通过汇编器转换为机器代码，机器可读懂并执行的代码，一串二进制数，人很难理解。所以汇编代码就十分重要，其可以帮助我们去查看用高级语言所写代码在计算机内运行的逻辑及过程，理解汇编代码，可以帮助我们debug以及运用维护，同时也要注意到，有时候编译器会程序进行一定的优化，会改变一些库函数的调用，比如我们第一处调用printf函数，其计算机实际调用的却是puts函数。</p>
<p>（第3章2分）</p>
<h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>​    汇编的概念：</p>
<p>我们都知道，计算机的硬件作为一种电路元件，它的输出和输入只能是有电或者没电，也就是所说的高电平和低电平，所以计算机传递的数据是由“0” 和“1”组成的二进制数，所以说二进制的语言是计算机语言的本质，那么就有了机器指令的概念。</p>
<p>​    要讲汇编，需要先理解指令，之前我们在汇编部分已有谈及，这里给出更明晰的定义：指令被编码为有一个或多个字节序列组成的二进制格式一个处理器支持的指令和指令的字节级编码成为它的指令集体系结构，像Intel IA32和x86-64，x86-64也就是我们现在电脑windows系统所用的指令集体系结构。 </p>
<p>​    这里就是汇编器（as）将前面得到汇编文件hello.s从汇编语言指令翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并讲解结果保存在文件hello.o中，hello.o是一个二进制文件，其包含的字节是main函数的指令编码，这些指令的编码是基于该电脑上的指令集体系结构，用文本编辑器打开，将看到一堆乱码，人类完全无法读懂，但是计算机可以读懂并且执行，但部分要经过后续的链接才能执行。</p>
<h2 id="4-2在Ubuntu下汇编的命令"><a href="#4-2在Ubuntu下汇编的命令" class="headerlink" title="4.2在Ubuntu下汇编的命令"></a>4.2在Ubuntu下汇编的命令</h2><p>在ubutun终端输入如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; gcc –c hello.s –o hello.o</span><br></pre></td></tr></table></figure>

<p>如下图4-1所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image030.png" alt="img"></p>
<center>图 4‑1 Ubutun下汇编的命令及汇编生成hello.o文件</center>



<h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p>​    分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</p>
<p>​    Ubutun终端输入以下命令：linux&gt; readelf –a hello.o &gt; hello.elf</p>
<p>​    readelf读出hello.o——ELF可重定位目标文件所有信息，保存到hello.elf文件中，便于查看。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image031.png" alt="img"></p>
<center>图 4‑2 readelf读取信息并保持到hello.elf文件</center>

<p>​    先回顾典型ELF可重定位目标文件的格式，如图4-2所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image032.png" alt="img"></p>
<center>图 4‑3 典型ELF可重定位目标文件</center>

<p>​    然后打开hello.elf文件分析。</p>
<p>​    先是ELF 头：描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。如图4-3所示。我们对此分析：首先是magic，</p>
<p>​    一个16字节的序列，描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息， 其中包括 ELF 头的大小、目标文件的类型、 机器类型、字节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量等信息。观察其指明了该ELF文件类别为ELF64文件，数据是64位，采用补码为2的小端法存储，系统架构为X86-64，该文件为REL，可重定位文件，程序入口点地址为0x0，节头部表条目数量为14，大小为64字节，偏移量为1240字节，还有符号表等信息。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image033.png" alt="img"></p>
<center>图 4‑4 ELF 头</center>

<p>​    再是节头部表：描述目标文件的节，如图4-4所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image034.png" alt="img"></p>
<center>图 4‑5 节头部表信息</center>

<p>​    节头部表也是段表，我们观察到有14个节，其给出各个节的节名，在文件中的偏移、大小、访问属性、对齐信息等等。这些数据是由段表中一系列段描述符承载完成的，其中最为重要的就是下一步链接所要使用的信息：该段符号表的位置及重定位表的信息。 </p>
<p>​    下面针对其比较重要的几个节来说明：</p>
<p>​    .text节: 存储已编译程序的机器代码，大小为0x92字节，偏移量为0x0;</p>
<p>​    .rodate节: 存储只读数据，如字符串常量，大小为0x33字节，偏移量为0xd8。</p>
<p>​    .data节: 存储已初始化的全局和静态C变量，大小为0x0字节，偏移量为0xd2。</p>
<p>​    .bss节: 存储未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量，大小为0x0字节，偏移量为0xd2。</p>
<p>​    .symtab节: 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息，大小为0x1b0字节，偏移量为0x180。</p>
<p>​    .strtab节: 一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字，大小为0x48字节，偏移量为0x340。</p>
<p>​    .rela.text节：一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这信息。大小为0xc0字节，偏移量为0x388。</p>
<p>​    再是重定位节：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image035.png" alt="img"></p>
<center>图 4‑6 重定位节</center>

<p>​    先介绍重定位的概念：重定位是连接符号引用与符号定义的过程。例如，程序调用函数时，关联的调用指令必须在执行时将控制权转移到正确的目标地址。可重定位文件必须包含说明如何修改其节内容的信息。通过此信息，可执行文件和共享目标文件可包含进程的程序映像的正确信息。重定位项即是这些数据。该信息就存储在重定位节中。</p>
<p>​    重定位节’.rela.text’：一个.text节中位置的列表，包含.text 节中需要进行重定位的信息，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者应用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改，就如图4-6所示，hello.o的重定位信息：各个节的符号名称、符号值、加数、类型、偏移量、信息等等。</p>
<p>​    最后是符号表：一个符号表，用来存放程序中定义和引用的函数和全局变量的信息。每个重定位文件都在.symtab中都有符号表，需要引用的符号都在其中声明。如图4-7所示，里面有我们在hello.c中看到几个函数的符号：exit，printf，atoi等等。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image036.png" alt="img"></p>
<center>图 4‑7 符号表</center>



<h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt;objdump -d -r hello.o</span><br></pre></td></tr></table></figure>

<p>​    如图4-8所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image037.png" alt="img"></p>
<center>图 4‑8 objump反汇编并保存为hello.txt文件</center>

<p>​    反汇编得到文件后，打开查看：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image038.png" alt="img"></p>
<center>图 4‑9 hello.o反汇编文件内容</center>

<p>​    发现与我们在第3章编译得到的hello.s的汇编代码并不一样，有很多差异。 </p>
<p>​    首先我们发现其开头表明其是由hello.o文件反汇编得到，文件格式为elf64-x86-64，而不是我们然后我们之前hello.s文件的存储的字符串常量.LC0和.LC1，在hello.s中，访问全局变量是通过字节使用声明中的助记符+off+%rip来实现的；而在这里hello.o反汇编代码中，访问全局变量是通过用$0x0(%rip)来确定，其因为.data与.rodata段中的数据地址在链接运行后时才确定的，因此，对全局变量的访问需要重定位，全局变量的访问需要添加重定位条目。</p>
<p>​    此外，其左侧多了一栏地址（格式为xx:）,以及一串十六进制数，如4: 55，4：表示地址，55则表示指令的字节级编码，是由汇编指令翻译而来，其再翻译成二进制数，就是低级语言，机器指令或是机器语言。以sub $0x20,%rsp这条汇编指令举例，其意思为将寄存器%rsp存储的值减去-0x20然后存储在寄存器内，其对应的指令的字节级编码为48 83 ec 20。我们这里解析一下这个指令编码，其与汇编代码的对应关系。每条指令需要1-10个字节不等，这取决于需要哪些字段，此外每个字节编码都只有唯一的结束，任何一个字节序列要么就是一个为的指令序列的编码，要么就不是一个合法的字节序列。</p>
<p>​    指令的编码为48 83 ec 20共8位，按顺序放。</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">3</td>
<td align="center">e</td>
<td align="center">c</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>​    每条指令的第一个字节表明指令的类型，这里就是0、1两位存储的一个字节，这个字节分为两个部分，每部分4位：高4位是代码部分，低4位是功能部分，这里0存储的就是高4位代码部分，表明其是什么操作，整数操作、分支条件传送或是函数操作等等；这里1存储的就是低4位功能部分，0里面存储的4表示整数操作，8表示是整数操作里面的减法操作。再接着往下看2、3位存储的字节，是寄存器指示符字节，指定一个或两个寄存器，根据指令类型，其可以指定用于数据源和目的寄存器，或是用地址计算的基址寄存器，其表明使用的寄存器的编号，如3位存储的3为该指令集下寄存器%rsp的相对应的标识符。再往下看是一个常数字，6、7两位存储的0x20，表明要减去立即数0x20。同时我们可以看到，地址8的下一条语句的地址是c，而不是9，有些奇怪，其实这里的地址是等于上一条语句的地址+指令的字节数，这里上一条语句地址为8，指令的字节数为4，8+4=12，反以十六进制就是12。</p>
<p>​    下面还有一个明显区别就是，分支转移。我们在第3章可以观察到其发生跳转都是跳转到另一段中，使用助记符.LX，例如.L2，.L4等。而在反汇编代码中，我们可以发现转跳指令语句中目的地址使用的是实际地址，如&lt;main+0x20&gt;等等。如图4-10所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image039.png" alt="img"></p>
<center>图 4‑10 hello.o与hello.s跳转转移的对应</center>

<p>​    再看函数调用也有区别，在hello.s文件中，函数调用call的对象直接就是调用函数名称，而在hello.o反汇编中，call 的对象却是目标地址，而不是之前的函数名称，而是当前下一条指令地址，但这并不是目标函数的地址，其是因为hello.c中调用的函数不是本地函数，而是共享库中的函数，需要通过动态链接器要将共享库与程序链接后才能确定函数的运行时真正的地址，而在hello.o可重定位文件生成为机器语言的时候，这些地址并不确定，所以被称为可重定位文件，对于这些不确定地址的函数调用，将其call指令后的相对地址设置为全目标地址正是下一条指令，然后在.rela.text节中为其添加重定位条目，在连接阶段静态链接会重定位。如图4-11所示</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image040.png" alt="img"></p>
<center>图 4‑11 函数调用的对应</center>

<p>​    </p>
<h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>​    本章先是介绍了汇编的概念及作用，汇编器as将前面得到汇编文件hello.s从汇编语言指令翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式hello.o文件，分析了elf文件的内容，包含的elf头、符号表、.text节等等各种信息，说明其为什么是可重定位文件，其还要经过后续的链接重定位才可运行。然后比较了hello.o饭汇编文件与hello.s编译文件的差异，同为汇编代码，却在表达上有种种差异，如条件转移，函数调用，同时也讲明了汇编代码与机器代码的映射，指令字节级编码的概念。</p>
<p>（第4章1分）</p>
<h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p>​    链接是链接器（ld）将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行与加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是有应用程序来执行。链接由链接器的程序自动执行的。</p>
<p>​    链接器在软件开发中扮演着一个关键的角色，因为他们使得分离编译成为可能。我们不用讲一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块的一个时，只需要简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
<p>​    举例：hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。结果就是得到hello文件，他是一个可执行目标文件，可以被加载到你内存中，由系统执行。</p>
<h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Linux&gt;ld -o hello -dynamic-linker /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span></span><br><span class="line"></span><br><span class="line"> /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o </span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure>

<p>(注意：其是连续的而不是隔开的的，如图5-1所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image041.png" alt="img"></p>
<center>图 5‑1 链接指令及链接生成的hello可执行目标文件</center>



<h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>​    Ubutun终端输入下列命令，将其保存到hello2.elf文件中，与之前读取hello.elf区别开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; readelf -a hello &gt; hello2.elf</span><br></pre></td></tr></table></figure>



<p>​    同样先回顾一下典型的可执行目标文件的ELF格式，如图5-2所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image042.png" alt="img"></p>
<center>图 5‑2 典型的ELF可执行目标文件</center>

<p>​    可以发现可执行目标文件的ELF格式与可重定位目标文件的ELF格式基本一致，但其少了部分内容，少了rela.text等等，虽少了这些内容，但hello的ELF文件内容较hello.o多了许多，内容上有差异，我们将hello和hello.o对照观察，有些差异，如图5-3所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image043.png" alt="img"></p>
<center>图 5‑3 hello文件elf格式与hello.o文件elf格式对比</center>

<p>​    从hello文件elf格式与hello.o文件的elf格式的对比，可以观察到，文件类型由hello.o的可重定位文件（REL）变为hello的可执行文件（EXEC），入口点地址也由0变为0x4010f0，程序头起点也由0变为64字节，节头部的开始由1240变为14208，</p>
<p>​    节的数量和程序头的数量都变多了。</p>
<p>​    下面查看hello的ELF文件其各段的基本信息，包括各段的起始地址、大小、偏移量、对齐等信息等，如图5-4及5-5所示。<img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image044.png" alt="img"></p>
<center>图 5‑4 hello的ELF格式的节的信息1 </center>

<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image044.png" alt="img"></p>
<center>图 5‑5 hello的ELF格式的节的信息2</center>

<p>​    hello文件的ELF格式还较hello.o文件的ELF格式多出了一个程序头的内容：程序头表描述了可执行文件的连续片与连续内存段之间的映射关系，根据程序表头的内容，可以根据可执行文件的内容初始化两个内存片段。如下图5-6所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image046.png" alt="img"></p>
<center>图 5‑6 hello文件程序头的内容</center>

<p>​    此外还多了段节的内容以及动态节的内容，如图5-7所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image047.png" alt="img"></p>
<center>图 5‑7 段节及动态节的内容</center>

<p>​    可重定位节的内容也发生了改变，多了我们hello中所调用系统库内函数的内容。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image048.png" alt="img"></p>
<center>图 5‑8 重定位节的内容</center>

<p>​    此外，符号表的内容也大大增多，包含51项，较原来的18项大大增多。如下图5-9所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image049.png" alt="img"></p>
<center>图 5‑9 符号表的内容</center>



<h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p>​    使用edb加载hello，查看本进程的虚拟地址空间各段信息，并与5.3对照分析说明。  </p>
<p>edb运行hello程序，打开data dump可查看hello进程的虚拟地址空间各段信息，如图5-10所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image050.png" alt="img"></p>
<center>图 5‑10 hello的虚拟地址空间</center>

<p>​     观察发现程序被分配到虚拟地址为0x0400000~0x0405000的虚拟空间上，同时我们观察到点运行后，跳转到地址0x0401000，刚好与我们刚才elf文件（图5-3所示）读出信息，程序入口点地址为0x401000一致，结束地址为0x0401ff0，各个段的顺序与节表头的顺序一一对应。</p>
<p>​    举例说明：</p>
<p>​    根据ELF文件读出信息查看：先是ELF头：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image051.png" alt="img"></p>
<center>图 5‑11 ELF头从0x400000开始</center>

<p>​    再是.interp段的地址，存储着动态链接共享库路径：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image051.png" alt="img"></p>
<center>图 5‑12 .interp从0x4002e0开始</center>

<p>​    此外，我们再查看ELF 格式文件中的程序头，程序头表在执行的时候被使用，通过表中的信息我们可以得知内存与段之间的映射关系，表中得到每一个项提供了各段的基本信息，如图5-11所示，其中offset表示偏移，birtAddr就表示虚拟地址的起始，physAddr表示物理地址的起始，FileSiz表示目标文件中的段大小，MemSiz表示内存中的段大小，Flags表示运行时访问权限，最后Align表示对齐。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image053.png" alt="img"></p>
<center>图 5‑13 程序表头的内容</center>

<p>​    程序表头主要有以下几个内容：</p>
<ol>
<li><p>PHDR：保存程序头表。</p>
</li>
<li><p>INTERP：指定在程序已经从可执行文件映射到内存之后，必须调用的解释</p>
</li>
</ol>
<p>器（如动态链接器）。</p>
<ol start="3">
<li>LOAD：只读代码段。</li>
<li>LOAD：读写数据段：表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串） 、程序的目标代码等。</li>
<li>DYNAMIC：保存了由动态链接器使用的信息。</li>
<li>NOTE：保存辅助信息。</li>
<li>GNU_STACK： 权限标志，标志栈是否是可执行的。</li>
<li>GNU_RELRO： 指定在重定位结束之后那些内存区域是需要设置只读。</li>
</ol>
<h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>​    objdump -d -r hello 分析hello与hello.o的不同，说明链接的过程。</p>
<p>​    在linux终端下输入下列命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux &gt; objdump –d –r hello &gt; hello2.txt</span><br></pre></td></tr></table></figure>

<p>​    将hello可执行文件反汇编的内容保存到hello2.txt文件中，与hello.o文件做区别，如图5-12所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image054.png" alt="img"></p>
<center>图 5‑14 hello文件反汇编得到hello2.txt</center>

<p>​    然后将二者比对来看： </p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image055.png" alt="img"></p>
<center>图 5‑15 hello.o文件与hello文件反汇编对比 </center>

<p>​    我们发现，程序入口地址其由原来的0变成0x401000，此外也不是以mian函数开始，而是以init函数开始，地址在链接器重定位后，变成了CPU实际分配的虚拟地址，其地址计算是通过0x040000+数据所在节的地址+再加节内偏移量即可得出；此外还多了许多我们在hello里面调用函数的内容，像是puts、getchar等等库文件的内容，如图5-14所示，这是我们之前hello.o反汇编文件里面所没有看到，变化这样一来也是验证了链接，将共享库的内容与hello.o的内容链接、合并了进来。其中</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image056.png" alt="img"></p>
<center>图 5‑16 hello反汇编文件调用函数的内容</center>

<p>​    此外，还多出了一些节的内容，像是_init等等。多出来节的作用：</p>
<p>​    .init: 程序初始化执行的代码；</p>
<p>​    .plt: 静态连接的连接表；</p>
<p>​    .plt.got: 保存函数引用的地址；</p>
<p>​    .fini: 程序正常终止时执行的代码。</p>
<p>​    然后介绍重定位的概念：</p>
<p>​    重定位：在连接阶段，连接器将所有的相同类型的节合并为同一类型的新的聚合节，然后连接器将运行时内存地址赋值给新的聚合节，赋值给输入模块定义的每个节，以及以及赋值给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址。</p>
<p>​    重定位节中的符号引用：在这一步中，连接器修改代码节的符号节中的引用，使它们指向正确的运行时地址，完成这一步，连接器需要依赖可重定位目标模块中称为重定位条目。</p>
<p>​    给出重定位条目的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span>   offset;             <span class="comment">//节内偏移</span></span><br><span class="line">	<span class="keyword">long</span>   type:<span class="number">32</span>,          <span class="comment">//重定位类型</span></span><br><span class="line">	 	   symbol:<span class="number">32</span>;         <span class="comment">//说绑定的符</span></span><br><span class="line">	<span class="keyword">long</span>   addend;           <span class="comment">//偏移调整</span></span><br><span class="line">&#125;Elf64_Rela</span><br></pre></td></tr></table></figure>



<p>​    我们先看hello.o文件的重定位节的内容，然后举例说明</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image057.png" alt="img"></p>
<center>图 5‑17 hello.o重定位条目与hello.o反汇编文件的对应</center>

<p>​    图5-17中R_X86_64_PC32：32位相对地址引用，一个PC相对地址就是据程序计数器（PC）的当前运行值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的地址。图5-17中.rodata-4就是PC相对寻址。</p>
<p>​    那么符号（symbol）puts偏移（offset）是21，类型（type）是R_X86_64_PLT32，</p>
<p>addend为-4；</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image058.png" alt="img"></p>
<center>图5‑18puts函数在hello文件里的地址</center>

<p>​    当运行到call puts函数这条语句的PC值为下一条语句的地址：0x40114a，再看call这条机器指令的字节级编码：e8表是call，后面的46 ff ff ff则是相对寻址的偏移量</p>
<p>​    小端存储，为0xffffff46 = -0xba</p>
<p>​    故call 指令后面的地址值为0x40 114a-0xba=0x401090。</p>
<h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><p>使用edb执行hello，从加载hello到_start，到call main,以及程序终止的所有过程。</p>
<table>
<thead>
<tr>
<th>调用程序</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>ld-2.31.so!_dl_start</td>
<td>0x00007f58fe20fb30</td>
</tr>
<tr>
<td>ld-2.31.so!_dl_init</td>
<td>0x00007f58fe20fbc0</td>
</tr>
<tr>
<td>hello!_start</td>
<td>ox4010e0</td>
</tr>
<tr>
<td>libc-2.31.so!_libc_start_main</td>
<td>0x00007fe977429bc0</td>
</tr>
<tr>
<td>ld-2.31.so!_dl_fixup</td>
<td>0x00007ffed6dbae70</td>
</tr>
<tr>
<td>libc-2.31.so!_cxa_atexit</td>
<td>0x00007ffed6a1b700</td>
</tr>
<tr>
<td>libc-2.31.so!_libc_csu_init</td>
<td>0x401260</td>
</tr>
<tr>
<td>libc-2.31.so!_setjmp</td>
<td>0x00007ffed6a166d0</td>
</tr>
<tr>
<td>hello!main</td>
<td>0x4011d6</td>
</tr>
<tr>
<td>hello!puts@plt</td>
<td>0x401090</td>
</tr>
<tr>
<td>hello!exit@plt</td>
<td>0x4010b0</td>
</tr>
<tr>
<td>ld-2.31.so!_dl_fixup</td>
<td>0xo0007ffcd6dbae70</td>
</tr>
<tr>
<td>libc-2.31.so!exit</td>
<td>0x00007f69325cf4b0</td>
</tr>
<tr>
<td>libc-2.31.so!_run_exit_handlers</td>
<td>0x00007f69325cf390</td>
</tr>
</tbody></table>
<h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>​    分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。</p>
<p>​    动态链接的概念：</p>
<p>​    动态链接，在可执行文件装载时或运行时，由操作系统的装载程序加载库。大多数操作系统将解析外部引用（比如库）作为加载过程的一部分。</p>
<p>以下两个概念较为重要</p>
<ol>
<li><p>装载时重定位：对于动态共享库中的函数，在编译阶段无法获得其真实地址；在动态连接阶段，连接器将共享函数设置一个重定位项，其中包含重定位信息（ADDR(.plt)+offset）和符号表信息，然后在运行时根据重定位项信息才能确定其真实地址。</p>
</li>
<li><p>PIC（地址无关代码）：动态链接库希望所有进程共享指令段而各自拥有数据段的私有副本，为了实现这个目标，就要采用与地址无关代码的技术。该实现的基本思想是：把指令中需要修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分则在每个进程拥有一个副本。</p>
</li>
</ol>
<p>​    在之前读取hello的ELF格式文件时，发现了一个dynamic section。假如一个object文件参与动态的连接，它的程序头表将有一个类型为PT_DYNAMIC</p>
<p>的元素。该“段”包含了.dynamic sectio。说明有下列这些项目参与了动态的链接，</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image059.png" alt="img"></p>
<center>图 5‑19 Dynamic section</center>

<p>​    此外，我们分析在dl_init前后，观察这些项目的内容变化。</p>
<p>​    我们先观察没有dl_init的.plt和.pot的内容，如图所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image060.png" alt="img"></p>
<center>图 5‑20 未dl_init的内存</center>

<p>​    dl_init后.plt和.pot的内容，如图所示</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image061.png" alt="img"></p>
<center>图 5‑21 dl_init后的内存</center>

<p>​    可以发现，原先有些内存存储的是0被赋值，其内容对应着那些动态链接进来的项目，举例第二行的地址内容即为以下函数的地址;libc-2.31.so!_libc_start_main , ox00007fe977429bc0。</p>
<p>​    同时还可以发现其增加了链接了一些库，如图所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image062.png" alt="img"></p>
<center>图 5‑22 dl_init后增加的库</center>



<h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>​    本章主要介绍了链接的概念，链接器（ld）将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。其中我们观察了链接前后，hello.o的elf格式文件与hello的elf格式文件内容上的差异，以及由二者反汇编代码的差异去分析、理解链接的概念，包括重定位等等。</p>
<p>（第5章1分)</p>
<h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h1><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p>​    进程：一个执行中程序的实例，系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正常运行所需的状态组成。</p>
<p>​    关注进程提供给应用程序的关键抽象：</p>
<ol>
<li><p>一个独立的逻辑控制流，他提供一个假象，好像我们的程序独占地使用处理器；</p>
</li>
<li><p>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。</p>
<p>创建：父进程调用fork函数创建一个新的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。</p>
</li>
</ol>
<p>回收方法：</p>
<p>​    1. 当一个进程终止时，内核并不是立即把它从系统中清除，直到被其父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，完成进程回收。</p>
<pre><code>2. 如果一个父进程终止了，内核会安排init进程成为其子进程的父进程，负责回收父进程已终止的子进程。
</code></pre>
<h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p>​    shell是一个用C语言编写的程序，通过Shell用户可以访问操作系统内核服务，类似于DOS下的command和后来的cmd.exe。shell既是一种命令语言，又是一种程序设计语言。shell是一个应用程序。shell还是系统的用户界面，提供了用户与内核进行交互操作的一种接口，其接收用户输入的命令并把它传入内核去执行。</p>
<p>​    shell的功能：</p>
<ol>
<li><p>当shell作为命令语言，它交互式地解释和执行用户输入的命令；</p>
</li>
<li><p>当shell作为程序设计语言，它定义了各种变量、参数、函数、流程控制等等。它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。</p>
</li>
</ol>
<p>shell的处理流程：</p>
<ol>
<li>从终端读取输入的命令。</li>
<li>将输入字符串切分获得所有的参数</li>
<li>如果是内置命令则调用内部函数立即执行，否则调用相应的程序执行</li>
<li>shell可接受键盘输入信号，并对这些信号进行相应处理</li>
</ol>
<h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>​    在linux在终端下执行下列语句来启动hello程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linux&gt; ./hello <span class="number">1190201307</span> 徐伟 <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>​    看到屏幕输出： Hello 1190201307 徐伟 </p>
<p>且程序没有停止，直到过了30s后才结束，这里就表明运行了hello这个程序。</p>
<p>​    shell从命令行读取了这行命令，然后对其进行解析，判断非内置命令，而是运行程序，调用fork机制，为这个程序fork了一个进程，为shell的子进程，与shell同属一个进程组，进程组号相同，这里hello进程pid为31524，新创建的子进程拥有几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，其意思是当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别在于它们拥有不同的 PID。此外，父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。如果在shell上无作特殊说明，则在子进程执行期间，父进程（shell）默认选项是显式等待子进程的完成，如指定为后台程序，则无需等待子进程完成。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image063.png" alt="img"></p>
<center>图 6‑1 为hellofork的进程</center>

<p>​    下面用一个进程图来说明Hello的fork进程创建过程。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image064.png" alt="img"></p>
<center>图 6‑2 hello的fork进程创建</center>



<h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>​    因为shell判断出hello不是内置命令，且hello是一个可执行文件，所以shell在当前进程的上下文中调用execve函数加载并运行hello程序，且带参数列表argv和环境变量列表envp。argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串，按照惯例，argv[0]是可执行目标文件的名字，所以我们可以想到hello.c文件中，其访问的是argv[1],argv[2],argv[3]，存储的参数分别是我们的学号、姓名、sleep时间的字符串，就是刚才我们在终端输入“1190201307 徐伟 30”，即为参数。环境变量的列表是有一个类似的数据结构表示的，envp变量指向一个以null结尾的指针数组，其中每一个指针指向一个环境变量字符串。execve是通过调用驻留在存储器中称为加载器的操作系统代码来运行hello， 其删除进程现有虚拟内存映射关系，给hello分配新的虚拟内存地址,并映射hello中的文件或匿名文件至虚拟内存中。然后跳转至_start函数，再通过调用libc_start_main函数初始化环境变量等内容，并将程序执行至main函数入口。加载器将可执行目标文件中的代码和数据从磁盘中复制到内存中，然后通过跳转到程序的第一条指令或者入口点来运行hello。</p>
<h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>​    前面已经介绍过了进程的概念。我们提到了进程向每个程序提供了一个假象，好像它在独占地使用处理器。如果用调试器单步之形成，可以看到一系列的程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享库对象中的指令。这个PC值的序列就叫叫做逻辑控制流，简称逻辑流。若一个逻辑流的执行时间和另一个流重叠，则成为并发流，这两个流被称为并发地运行。多个流并发地执行地一般现象被称为并发。一个进程和其他进程轮流运行的概念为多任务，一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此多任务也叫做时间分片。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image065.png" alt="img"></p>
<center>图 6‑3 逻辑并发流</center>

<p>​    而操作系统内核则使用上下文切换的较高层形式的异常控制流来实现多任务。</p>
<p>​    内核为每一个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态。它由包括目的寄存器、程序计数器、用户栈、状态寄存器在内的对象的值构成。</p>
<p>​    当子进程调用exceve()函数在上下文中加载并运行hello程序后，hello程序不会立即运行，需要内核调度它。进程调度是由内核中称为调度器的代码处理的。当内核选择一个新的进程运行时，就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称为上下文切换的机制来将控制转移到新的进程。</p>
<p>​    处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。通常用某个控制寄存器的一个模式位来提供这种机制，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程运行在内核模式中，进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置；没有设置模式位时，进程运行在用户模式中，进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据，否则会导致保护故障。运行应用程序代码的进程初始时在用户模式中，进程需要通过中断、故障或者陷入系统调用这样的异常才能从用户模式变为内核模式。</p>
<p>​    由于负责进程调度的是内核，因此内核调度需要运行在内核模式下。当内核代表用户执行系统调用时，可能会发生上下文切换，中断也可能引发上下文切换。同时，系统通过某种产生周期性定时器中断的机制判断当前进程已经运行了足够长的时间，并切换到一个新的进程。</p>
<p>​    然后分析我们的hello的例子，当调用printf函数时，需要访问内核，这时就会进行上下文切换，于是进程就会从用户模式切换到内核模式。再比如说当hello进程调用sleep时，由于sleep是系统调用，进程陷入内核模式。这时hello进程被挂起，内核会选择调度其他进程，通过上下文切换保存hello进程的上下文，将控制传递给新调度的进程。定时器的时间到了后会发送中断信号，进入内核模式，将挂起的hello进程变成运行状态，这时hello进程就可以等待内核调度它。当从内核模式变回用户模式时，可能就返回切换到另一个进程了。这时会进行上下文切换，切换过程一般可分为3个部分，分别为：</p>
<p>​    （1）保存当前进程的上下文；</p>
<p>​    （2）恢复要执行进程之前保存的上下文；</p>
<p>​    （3）将控制传递给新恢复的进程。如图6-4所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image066.png" alt="img"></p>
<center>图 6-4 hello的上下文切换</center>



<h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><p>​    hello执行过程中，四类异常都可能会出现：故障，中断，陷阱，终止，图6-5总结了异常的类别。</p>
<p>​    故障：由错误情况引起的，它可能能够被故障处理程序修正。如果修正成功，则将控制返回到引起故障的指令，否则将终止程序。</p>
<p>​    中断：中断是来自IO设备的信号，异步发生，中断处理程序对其进行处理，泛回后继续执行调用前待执行的下一条代码，就像没有发生过中断。</p>
<p>​    陷阱:有意的异常，是执行一条指令的结果，调用后也会返回到下一条指令，用来调用内核的服务进行操作。帮助程序从用户模式切换到内核模式。</p>
<p>​    终止：是不可恢复的致命错误造成的结果，通常是一些硬件的错误，处理程</p>
<p>序会将控制返回给一个abort例程，该例程会终止这个应用程序。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image067.png" alt="img"></p>
<center>图 6‑5 异常的类别</center>

<p>​    （1）正常执行：hello程序正常执行，途中不作任何中断程序的输入，同时尝试键盘乱按，发现乱按会将乱按的输入的输出，  在执行完毕之后，hello进程被其父进程回收，同时getchar会读取键盘输入作为shell终端指令的输入，如图6-6所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image068.png" alt="img"></p>
<center>图 6‑6 hello正常执行</center>

<p>​    （2）键盘输入Ctrl+c，给正在运行的前台作业hello发送SIGINT信号，终止其进行，如图6-7所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image069.png" alt="img"></p>
<center>图 6‑7 hello被Ctrl+c终止</center>

<p>​    再使用linux&gt; ps 查看是否有这个hello进程，发现没有hello程序。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image069.png" alt="img"></p>
<p>​    <center> 图6-8 查看进程信息</center></p>
<p>​    （3）键盘输入Ctrl+z，给正在运行的前台作业hello发送SIGSTP信号，停止其进行，并且ps查看进程，发现其已停止，如图6-9所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image071.png" alt="img"></p>
<center>图 6-9 hello被Ctrl+z停止</center>

<p>​    再使用linux&gt;jobs查看当前shell的任务信息，linxu&gt;pstree打印进程关系树，显示进程之间的关系。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image072.png" alt="img"></p>
<center>图6-10 jobs查看任务信息及pstree查看进程关系树</center>

<p>​    此外linux&gt; bg，可以让暂停被提交至后台的hello作业转到前台继续运行，最后linux&gt;kill -9 pid ，杀死hello进程，终止其运行，如图6-10所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image073.png" alt="img"></p>
<center>图 6-11 杀死hello进程</center>



<h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>​    本章主要涉及到异常控制流的内容，引入了进程、上下文的概念，简述了壳Shell-bash的作用与处理流程，结合hello程序讲述了hello的fork进程创建过程、hello的execve过程和hello的进程执行，一个程序在计算机里运行的状态，前台作业或后台作业，以及运行各种可能出现的异常，以及对异常的处理，主要是各种来自键盘的中断等等。</p>
<p>（第6章1分）</p>
<h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p>​    先分别给出这4种地址的概念：</p>
<p>​    逻辑地址（Logical Address）：包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在80x86著名的分段结构中表现得尤为具体，它促使windows程序员把程序分成若干段。每个逻辑地址都由一个段地址和偏移量组成，偏移量指明了从段开始的地方到实际地址之间的距离。实际上也就是hello.o中的我们看到的以及hello.o的ELF格式文件中我们看到了偏移量及相对偏移地址。</p>
<p>​    线性地址：逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址后加上基地址就是线性地址。</p>
<p>​    虚拟地址：由CPU生产，经过MMU转换可以转换为物理地址，虚拟地址实际上就是一种线性地址。我们在hello反汇编文件中看到的就是虚拟地址。</p>
<p>​    物理地址：用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚按发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每一个字节都有一个唯一的物理地址。在hello得到虚拟地址后，通过查询页表等分页机制，将其转化为物理地址，到内存或磁盘中寻址，读取文件。</p>
<p>​    其关系如图7-1所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image074.png" alt="img"></p>
<center>图 7‑1 4类地址之间关系</center>

<p>​    hello.c在汇编生成hello.o可重定位目标文件后，还未与共享库链接，所以这里hello.o的反汇编代码体现的就是逻辑地址，仅有偏移量。再到重定位链接生成hello可执行文件，此时反汇编代码所体现的就是虚拟地址。</p>
<h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>​    段式内存管理方式就是直接将逻辑地址转换成线性地址，一个逻辑地址由两部份组成，段标识符: 段内偏移量。段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节。如7-2所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image075.png" alt="img"></p>
<center>图 7‑2  段标识符</center>

<p>逻辑空间：逻辑空间分为若干个段，其中每一个段都定义了一组具有完整意义的信息，逻辑地址对应于逻辑空间。</p>
<p>段： 段是对程序逻辑意义上的一种划分，一组完整逻辑意义的程序被划分成一段，所以段的长度是不确定的。</p>
<p>段描述符：段描述符段中的元素，用于描述一个段的详细信息的结构，段描述符一般是由8个字节组成。此外，又有很多段，就又相应多的段描述符，这些段描述符就组成了“段描述符表”。如图7-3所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image076.png" alt="img"></p>
<center>图 7‑3 段描述符的定义</center>

<p>​    逻辑地址到线性地址的转换过程：首先获取一个完整的逻辑地址[段选择符（段基值）：段内偏移地址], 看段选择描述符中的T1字段是0还是1，可以知道当前要转换的是GDT（全局段描述符）中的段，还是LDT（局部段描述符表）中的段，再根据指定的相应的寄存器，得到其地址和大小，我们就有了一个数组了。 拿出段选择符中的前13位，可以在这个数组中查找到对应的段描述符，这样就有了Base，即基地址就知道了，把基地址Base+Offset,就是要转换的下一个阶段的物理地址。如图7-4所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image077.png" alt="img"></p>
<center>图 7‑4 逻辑地址到线性地址的转换过程</center>



<h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>​    前面我们已经介绍到了，由逻辑地址经过段式管理得到线性地址，也就是虚拟地址，而又虚拟地址并不够，还需要物理地址，才能到磁盘上存取。而线性地址（虚拟地址VA）到物理地址（PA）之间的转换通过分页机制以及页式管理来完成。</p>
<p>​    概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，磁盘上数组的内容被缓存在物理内存。 这些内存块被称为页。</p>
<p>​    操作系统通过将虚拟内存空间以页为单位分割管理，一页大小4KB；类似地，物理内存空间也以页以页为单位分割管理，一页大小4KB。通过MMU，可以将虚拟地址映射到唯一物理地址。</p>
<p>​    由此引入页表的概念：页表是一个页表条目 (Page Table Entry, PTE)的数组，将虚拟页地址映射到物理页地址。如图7-5所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image078.png" alt="img"></p>
<center>图 7‑5 页表</center>

<p>​    MMU利用页表实现从虚拟地址到物理地址的变换。CPU中的一个控制寄存器，页表基址寄存器指向当前页表。</p>
<p>​    再介绍虚拟地址和物理地址的组成。</p>
<p>​    虚拟地址组成：虚拟地址由两部分组成VPN和VPO。VPN为虚拟页号，在虚拟地址高位位置；VPO为虚拟页偏移量，在虚拟地址低位位置。VA具体占用多少位，由系统环境决定；在Intel Core i7环境下，VPN占据高36位，VPO占据低12位。</p>
<p>​     物理地址组成：物理地址由两部分组成PPN和PPO。PPN为物理页号，在物理地址高位位置；PPO为物理页偏移量，在物理地址低位位置。PA具体占用多少位，由系统环境决定；在Intel Core i7环境下，PPN占据高40位，VPO占据低12位。</p>
<p>​    MMU利用VPN选择适当的PTE，如果这个PTE设置了有效位，则页命中，将页表条目中的物理页号和虚拟地址中的VPO连接起来就得到相应的物理地址。否则会触发缺页异常，控制传递给内核中的缺页异常处理程序。缺页处理程序确定物理内存中的牺牲页，调入新的页面，并更新内存中相应PTE。处理程序返回到原来的进程，再次执行导致缺页的指令，MMU重新进行地址翻译，此时和页命中的情况一样。</p>
<p>​    整个流程如下图：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image079.png" alt="img"></p>
<center>图 7‑6 基于页表的地址翻译</center>



<h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p>先介绍TLB的概念：TLB，也称翻译后备缓冲器，是在MMU中包括一个关于PTE的缓存。TLB是一个小的、虚拟寻址的缓存，每一行保存着一个由单个PTE组成的块。由于VA到PA的转换过程中，需要使用VPN确定相应的页表条目，因此TLB需要通过VPN来寻找PTE。和其他缓存一样，需要进行组索引和行匹配。如果TLB有2t个组，那么TLB的索引TLBI由VPN的t个最低位组成，TLB标记TLBT由VPN中剩余的位组成。如图7-7所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image080.png" alt="img"></p>
<center>图 7‑7 TLB的构成</center>

<p>​    接着介绍TLB的工作机制。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常快。</p>
<p>​    第1步:CPU产生一个虚拟地址。</p>
<p>​    第2步和第3步:MMU从TLB中取出相应的PTE。</p>
<p>​    第4步:MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</p>
<p>​    第5步:高速缓存/主存将所请求的数据字返回给CPU。</p>
<p>​    当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，如图7-8(b)所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image081.png" alt="img"></p>
<center>图 7‑8 TLB命中与不命中</center>

<p>​    再接着介绍多级页表的概念：多级页表可以用来压缩页表，对于k级页表层次结构，虚拟地址的VPN被分为k个，每个VPNi是一个到第i级页表的索引。当1≤j≤k-1时，第j级页表中的每个PTE指向某个第j+1级页表的基址。第k级页表中的每个PTE和未使用多级页表时一样，包含某个物理页面的PPN或者一个磁盘块的地址。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image082.png" alt="img"></p>
<center>图 7‑9 二级页表层次结构</center>

<p>​    再将页表翻译：首先四级页表中，第一级页表为第二级页表的索引，第二级页表为第三级页表的索引，第三级为第四级的索引，最终的第四级页表映射到物理地址。然后对虚拟地址进行划分，得到VPN，则根据VPN访问页表，根据页表判断相应地址的数据是否缓存，若缓存，可直接从页表中读出PPN，则VPO与PPN组成一个完整的物理地址，接下来便可访存。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image083.png" alt="img"></p>
<center>图 7‑10 使用4级页表的地址翻译</center>



<h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>​    先介绍cache的概念：高速缓存cache被组成一个有S=2s个高速缓存组的数组，每个组包含E个高速缓存行。每个是由一个B=2b字节的数据块组成，一个有效位指明这个行是否存储有意义的信息，还有t=m-b-s个标记为，唯一标识存在这个高速缓存的块。如图7-11所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image084.png" alt="img"></p>
<center>图 7‑11 cache的结构</center>

<p>​    再给出三级Cache的相关概念，Cache被分为三级。L1级cache作为L2级cache的缓存，L2级cache作为L3级cache的缓存，而L3级cache作为内存（DRAM）的缓存。而L1cache又分为指令cache和数据cache。如图7-11所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image085.png" alt="img"></p>
<center>图 7‑12 Core i7的内存系统</center>

<p>​    当我们进行进行物理内存访问时，先将物理地址发送给L1级cache，看L1级cache中是否缓存了需要的数据。L1级cache共64组，每组8行，块大小64Bytes。由之前cache的结构将物理地址分为三部分，块偏移6位，组索引6位，剩下的为标记位40位。首先利用组索引位进行组匹配找到对应的组，然后在组中进行行匹配找到对应的行，对于组中的8个行，分别查看有效位并将行的标记位与物理地址的标记位匹配，当标记位匹配且有效位是1时，缓存命中，根据块偏移位取出对应的块就课直接将cache中缓存的数据传送给CPU。如果缓存不命中，需要继续从存储层次结构中的下一层中取出被请求的块，将新块存储在相应组的某个行中，可能会替换某个缓存行。</p>
<p>​    L1级cache不命中时，会继续向L2级cache发送数据请求。和L1级cache的过程一样，需要进行组索引、行匹配和字选择，找到后将数据传送给L1级cache。如果L2级cache不命中时，则会继续向L3级cache发送数据请求。最后，L3级cache不命中时，只能从内存中请求数据了。</p>
<h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>​    前面在第6章我们讲hello的fork进程创建时，就已提到shell父进程为新创建的hello子进程提供了一个几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，其意思是当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程与子进程之间最大的区别在于它们拥有不同的 PID。为了给这个新进程创建虚拟内存，fork创建了当前进程的mm_struct，区域结构和页表的原样副本。fork将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记私有的写时复制。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image086.png" alt="img"></p>
<center>图 7‑13 一个共享的对象</center>

<p>​    当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中任一个后来进行写操作时，写时复制机制就会创建新页面。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image087.png" alt="img"></p>
<center>图 7‑14 一个私有的写时复制对象</center>

<h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>​    execve通过调用某个驻留在存储器中称为加载器的操作系统代码来运行hello，加载器将可执行目标文件中的代码和数据从磁盘中复制到内存中，然后通过跳转到程序的第一条指令或者入口点来运行该程序，当加载器运行时，会hello创建内存映像。加载并运行 hello 需要以下几个步骤：</p>
<ol>
<li><p>删除已存在的用户区域：删除当前进程虚拟地址的用户部分中的已存在的区域结构。</p>
</li>
<li><p>映射私有区域：为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 hello 文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零。</p>
</li>
<li><p>映射共享区域：hello 程序与共享对象（或者目标）链接，libc.so是动态链库，那么这些对象都是接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。</p>
</li>
<li><p>设置程序计数器（PC）：execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。</p>
<p>内存映射示意图如图7-15所示</p>
</li>
</ol>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image088.png" alt="img"></p>
<center>图 7‑15 加载器映射用户地址空间的区域</center>



<h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p>​    同样先给出缺页故障的概念，缺页故障：CPU产生一个虚拟地址给MMU，MMU经过一系列步骤获得了相应的PTE，当PTE的有效位未设置时，说明虚拟地址对应的内容还没有缓存在内存中，这时MMU会触发缺页故障。</p>
<p>​    而缺页故障则会使正在运行的程序陷入内核，从而触发缺页中断处理程序。缺缺页处理程序主要会执行以下三个步骤：</p>
<ol>
<li><p>判断虚拟地址是否合法。缺页处理程序搜索区域结构的链表，把虚拟地和每个区域结构中的vm_start和vm_end做比较。如果指令不合法，缺页处理程序会触发一个段错误，从而终止这个进程。</p>
</li>
<li><p>判断内存访问是否合法。比如缺页是否由一条试图对只读页面进行写操作的指令造成的。如果访问不合法，缺页处理程序会触发一个保护异常，从而终止这个进程。</p>
</li>
<li><p>此刻，内核知道这个缺页是由合法的操作造成的。内核会选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。处理程序返回时，CPU重新执行引起缺页的指令，这条指令将再次发送给MMU。这次，MMU能正常地进行地址翻译，不会再产生缺页中断了。</p>
</li>
</ol>
<p>Linux缺页处理如图7-16所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image089.png" alt="img"></p>
<center>图 7‑16 Linux缺页处理</center>



<h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>​    动态内存分配器维护着一个进程的虚拟内存区域，堆。假设堆为一个请求二进制零的区域，紧接在未初始化的数据区域（.bss）后开始，并向上生长（向更高的地址），对应每个进程，内核维护着一个brk，指向堆的顶部。</p>
<p>​    分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，块为已分配的或为空闲的。已分配的块显式地保留为供应用程序使用，已分配块保持已分配状态，直到它被释放，或被应用程序显式执行释放，或是内存分配器自身隐式执行释放。空闲块可用来分配，空闲块保持空闲，直到它被显式地被所应用分配。</p>
<p>​    分配器有两种基本风格，其都要求应用显式地分配块，不同之处在于哪个实体来负责释放已分配的块。</p>
<p>​    显式分配器，要求应用显式地释放任何已分配的块，如C语言的free函数。</p>
<p>​    隐式分配器，也称垃圾收集器，要求分配器检测一个已分配的块何时不再被程序所使用，然后释放这个块，代表有Java语言。</p>
<p>​    分配器的要求和目标：无法控制分配块的数量或大小；处理任意请求序列；立即响应请求；必须对齐块，使得它们可以保护任何类型的数据对象；只能操作或改变空闲块；一旦块被分配，就不允许修改或移动它了。</p>
<p>​    分配器的数据结构：</p>
<p>​    隐式空闲链表，在隐式空闲链表中，一个块是由一个字（4字节）的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有填充），且标记了这个块是已分配的还是空闲的，如图7-17所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image090.png" alt="img"></p>
<center>图 7‑17 隐式空闲链表的堆块格式</center>


<p>头部后面就是应用调用malloc时请求的有效载荷，有效载荷后面是一片不使用的填充块，其大小是任意的，满足对齐要求。</p>
<p>在设计完成了堆块的结构后，我们将一个对组织成为一个连续的已分配块和空闲块的序列，隐式空闲链表指的是并不直接对空闲块进行链接，而是将对内存空间中的所有块组织成一个大链表，其中头部和脚部中的信息隐式地起到连接的作用。如图7-18所示。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image091.png" alt="img"></p>
<center>图 7‑18 隐式空闲链表结构</center>

<p>​    放置策略主要有三种：</p>
<p>​    首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。</p>
<p>​    下一次适配：是从上一次查询结束的地方开始搜索空闲链表。</p>
<p>​    最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。</p>
<p>​    分割：放置时，可能分配块空间远大于我们实际需要空间大小，可以选择分割。</p>
<p>​    一旦分配器找到一个匹配的空闲块，就必须做一个另一个策略决定，那就是分配这个块多少空间。分配器通常将空闲块分割为两部分，第一部分变为分配块，剩下的变成一个新的空闲块。</p>
<p>​    合并空闲块：在带边界标签的隐式空闲链表分配器下有4中情况：前面的块和后面的块都是已分配的，则就直接将当前块释放，不合并；前面的块和后面的块都是空闲的，那么将这三块合并；前面的块空闲后面的块已分配，将前一个块和当前块合并；前面的块已分配后面的块空闲，当前块和后面的块合并。</p>
<p>​    此外较为常用的是显式空间链表。显式空闲链表是将空闲块组织为某种形式的显式数据结构。堆被组织为一个双向空闲链表，在每个空闲块中，都包含一个前驱和后继的指针。</p>
<p>​    块结构如下：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image092.png" alt="img"></p>
<center>图 7‑19 显式空间链表的堆块结构</center>

<p>链表结构如图7-20所示：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image093.png" alt="img"></p>
<center>图 7‑20 显式空间链表结构</center>

<p>​    使用双向链表而不是隐式空闲链表，使得首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。</p>
<p>​    一种方法是用后进先出的顺序维护链表，将新释放的块放置在链表的开始处。使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在常数时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。</p>
<p>​    另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比LIFO排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。</p>
<p>​    一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p>
<h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>​    本章主要先是介绍了逻辑地址、线性地址、虚拟地址、物理地址的概念，由此引入段式管理将逻辑地址翻译到线性地址，再到页式管理将虚拟地址翻译到物理地址，这一连串地址的转化及之间关系的论述，再到更为复杂的TLB及四级页表，三级cache，是对计算机存储系统的一个全面的回顾。此外，还探讨了一个程序在运行时，父进程与其共享的虚拟映射，讲到了写时复制以及缺页处理等等，明晰了进程与存储的关系。</p>
<p>（第7章 2分）</p>
<h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><p>​    设备的模型化：文件</p>
<p>​    一个linux文件就是一个m个字节的序列：B0, B1, … Bk, …, Bm-1</p>
<p>​    所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。</p>
<p>​    每个Linux文件都有一个类型(type)来表明它在系统中的角色:</p>
<ol>
<li><p>普通文件(regular file)包含任意数据。应用程序常常要区分文本文件(text file)和二进制文件(binary file)，文本文件是只含有ASCII或Unicode字符的普通文件;二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。</p>
</li>
<li><p>目录( directory)是包含一组链接(link)的文件，其中每个链接都将一个文件名(filename)映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目:“.”是到该目录自身的链接，以及“..”是到目录层次结构(见下文)中父目录( parent directory)的链接。你可以用mkdir命令创建一个目录，用ls查看其内容，用rmdir删除该目录。</p>
</li>
<li><p>套接字(socket)是用来与另一个进程进行跨网络通信的文件。</p>
</li>
</ol>
<p>​    其他文件类型包含命名通道(named pipe)、符号链接(symbolic link)，以及字符和块设备(character and block device)。 </p>
<p>​    设备管理：unix io接口</p>
<p>​    所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：Unix I/O</p>
<h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><p>​    Unix IO 接口，使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ol>
<li>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，即描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</li>
<li>Linux shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）和标准错误（描述符为2）。头文件中的常量可以代替显式的描述符值。</li>
<li>改变当前的文件位置：对于每个打开的文件，内核保持着一个文件位置 k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。</li>
<li>读写文件：一个读操作就是从文件复制n&gt;0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发EOF条件，应用程序能检测到这个条件。类似地，写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。</li>
<li>关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</li>
</ol>
<p>Unix I/O函数:</p>
<ol>
<li> 进程通过调用open函数打开一个存在的文件或者创建一个新文件。</li>
</ol>
<p>   函数声明：int open(char* filename,int flags,mode_t mode);</p>
<p>   open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件；mode参数指定了新文件的访问权限位。</p>
<p>   ​    flags参数如下：</p>
<p>   ​        O_RDONLY：只读</p>
<p>   ​        O_WDONLY：只写</p>
<p>   ​        O_RDWR：可读可写</p>
<p>   ​        O_CREAT：如果文件不存在，就创建它的一个截断的空文件</p>
<p>   ​        O_TRUNC：如果文件已经存在，就截断它</p>
<ol start="2">
<li><p>进程通过调用close函数关闭一个打开的文件，所需头文件： #include &lt;unistd.h&gt;。</p>
<p>函数声明：int close（int fd）;</p>
<p>fd是需要关闭的文件描述符，成功返回0，错误返回-1。关闭一个已关闭的描述符会出错。</p>
</li>
<li><p>应用程序通过分别调用read和write函数来执行输入和输出，所需头文件： #include &lt;unistd.h&gt;</p>
<p>函数声明如下：</p>
<p>ssize_t read(int fd,void *buf,size_t n);</p>
<p>ssize_t wirte(int fd,const void *buf,size_t n);</p>
<p>read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置buf。返回值-1表示一个错误，而返回值0表示EOF。否则返回值表示的是实际传送的字节数量；write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。</p>
</li>
</ol>
<h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p><a href="https://www.cnblogs.com/pianist/p/3315801.html">https://www.cnblogs.com/pianist/p/3315801.html</a></p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image094.png" alt="img"></p>
<center>图 8‑1printf函数的源代码</center>

<p>​    然后观察发现其调用了一个我们没见过的vsprintf函数，此外还有我们前面提到的write函数。先分析这个vsprintf函数。</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image095.png" alt="img"></p>
<center>图 8‑2 vsprintf函数的源代码</center>

<p>​    仔细观察发现 vsprintf他对传进来的字符串，循环判断是否为‘%’，或‘x’,或‘s’，在循环中用参数替换占位符，最后返回的整数类型，返回的是要打印出来的字符串的长度，vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt，用格式字符串对个数变化的参数进行格式化，产生格式化输出。</p>
<p>  然后再到write函数的分析，write，写操作，把buf中的i个元素的值写到终端，引发系统调用syscall，显示格式化了的字符串，字符串的每个字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。</p>
<p>​    显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p>
<h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>​    同样先研究getchar函数的源代码：</p>
<p><img src="/2021/06/27/Hello%E7%9A%84%E4%B8%80%E7%94%9F/image096.png" alt="img"></p>
<center>图 8‑3 getchar函数源代码</center>

<p>​    观察源代码发现，getchar调用了read函数，从标准输入缓冲区读取BUFSIZE个字符到静态字符串数组buf中，从缓冲区中返回一个字符，而当缓冲区字符个数为0时，则返回EOF，表示读到文件末尾。getchar函数的返回值是用户输入的字符的ASCII码。若用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中，等待后续getchar继续读取，则后续的getchar调用不会等待用户按键，而会直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才等待用户按键。</p>
<p>​    异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。</p>
<p>​    getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p>
<h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>​    这一章主要介绍了hello的IO管理，简述了文件的概念，以及unix I/O的接口和函数，同时分析了库函数printf和getchar函数的实现。以此为基础，了解我们的hello程序是如何在屏幕上输出的，同时其中调用getchar函数获取我们的输入等等，</p>
<p>（第8章1分)</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>​    用计算机系统的语言，逐条总结hello所经历的过程。</p>
<p>​    hello这个源程序不过短短几行而已，同时也并不是很难，但从其出生到死亡可谓是漫长而又丰富的一段历程，其中它遇到了许多“人”，为其服务，帮助他成长，下面一条条简要论述。</p>
<ol>
<li><p>编写源程序：在IDE中用c语言编写代码，形成hello.c文件（文本文件）。</p>
</li>
<li><p>预处理：hello.c经过预处理器cpp处理，处理开头的预处理指令，将库文件加到文件中，解析宏定义，生成一个hello.i文件，一个修改了的源文件（文本文件）。</p>
</li>
<li><p>编译：hello.i文件经过编译器（ccl）处理，将c语言高级语言翻译成汇编语言，生成hello.s汇编文件（文本文件）。</p>
</li>
<li><p>汇编：hello.s经过汇编器as处理，编译成机器代码，生成可重定位目标文件hello.o文件）。</p>
</li>
<li><p>链接：hello.o可重定位目标文件经链接器lld和动态链接库链接，实现重定位，生成可执行目标程序hello（二进制文件）</p>
</li>
<li><p>fork创建进程：在终端输入运行hello的指令，shell为hello程序fork子进程。</p>
</li>
<li><p>execve加载运行程序：子进程中调用execve函数，加载并运行hello程序，进入hello的程序入口点，hello开始运行。</p>
</li>
<li><p>进程管理：内核负责调度进程，进行上下文切换，在用户模式和内核模式之间切换。</p>
</li>
<li><p>内存管理：hello运行需要读取指令和数据。MMU、TLB、多级页表、cache、DRAM内存、动态内存分配器相互协作，共同完成内存的管理。Unix I/O使得程序与文件进行交互。</p>
</li>
<li><p>信号处理：程序运行过程中，会碰到各种异常和接收到各种信号比如来自键盘的输入，调用异常处理程序处理这些异常和信号。</p>
</li>
<li><p>终止：hello走到生命的最后，终止运行，shell回收hello进程及相关资源，内核删除为hello进程创建的所有数据结构，hello丰富的一生结束了。</p>
<p>对计算机系统的设计与实现的深切感悟:</p>
</li>
</ol>
<p>​    计算机系统这门课，可以说是每个程序员的必修课，要不然对于程序的理解永远是肤浅的。上完数据结构和算法这些课程后，我并没有太强烈的感觉成为了一个程序员，就是写代码、设计数据结构、设计算法来编写代码运行完成所要实现的需求就完了，说白了就是对高级语言语法的掌握和数据结构、算法的设计，其中重要的编写代码的逻辑。但是在上完计算机系统后，了解了一个编写的程序到底是怎么在计算机上运行的整个过程，其并不是我们简单地点一下运行就好了，其中发生了经历许多的变化，我感觉对程序地运行有了更深的理解、以及对更底层的理解。不再是前面的代码编写的软件部分，开始触碰到硬件，软硬结合， 威力无边。正如书所说，真正开始以一个程序员的角度看待程序，可谓是豁然开朗之感。</p>
<p>​    计算机系统的设计与实现经常让我发出惊叹，如此巧妙，又如此神奇，将计算机如此一个庞大、复杂的结构、体系层层相扣，从最基础的电路的有电没电，到高级语言程序的编写，而这样的体系在短短不到100年就发展起来，着手神奇。</p>
<p>​    总之，这门课受益匪浅，意犹未尽，感谢老师的辛苦教学。</p>
<p>​    个人博客地址：<a href="https://1nvisble.github.io/">https://1nvisble.github.io/</a></p>
<p>​    CSDN论文博客地址：<a href="https://blog.csdn.net/weixin_45961864/article/details/118282290">https://blog.csdn.net/weixin_45961864/article/details/118282290</a></p>
<h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>列出所有的中间产物的文件名，并予以说明起作用。</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>文件作用</th>
</tr>
</thead>
<tbody><tr>
<td>hello.c</td>
<td>保存hello源代码即源文件</td>
</tr>
<tr>
<td>hello.i</td>
<td>经过预处理的修改了的源文件</td>
</tr>
<tr>
<td>hello.s</td>
<td>编译器编译hello.i生成的汇编文件</td>
</tr>
<tr>
<td>hello.o</td>
<td>编译器编译hello.s生成的可重定位目标文件</td>
</tr>
<tr>
<td>hello.elf</td>
<td>hello.o文件的ELF格式文件，查看hello.o各节的信息</td>
</tr>
<tr>
<td>hello.txt</td>
<td>objdump反汇编hello.o生成的汇编文件与hello.s对比</td>
</tr>
<tr>
<td>hello</td>
<td>链接器重定位、链接生成的可执行目标文件</td>
</tr>
<tr>
<td>hello2.elf</td>
<td>hello文件的ELF格式文件，查看hello各节的信息</td>
</tr>
<tr>
<td>hello2.txt</td>
<td>objdump反汇编hello文件生成的汇编文件</td>
</tr>
</tbody></table>
<p>（附件0分，缺失-1分）</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><strong>为完成本次大作业你翻阅的书籍与网站等</strong></p>
<p>[1] 图中部分图片来源于老师上课PPT</p>
<p>[2] 图中部分图片来源于书籍《深入理解计算机系统》第三版。</p>
<p>[3] <a href="https://www.runoob.com/linux/linux-comm-pstree.html">https://www.runoob.com/linux/linux-comm-pstree.html</a></p>
<p>[4] <a href="https://www.runoob.com/cprogramming/c-function-vsprintf.html">https://www.runoob.com/cprogramming/c-function-vsprintf.html</a></p>
<p>[5] <a href="https://blog.csdn.net/yusiguyuan/article/details/9664887">https://blog.csdn.net/yusiguyuan/article/details/9664887</a></p>
<p>[6] <a href="https://blog.csdn.net/cherisegege/article/details/80708143">https://blog.csdn.net/cherisegege/article/details/80708143</a></p>
<p>[7]  <a href="https://blog.csdn.net/weixin_41571493/article/details/80692749">https://blog.csdn.net/weixin_41571493/article/details/80692749</a></p>
<p>（参考文献0分，缺失 -1分)</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>CSAPP</tag>
        <tag>计算机系统</tag>
      </tags>
  </entry>
</search>
