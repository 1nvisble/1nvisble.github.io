<hr>
<p>title: Java代理模式（Proxy理解）.<br>categories: [Java,设计模式]<br>tags: Java</p>
<hr>
<h1 id="Java代理模式-Proxy-理解"><a href="#Java代理模式-Proxy-理解" class="headerlink" title="Java代理模式(Proxy)理解"></a>Java代理模式(Proxy)理解</h1><h2 id="代理模式概念简述"><a href="#代理模式概念简述" class="headerlink" title="代理模式概念简述"></a>代理模式概念简述</h2><p>首先，代理模式是一种<strong>设计模式</strong>。</p>
<p>先给出代理模式的概念：代理模式是指通过<strong>代理对象</strong>访问目标对象，而不是直接访问目标对象，通过字面理解即可，要通过一个代理人或者说中间人来访问我们想要访问的对象。举例就像房屋中介，买房人不想自己去一个找房主询问其是否卖房，而卖房人也不想麻烦去一个个找买房人，中介就承担起这个功能，买房人（用户）通过中介（代理对象）获知在售的其意向房产的信息（如房价、面积、位置等的）。</p>
<p>那么为什么要有代理模式呢？其好处是可以在目标对象实现的基础上，增强额外的功能操作，即拓展目标对象的功能，如添加权限进行访问控制和审计等功能，其中举添加权限这个功能说明，通过代理对象判断访问目标对象的用户是否拥有访问的权限，没有则禁止访问，实现对信息的一个保护。</p>
<p>同时，代理模式也是遵循了设计思想中类的单一性原则，就是每个类功能应该单一，即专一，就是说什么人干什么事，一个人尽可能负责一个工作，同时也是去尽量实现低耦合。</p>
<p><img src="C:\Users\admini\AppData\Roaming\Typora\typora-user-images\image-20210622190510605.png" alt="image-20210622190510605"></p>
<p>代理模式要着重理解代理对象和目标对象的概念，代理对象是对目标对象的扩展,并会调用目标对象。就像房屋中介调用目标对象（卖房人）获取其房产信息，但不仅限于房产信息，房屋中介还会审计其掌握的房产资源，而后挑选合适的房产给买房人。</p>
<h2 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h2><p>代理模式主要分为三类：</p>
<p> 1.静态代理；</p>
<p> 2.动态代理；</p>
<p> 3.Cglib代理。</p>
<p>下面分别论述。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。需要注意的是，代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。</p>
<p>优点：在不修改目标对象的功能前提下,可以实现对目标对象功能的扩展。</p>
<p>缺点：</p>
<ol>
<li><p>代理对象必须提前写出（在编译期就已经知道了代理对象），如果接口层发生了变化，代理对象的代码也要进行维护。</p>
</li>
<li><p>因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多，导致一旦接口增加方法,目标对象与代理对象都要维护。</p>
</li>
</ol>
<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="动态代理的下特点"><a href="#动态代理的下特点" class="headerlink" title="动态代理的下特点"></a>动态代理的下特点</h4><p>1.代理对象,不需要实现接口；<br>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)；<br>3.动态代理也叫做: JDK代理,接口代理。</p>
<p><strong>JDK中生成代理对象的API</strong><br>代理类所在包:java.lang.reflect.Proxy</p>
<p><strong>总结</strong>：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理。</p>
<p>优点：JDK动态代理解决了静态代理中需要创建多个代理类的问题。</p>
<p>缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，假如没有，则可以使用Cglib代理<strong>。</strong></p>
<h4 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h4><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p>
<p>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p>
<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。</p>
<p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)。</p>
<p>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>Cglib子类代理实现方法:</p>
<ol>
<li>需要引入cglib的jar文件,但是因为pring的核心包中已经包括了Cglib功能,所以可以直接引入<code>pring-core-3.2.5.jar</code>。</li>
<li>引入功能包后,就可以在内存中动态构建子类</li>
</ol>
